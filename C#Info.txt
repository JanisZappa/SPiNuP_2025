7/8/2020 -- 0:5


494    Total C# Files
429 Filtered C# Files

-- -- -- -- --
51292    Total Lines
25701 Filtered Lines

13347 Empty
  706 Comments
 1014 Usings
  180 Hashs
10344 Squigglys
-- -- -- -- --


456 - LevelSection.cs              75 - EyeTest.cs                  33 - clipType.cs               15 - Bary.cs
427 - Level.cs                     74 - UniqueList.cs               33 - Digit.cs                  15 - HouseDataViewer.cs
422 - HousePiecePlacer.cs          73 - Interaction.cs              32 - FovAdjust.cs              15 - HouseZone.cs
398 - ParseElementJSON.cs          73 - Bump.cs                     31 - FilterTest.cs             15 - Color32AsCord.cs
369 - ActorAnimator.cs             72 - Squash.cs                   31 - ListMenuItems.cs          14 - StructTest.cs
364 - HouseDraw.cs                 72 - ShapeLineDrawer.cs          31 - Stick.cs                  14 - PoolDebug.cs
343 - ConnectWithArcs.cs           71 - Quad.cs                     31 - UI_SpinUp.cs              14 - BounceLight.cs
316 - HouseGen.cs                  70 - UsedKeys.cs                 31 - ShapeMesher.cs            14 - PaletteSource.cs
303 - Prediction.cs                69 - vector2Ext.cs               31 - EdgeMeshCreation.cs       13 - SetRenderPipeline.cs
294 - ShapeSegment.cs              68 - ServerTime.cs               30 - CamDebug.cs               13 - Layers.cs
291 - NewColorGen.cs               67 - ConvexHull.cs               30 - Side.cs                   13 - CellLineTest.cs
281 - PathSearch.cs                66 - LevelCheck.cs               30 - ShowVersion.cs            13 - Simplify.cs
277 - UI_Creator.cs                66 - Pool.cs                     29 - Rectangle.cs              13 - V2.cs
277 - Outline.cs                   66 - Boundary.cs                 29 - ThreadClub.cs             13 - WallHole.cs
273 - SpinnerDebug.cs              65 - MultiCam.cs                 29 - Encryption.cs             13 - SpinnerContact.cs
269 - LevelDebug.cs                65 - HouseDebugCam.cs            29 - BodyPartMesh.cs           13 - OccilationTest.cs
260 - ElementMask.cs               64 - ListUniqueMeshes.cs         28 - Proximity.cs              12 - SceneLocator.cs
260 - Swing.cs                     64 - StaticConstructor.cs        28 - Crunch.cs                 12 - CharColors.cs
253 - Login.cs                     64 - ShapeFacingDrawer.cs        28 - Height.cs                 12 - AllTrackMeshes.cs
249 - LevelSaveLoad.cs             64 - EdgeMesh.cs                 28 - EditorCamControll.cs      12 - TimedLightSource.cs
227 - Track.cs                     63 - Score.cs                    28 - Timer.cs                  12 - DigitTest.cs
216 - Jump.cs                      62 - Creator_Edit.cs             28 - GarbageRect.cs            12 - Emoji.cs
211 - Sound.cs                     62 - Leaderboard.cs              28 - floatExt.cs               12 - NameGameObjectLikeScript.cs
209 - Turd.cs                      62 - ThinkingPanel.cs            28 - FillMesher.cs             12 - HashSetInit.cs
199 - elementType.cs               62 - PaletteSourceEditor.cs      27 - Supercover.cs             12 - CastShadow.cs
192 - ShapeTest.cs                 61 - CharPartIndex.cs            27 - Mood.cs                   12 - LightColorTestObject.cs
179 - PlacerMeshes.cs              61 - LevelSectionTest.cs         27 - Spawn.cs                  12 - LineCircleAllign.cs
177 - HouseData.cs                 61 - FancyString.cs              27 - PerlinNoiseCheck.cs       11 - MusicSideSpeed.cs
171 - BasicShapes.cs               60 - SunDir.cs                   27 - RigBone.cs                11 - BatchAndScale.cs
170 - Cell.cs                      60 - LevelList.cs                26 - MeshColorSwap.cs          11 - None.cs
164 - Shape.cs                     60 - listExt.cs                  26 - ShapeMeshSet.cs           11 - BadFrame.cs
155 - ForceAnim.cs                 59 - CustomMaterialEditor.cs     26 - TrackTest.cs              11 - SceneryEyes.cs
154 - QuickBuild.cs                58 - PauseCam.cs                 25 - UserSave.cs               11 - CollectionInit.cs
153 - Frustum.cs                   57 - BotControll.cs              25 - SoundSchedule.cs          11 - GroupSelection.cs
148 - ReplayGetter.cs              57 - AudioTypes.cs               25 - LevelInfo.cs              11 - _SoundPack.cs
146 - Rig.cs                       57 - Tri.cs                      25 - Bouncy.cs                 11 - IntListTest.cs
145 - RigPoser.cs                  57 - TimeSliderUI.cs             25 - BoolSwitchToggle.cs       11 - ArcDebug.cs
144 - AllTracks.cs                 57 - MobileAspectDektopCams.cs   25 - StoreOldMeshes.cs         10 - CharacterAsMusicSourceTest.cs
143 - EdgeMesher.cs                56 - ShaderPaletteInit.cs        25 - IntersectionTest.cs       10 - SkyUpdate.cs
141 - LevelSectionDraw.cs          56 - RigHead.cs                  24 - KeyPressCheck.cs          10 - Curves.cs
139 - ClubMaster.cs                55 - SideSwitcher.cs             24 - UI_ElementInfo.cs         10 - V3.cs
139 - collisiontest.cs             55 - ChordBend.cs                24 - Shadow.cs                 10 - serializeExt.cs
136 - ScriptCreator.cs             54 - ListMaterials.cs            24 - BendLine.cs               10 - transformExt.cs
136 - InterfaceTest.cs             54 - LevelElements.cs            24 - BotPlayers.cs             10 - FittingRectangle.cs
130 - Circle.cs                    53 - ScriptCreatorWindow.cs      24 - pumpRingTest.cs           10 - BGPieceCounterUI.cs
129 - SmoothBind.cs                53 - CircleSquare.cs             24 - SmallestFitCircle.cs      10 - MeshCam.cs
128 - UI_Manager.cs                52 - ElementInfo.cs              23 - TableLine.cs              10 - OldRig.cs
127 - Link.cs                      52 - ShapeCollision.cs           23 - AirLaunch.cs               9 - GarbageMachine.cs
127 - MeshDraw.cs                  52 - PlayerNameUI.cs             23 - ShadowTestToggle.cs        9 - StaticBounceLight.cs
126 - MoveCam.cs                   51 - AngleCam.cs                 23 - AccessRandomizer.cs        9 - Run.cs
126 - Anim_Jump.cs                 51 - ScoreUI.cs                  23 - DesktopTxt.cs              9 - RectRotation.cs
121 - SpinnerSpineShadow.cs        51 - DrawMeshesTest.cs           23 - CoinShadow.cs              9 - MeshDrawTest.cs
120 - ColorTools.cs                51 - RigBendPart.cs              23 - SpinnerShadow.cs           8 - WallAllign.cs
119 - HouseOcclusion.cs            50 - CircleAllign.cs             22 - Branch.cs                  8 - Wireframe.cs
118 - RigPart.cs                   49 - HouseMesher.cs              22 - PaletteDebug.cs            8 - VectorCompare.cs
117 - Bounds2D.cs                  48 - TrackMesh.cs                22 - AppControllWindow.cs       8 - Flower.cs
116 - DRAWHelp.cs                  48 - Fade.cs                     22 - FovAdjustEditor.cs         8 - DebugLogToggle.cs
116 - SmoothBindBounce.cs          48 - MultiMesh.cs                22 - FrameTimeCalc.cs           8 - FloatEasing.cs
115 - Database.cs                  47 - InfoPanelUpdate.cs          22 - ExeEscQuit.cs              8 - HirarchyBlurbEditor.cs
115 - GridRegions.cs               47 - NewSpinnerShadow.cs         22 - QuickList.cs               8 - ZeroTransform.cs
114 - Controll.cs                  46 - ShakeRewind.cs              22 - RadAngleTest.cs            8 - wobble.cs
113 - GameManager.cs               46 - Palette.cs                  21 - SetVolume.cs               8 - PaletteEditor.cs
112 - JumpInfo.cs                  45 - MeshExt.cs                  21 - Vector2IntExt.cs           7 - LevelDevFilter.cs
112 - StackTangle.cs               44 - QualitySwitches.cs          21 - PowTest.cs                 7 - NonDrawingGraphic.cs
111 - MarchingSquares.cs           44 - FrameCounter.cs             21 - bouncy.cs                  7 - PillUI.cs
111 - OccluderPacking.cs           44 - WallPatcher.cs              21 - GeoTest.cs                 7 - NonDrawingGraphicEditor.cs
110 - arrayExt.cs                  44 - LerpTests.cs                20 - ColorPacking.cs            7 - FocusSpinnerDebug.cs
109 - Item.cs                      43 - ScreenControll.cs           20 - BlurCam.cs                 7 - MaskCheck.cs
108 - Clip.cs                      43 - _SceneLighting.cs           20 - New_LevelBrain.cs          7 - SimpleAxisRotation.cs
107 - ByteReplays.cs               43 - ThreadingTest.cs            20 - ActorDebug.cs              7 - boolExt.cs
107 - Collector.cs                 42 - ReplaySaveLoad.cs           20 - byteArrayExt.cs            7 - randomExt.cs
107 - Anim.cs                      42 - info.cs                     19 - Mode_SpinUp.cs             7 - RotCompare.cs
106 - Line.cs                      42 - CreateCharPartsIndex.cs     19 - ItemCheck.cs               7 - BoolArrayTest.cs
106 - ScoreStick.cs                42 - RigHelp.cs                  19 - EditorCoroutine.cs         6 - FloorColor.cs
104 - GPhysics.cs                  42 - CircleIntersection.cs       19 - JointsOnChain.cs           6 - MainMenu.cs
103 - Tape.cs                      42 - ColorMap.cs                 19 - LightColorTest.cs          6 - LayoutToggle.cs
103 - Spinner.cs                   41 - LinkEdit.cs                 19 - OverlapTest.cs             6 - CloudMoveTest.cs
102 - Arc.cs                       41 - OwnBounds.cs                19 - CamTilt.cs                 6 - Singleton.cs
101 - KeyMap.cs                    41 - ImpactSquashTest.cs         18 - Creator_Misc.cs            6 - ClearConsole.cs
100 - Triangulator.cs              40 - WallMaster.cs               18 - HeightAmbience.cs          6 - stringbuilderExt.cs
 98 - Creator_New_Copy_Delete.cs   40 - ShowUsedColorHues.cs        18 - Probe.cs                   6 - LineSide.cs
 97 - BenchmarkKing.cs             39 - Assets.cs                   18 - ByteStream.cs              5 - PrintColorValue.cs
 97 - HouseRules.cs                39 - HirarchyBlurb.cs            18 - MergeMesh.cs               5 - StringDisplay.cs
 96 - ParseGroupJSON.cs            39 - SampleFloor.cs              18 - OffsetTest.cs              5 - SceneRestart.cs
 95 - Bezier.cs                    39 - FuckingCircleShit.cs        18 - ActivateInRow.cs           4 - LevelSeed.cs
 95 - AnimData.cs                  39 - AnimationHandler.cs         17 - ScaleWall.cs               4 - MoveCamTest.cs
 95 - EdgeMaster.cs                38 - SpinnerIndicator.cs         17 - V3Volume.cs                4 - DebugPulse.cs
 94 - Poof.cs                      38 - PrefValue.cs                17 - rendererExt.cs             4 - FirstUpdate.cs
 94 - SkinnedMeshItems.cs          38 - SceneLightLerp.cs           17 - SliderMapping.cs           4 - StreamWriterExt.cs
 93 - colorExt.cs                  38 - EditorFrame.cs              16 - Leaf.cs                    4 - NewContactShadow.cs
 89 - Anim_Swing.cs                38 - SegmentBend.cs              16 - ToggleUI.cs                4 - CapsuleRadius.cs
 89 - ShowClips.cs                 38 - ManageBGMeshes.cs           16 - DebugDrawUpdate.cs         4 - LerpTest.cs
 88 - AllSpinner.cs                37 - Coin.cs                     16 - ThinkingList.cs            3 - BatchThis.cs
 88 - vector3Ext.cs                37 - UI_LevelList.cs             16 - PrintKeycode.cs            3 - LevelSaveFile.cs
 87 - GTime.cs                     37 - BoolSwitchKeyToggle.cs      16 - Rot.cs                     3 - PathResourceInst.cs
 86 - Mth.cs                       37 - PoseUI.cs                   16 - BlankSpace.cs              3 - placementExt.cs
 86 - HLSColor.cs                  37 - ReplayFun.cs                16 - byteExt.cs                 3 - timespanExt.cs
 81 - Actor.cs                     37 - HouseHelp.cs                16 - SquashTest.cs              3 - ArCamMovementTest.cs
 81 - FindBestPalette.cs           37 - MeshPaletteColor.cs         16 - ArcRaycastTest.cs          3 - MainMatEditor.cs
 81 - RigDebug.cs                  37 - UpdatePalette.cs            16 - ZoneCornerTest.cs          2 - Environmentor.cs
 80 - ElementEdit.cs               36 - Groups.cs                   15 - WebGLMessageListener.cs    2 - AntiAliasingToggle.cs
 80 - ParseClipJSON.cs             35 - Creator_Mode.cs             15 - CamManager.cs              2 - SignRandom.cs
 79 - LightingSet.cs               35 - Group.cs                    15 - NumGen.cs                  2 - ContactShadow.cs
 79 - HoudiniImport.cs             35 - intExt.cs                   15 - Dead.cs                    1 - Cuby.cs
 78 - CostumeColors.cs             34 - LightManager.cs             15 - Frame.cs                   1 - OldMeshes.cs
 78 - HeringboneWang.cs            34 - gameobjectExt.cs            15 - Screeny.cs                
 75 - GameCam.cs                   34 - MapCam.cs                   15 - ProbeShadow.cs            
 75 - Shake.cs                     34 - InstancingTest.cs           15 - MapToARCam.cs             


-- -- -- -- --

- Filtered Lines -

publicclassColorPacking:MonoBehaviour
[Range(0,4095)]
publicintcolorID;
[Range(0,3)]
publicintmatCap;
[Header("Floats")]
publicfloatr,g;
[Header("Results")]
publicintresultID,resultMatCap;
privatevoidUpdate()
intmatCapOffset=Mathf.FloorToInt(colorID/256.0f);
intcolorValue=colorID%256;
intmatCapValue=matCapOffset*16+matCap;
r=colorValue/256.0f;
g=matCapValue/256.0f;
intcolorValue=Mathf.FloorToInt(r*256.0f);
intmatCapValue=Mathf.FloorToInt(g*256.0f);
intmatCapOffset=Mathf.FloorToInt(matCapValue/16.0f);
resultID=matCapOffset*256+colorValue;
resultMatCap=matCapValue%16;
publicstaticclassKeyPressCheck
publicstaticreadonlyKeyCheckMouse0Key=newKeyCheck(KeyCode.Mouse0),
Mouse1Key=newKeyCheck(KeyCode.Mouse1);
publicclassKeyCheck
publicIKeyOwnerowner;
publicreadonlyKeyCodekeyCode;
publicKeyCheck(KeyCodekeyCode)
this.keyCode=keyCode;
publicboolDown(IKeyOwnerowner)
if(Input.GetKeyDown(keyCode)&&this.owner==null)
this.owner=owner;
returntrue;
returnfalse;
publicboolHold(IKeyOwnerowner)
if(Input.GetKey(keyCode)&&(this.owner==null||this.owner==owner))
this.owner=owner;
returntrue;
returnfalse;
publicboolUp(IKeyOwnerowner)
if(Input.GetKeyUp(keyCode)&&this.owner==owner)
this.owner=null;
returntrue;
returnfalse;
publicinterfaceIKeyOwner{}
publicclassPoof:MonoBehaviour
publicMesh[]poofs;
privatestaticStack<PoofTransform>pool;
privatestaticList<PoofTransform>active;
privateclassPoofTransform
privateconstfloatspeed=2.4f,duration=1f/speed;
privatefloatstart,end;
privatereadonlyTransformtrans;
privatereadonlyMeshRenderermR;
privatereadonlyMeshFiltermF;
privateSpinnerspinner;
privateItemitem;
privateQuaternionrot;
privatefloatspin;
publicstaticMesh[]poofMeshes;
publicPoofTransform(Transformtrans)
this.trans=trans;
mF=trans.GetComponent<MeshFilter>();
mR=trans.GetComponent<MeshRenderer>();
mR.enabled=false;
publicvoidSetup(Spinnerspinner,Itemitem,Vector3dir,floatspin,floatstart)
this.spinner=spinner;
this.item=item;
this.spin=spin.SignAdd(1)*15;
this.start=start;
end=start+duration;
rot=Quaternion.LookRotation(Vector3.forward,dir);
mF.mesh=GetMesh(item.elementType);
publicPoofTransformDisable()
mR.enabled=false;
returnthis;
publicboolUpdate(floattime)
if(time-GTime.RewindTime>end)
mR.enabled=false;
returnfalse;
floatlerp=(time-start)/duration;
mR.enabled=lerp>0&&lerp<1;
lerp=Mathf.Clamp01(lerp);
floatangle=(1-Mathf.Pow(1-lerp,1.5f))*20;
QuaternionspinRot=Quaternion.AngleAxis(lerp*spin,Vector3.forward)*rot;
trans.rotation=spinRot*Quaternion.AngleAxis(angle,Vector3.up);
trans.position=item.GetLagPos(time).V3(Level.GetPlaneDist(item.side))+spinRot*Vector3.up*(.7f+(1-Mathf.Pow(1-lerp*.75f,4))*1.4f);
constfloatfirst=.75f,multi=1/first,multi2=1/(1-first);
floatscaleLerp;
floatyScale;
if(lerp<first)
floatl=lerp*multi;
scaleLerp=1-Mathf.Pow(1-l,8);
yScale=.4f*Mathf.Pow(1-l,4)+1f;
else
floatl=(lerp-first)*multi2;
scaleLerp=Mathf.Pow(1-l,3.2f);
yScale=1f-.1f*Mathf.Pow(1-l,2);
trans.localScale=newVector3(scaleLerp,yScale*scaleLerp,scaleLerp)*.8f;
returntrue;
publicboolClearedAfter(Spinnerspinner,floattime)
returnthis.spinner==spinner&&time<=start;
privateMeshGetMesh(elementTypetype)
switch(item.elementType)
default:returnpoofMeshes[0];
caseelementType.WarpStickA:returnpoofMeshes[1];
caseelementType.WarpStickB:returnpoofMeshes[2];
caseelementType.WarpStickC:returnpoofMeshes[3];
caseelementType.WarpStickD:returnpoofMeshes[4];
privatevoidAwake()
pool=newStack<PoofTransform>();
Transformdummy=transform.GetChild(0);
pool.Push(newPoofTransform(dummy));
for(inti=0;i<19;i++)
pool.Push(newPoofTransform(dummy.gameObject.CopyAndParent(true).transform));
active=newList<PoofTransform>(20);
PoofTransform.poofMeshes=poofs;
privatevoidLateUpdate()
intcount=active.Count;
for(inti=0;i<count;i++)
if(!active[i].Update(GTime.Now))
pool.Push(active.GetRemoveAt(i));
i--;
count--;
publicstaticvoidShow(Spinnerspinner,Itemitem,Vector3dir,floatspin,floatstart)
PoofTransformpoof=pool.Pop();
if(poof!=null)
poof.Setup(spinner,item,dir,spin,start);
active.Add(poof);
publicstaticvoidGameStart()
while(active.Count>0)
pool.Push(active.GetRemoveLast().Disable());
publicstaticvoidClearAfter(Spinnerspinner,floattime)
intcount=active.Count;
for(inti=0;i<count;i++)
if(active[i].ClearedAfter(spinner,time))
pool.Push(active.GetRemoveAt(i).Disable());
count--;
i--;
publicclassStructTest:MonoBehaviour{
privatestructMyStruct
publicinta;
publicfloatb;
publicMyStruct(inta,floatb)
this.a=a;
this.b=b;
privateMyStructs=newMyStruct(0,0);
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.S))
s.a++;
s.b+=2.354f;
Debug.Log(s.a);
Debug.Log(s.b);
publicclassBotControll:MonoBehaviour{
/*staticGameObjectspinnerCharacter;
staticSP_MainspMain;
staticSP_AnimationspAnim;
staticSwingDataswingData;
staticfloatfireTime;
staticintfoundStick=0;
staticfloatcheckTime=0;
staticintgoalStick;
staticboolreachedGoal;
staticfloatlastFire;
staticfloatskill=1;
publicvoidReset()
skill=Random.Range(.3f,1f);
if(Debugger.showDebugLog)
Debug.Log("BotSkill:"+skill);
goalStick=(int)Random.Range(2,Mathf.Lerp(10,100,skill));
if(Debugger.showDebugLog)
Debug.Log("BotGoal:"+goalStick);
reachedGoal=false;
publicvoidCreateBot()
spinnerCharacter=spinner;
spMain=spinner.GetComponent<SP_Main>();
spAnim=spinner.GetComponent<SP_Animation>();
publicstaticvoidConnect(SwingDataswingData)
BotControll.swingData=swingData;
checkTime=0;
foundStick=0;
if(!reachedGoal&&BotControll.swingData.stick==goalStick)
reachedGoal=true;
publicvoidUpdateBot()
if(foundStick==0&&swingData!=null)
if(!reachedGoal)
intcheck=0;
while(check<3&&foundStick==0)
check++;
checkTime+=.01f;
floatangle=swingData.Get_CleanAngle(swingData.startTime+checkTime);
Vector3spinnerPos=SwingData.Get_CleanPosition(swingData.stick,swingData.charHeight,swingData.Get_CleanAngle(checkTime),checkTime);
foundStick=SP_Predict.JumpPrediction(CharacterControll.GetHeight(0),1,spinnerPos,swingData.GetForceV(swingData.startTime+checkTime),swingData.stick,swingData.startTime+checkTime);
if(foundStick.BiggerStickNrThan(swingData.stick))
fireTime=swingData.startTime+checkTime+Random.Range(Mathf.Lerp(-.04f,0,skill),Mathf.Lerp(.04f,0,skill));
swingData=null;
check=3;
else
foundStick=0;
else
Debug.Log("ReachedGoal");
foundStick=10000000;
fireTime=swingData.startTime+Random.Range(0,2f);
swingData=null;
lastFire+=GameTime.delta;
if(foundStick!=0&&GameTime.Now>=fireTime||lastFire>=6)
spMain.Button(GameTime.Now);
foundStick=0;
lastFire=0;
*/
publicclassFloorColor:MonoBehaviour
publicColorfloorColor;
publicfloatsunColorLerp;
privatestaticreadonlyintFloorC=Shader.PropertyToID("FloorColor");
privatevoidLateUpdate()
Shader.SetGlobalColor(FloorC,Color.Lerp(floorColor,floorColor*LightingSet.SunColor,sunColorLerp));
namespaceGameModeStuff
publicenumMode:byte
Select,
SpinUp,
Creator
publicinterfaceIGameMode
voidLoad();
voidRestart();
voidStateUpdate();
IEnumeratorGameOver();
IEnumeratorHouseKeeping();
publicclassGameManager:Singleton<GameManager>
publicenumGameState
None,
ServerConnect,
GameLoad,
GameRun,
GameOver,
HouseKeeping,
Paused
privatestaticGameStateState=GameState.None;
publicstaticModeSavedMode
get{return(Mode)(Application.isEditor?PlayerPrefs.GetInt("GameMode"):1);}
set{PlayerPrefs.SetInt("GameMode",(int)value);}
publicstaticModeMode;
publicstaticboolRunning;
privatestaticIGameModeGameMode;
privatestaticreadonlyIGameMode[]modes={null,newMode_SpinUp(),newCreator(),null};
publicdelegatevoidGameStart();publicstaticeventGameStartonGameStart;
privatevoidAwake()
ChangeState(GameState.ServerConnect);
publicstaticvoidChangeState(GameStatestate)
State=state;
switch(state)
caseGameState.ServerConnect:
Inst.StartCoroutine(Database.InitServerConnection());
break;
caseGameState.GameLoad:
Physics.autoSimulation=false;
LoadGameMode(SavedMode);
break;
caseGameState.GameRun:
Level.GameStart();
CamManager.GameStart();
floatrestartOffset=GTime.GameStart();
ActorAnimator.GameStart(restartOffset);
Boundary.GameStart();
DrumRoll.GameStart();
WallMaster.GameStart();
Spinner.Squash.Reset();
Poof.GameStart();
Collector.GameStart();
GarbageMachine.Collect();
if(onGameStart!=null)
onGameStart();
GameMode.Restart();
Running=true;
break;
caseGameState.GameOver:
Running=false;
Inst.StartCoroutine(GameEnd());
break;
caseGameState.HouseKeeping:
Inst.StartCoroutine(HouseKeeping());
break;
publicstaticvoidLoadGameMode(ModenewMode)
Mode=newMode;
GameMode=modes[(int)Mode];
if(GameMode==null)
UI_Manager.Show_MainMenu_UI();
return;
Inst.StartCoroutine(GameLoad());
privatestaticIEnumeratorGameLoad()
yieldreturnServerTime.GetTime();
CamManager.GameLoad();
yieldreturnLevel.GameLoad();
Environmentor.GameLoad();
Spinner.GameLoad();
Sound.GameLoad();
GameMode.Load();
ChangeState(GameState.HouseKeeping);
privatevoidUpdate()
UI_Manager.CheckUI();
Controll.Update();
if(!Running)
return;
GTime.TimeStep();
GameMode.StateUpdate();
ByteReplays.GameUpdate();
Spinner.AllStateUpdate();
Spinner.AllPoseUpdate();
Spinner.Squash.GameUpdate();
Collector.GameUpdate();
Boundary.GameUpdate();
CamManager.LateGameUpdate();
LightManager.LightUpdate();
Sound.SoundUpdate();
Level.Refresh();
ActorAnimator.LatePoseSet();
WallMaster.GameUpdate();
privatestaticIEnumeratorGameEnd()
yieldreturnGameMode.GameOver();
ChangeState(GameState.HouseKeeping);
privatestaticIEnumeratorHouseKeeping()
yieldreturnGameMode.HouseKeeping();
ChangeState(GameState.GameRun);
privatevoidOnApplicationFocus(boolhasFocus)
if(!Running||!Application.isMobilePlatform)
return;
if(!GTime.Paused)
GTime.Pause();
else
TimeSliderUI.playingSlowMo=false;
publicstaticclassGarbageMachine
[DllImport("__Internal")]
privatestaticexternvoidGC_disable();
[DllImport("__Internal")]
privatestaticexternvoidGC_enable();
publicstaticvoidCollect()
GC_enable();
GC.Collect();
GC_disable();
publicstaticclassGTime
privateconstfloatBPM=132f;
privateconstfloatBPS=BPM/60f;
privateconstfloatBeat=1f/BPS;
publicconstfloatLoopTime=16*Beat;
publicconstfloatLoopMulti=1/LoopTime;
publicconstfloatRewindTime=LoopTime;
publicstaticfloatNow;
publicstaticfloatLastFrame;
publicstaticfloatSpeed=1;
privatestaticfloatpausedTime;
privateconstfloatslowMoFactor=1f/4;
privateconstfloatmegaSlowMoFactor=1f/16;
privatestaticboolresetLoop;
publicstaticfloatStartTime;
publicstaticboolPaused;
publicstaticfloatLoopCount{get{returnNow/LoopTime;}}
publicstaticfloatLoopFraction{get{returnLoopCount%1;}}
publicstaticfloatLastLoopPoint{get{returnMathf.Floor(Now/LoopTime)*LoopTime;}}
publicstaticfloatNextLoopPoint{get{returnMathf.Ceil(Now/LoopTime)*LoopTime;}}
publicdelegatevoidOnPaused(boolpaused);
publicstaticeventOnPausedonPaused;
privatestaticvoidKeys()
if(!Paused&&Input.GetKeyDown(KeyCode.Tab))
Speed=f.Same(Speed,1)?0:1;
if(!Paused&&Input.GetKeyDown(KeyCode.LeftShift))
Speed=f.Same(Speed,1)?slowMoFactor:f.Same(Speed,slowMoFactor)?megaSlowMoFactor:1;
if(GameManager.Mode==Mode.Creator)
return;
if(Input.GetKeyDown(KeyCode.Pause))
if(!Paused)
Pause();
else
UnPause();
if(!Application.isMobilePlatform&&!Paused&&KeyMap.Down(Key.Pause))
Pause();
else
if(!Application.isMobilePlatform&&Paused&&KeyMap.Down(Key.Unpause))
UnPause();
publicstaticvoidTimeStep()
if(!Application.isMobilePlatform)
Keys();
if(GameManager.Running)
LastFrame=Now;
Now+=Time.deltaTime*Speed;
if(Now<0)
Now=0;
if(resetLoop)
Now=Mathf.Repeat(Now,LoopTime);
publicstaticfloatGameStart()
floatbefore=Now;
StartTime=Now=ServerTime.GetGameStartTime();
Speed=1;
returnNow-before;
publicstaticvoidPause()
Paused=true;
Speed=0;
pausedTime=Now;
if(onPaused!=null)
onPaused(true);
SetVolume.UpdateVolume();
publicstaticvoidUnPause()
Paused=false;
Speed=1;
Now=pausedTime;
if(onPaused!=null)
onPaused(false);
SetVolume.UpdateVolume();
publicstaticvoidResetLoop(boolresetLoop)
GTime.resetLoop=resetLoop;
publicstaticvoidSlowMoPlease(floathowLong)
if(waitTime>howLong)
return;
if(waitTime>0)
waitTime=howLong;
return;
waitTime=howLong;
Run.Inst.StartCoroutine(SlowMo());
privatestaticfloatwaitTime;
privatestaticIEnumeratorSlowMo()
Speed=.15f;
floatcount=0;
while(count<waitTime&&!Paused)
count+=Time.deltaTime;
yieldreturnnull;
if(!Paused)
Speed=1;
publicenumKey
P1Action,
P2Action,
Rewind,
Pause,
Unpause,
Dev_SquashTest,
Dev_LightToggle,
Dev_CostumeColor,
Dev_SideSwitch,
Dev_CamModeToggle,
Dev_ColorShift
publicstaticclassKeyMap
staticKeyMap()
keyDict=newDictionary<Key,KeyCode[]>(newKey_Comparer())
KeyCode.Mouse0,
KeyCode.KeypadEnter,
KeyCode.Joystick1Button0,
KeyCode.Joystick1Button1}},
KeyCode.Mouse1,
KeyCode.Joystick1Button2,
KeyCode.Delete,
KeyCode.Minus}},
KeyCode.Joystick1Button7,
KeyCode.Pause}},
KeyCode.Joystick1Button7,
KeyCode.Pause}},
KeyCode.Joystick1Button6}},
KeyCode.Joystick1Button3}},
KeyCode.Joystick1Button4}},
KeyCode.Keypad1,
KeyCode.Joystick1Button5}},
KeyCode.Joystick1Button8}}
List<KeyCode>getKeys=newList<KeyCode>();
foreach(KeyCodevKeyinSystem.Enum.GetValues(typeof(KeyCode)))
getKeys.Add(vKey);
keyArray=getKeys.ToArray();
privatestaticKeyCode[]keyArray;
privatestructKey_Comparer:IEqualityComparer<Key>
publicboolEquals(Keyx,Keyy){returnx==y;}
publicintGetHashCode(Keyobj){return(int)obj;}
privatestaticreadonlyDictionary<Key,KeyCode[]>keyDict;
publicstaticboolAnyInput
get{returnDown(Key.P1Action)||
Down(Key.P2Action);}
publicstaticboolCheckInput()
return!UI_Manager.HitUI&&
!GTime.Paused&&
!ShakeRewind.Rewinding&&
Down(Key.P1Action);
publicstaticboolDown(Keykey)
KeyCode[]keys=keyDict[key];
for(inte=0;e<keys.Length;e++)
if(Input.GetKeyDown(keys[e]))
returntrue;
returnfalse;
publicstaticboolHold(Keykey)
KeyCode[]keys=keyDict[key];
for(inte=0;e<keys.Length;e++)
if(Input.GetKey(keys[e]))
returntrue;
returnfalse;
publicstaticboolUp(Keykey)
KeyCode[]keys=keyDict[key];
for(inte=0;e<keys.Length;e++)
if(Input.GetKeyUp(keys[e]))
returntrue;
returnfalse;
privateconstKeyCodeNull=KeyCode.Joystick8Button19;
publicstaticboolDown(KeyCodekeyA,KeyCodekeyB=Null,KeyCodekeyC=Null,KeyCodekeyD=Null)
if(Input.GetKeyDown(keyA))
returntrue;
if(keyB!=Null&&Input.GetKeyDown(keyB))
returntrue;
if(keyC!=Null&&Input.GetKeyDown(keyC))
returntrue;
returnkeyD!=Null&&Input.GetKeyDown(keyD);
publicstaticboolHold(KeyCodekeyA,KeyCodekeyB=Null,KeyCodekeyC=Null,KeyCodekeyD=Null)
if(Input.GetKey(keyA))
returntrue;
if(keyB!=Null&&Input.GetKey(keyB))
returntrue;
if(keyC!=Null&&Input.GetKey(keyC))
returntrue;
returnkeyD!=Null&&Input.GetKey(keyD);
publicstaticboolUp(KeyCodekeyA,KeyCodekeyB=Null,KeyCodekeyC=Null,KeyCodekeyD=Null)
if(Input.GetKeyUp(keyA))
returntrue;
if(keyB!=Null&&Input.GetKeyUp(keyB))
returntrue;
if(keyC!=Null&&Input.GetKeyUp(keyC))
returntrue;
returnkeyD!=Null&&Input.GetKeyUp(keyD);
publicstaticKeyCodeGetDownKey
get
intlength=keyArray.Length;
for(inti=0;i<length;i++)
KeyCodecode=keyArray[i];
if(Input.GetKeyDown(code))
returncode;
returnKeyCode.None;
publicstaticclassLightingSet
publicstaticVector3SunDir,ShadowDir;
publicstaticColorSunColor;
privatestaticColorFogColor,SkyColor;
privatestaticfloatSunIntensity,FogIntensity,ShadowBrightness,CastShadowVis;
publicstaticQuaternionSunRot,BounceRot;
publicstaticVector2SunXFactor;
privatestaticreadonlyintSide=Shader.PropertyToID("Side");
privatestaticreadonlyintSideMulti=Shader.PropertyToID("SideMulti");
privatestaticreadonlyintWallCastSideMulti=Shader.PropertyToID("WallCastSideMulti");
privatestaticreadonlyintMegaSideMulti=Shader.PropertyToID("MegaSideMulti");
privatestaticreadonlyintWall=Shader.PropertyToID("Wall");
privatestaticreadonlyintGamePlane=Shader.PropertyToID("GamePlane");
privatestaticreadonlyintContactAdd=Shader.PropertyToID("ContactAdd");
privatestaticreadonlyintDir=Shader.PropertyToID("ShadowDir");
privatestaticreadonlyintSunAngle=Shader.PropertyToID("SunAngle");
privatestaticreadonlyintSunFactors=Shader.PropertyToID("SunFactors");
privatestaticreadonlyintColor=Shader.PropertyToID("SunColor");
privatestaticreadonlyintAntiSunColor=Shader.PropertyToID("AntiSunColor");
privatestaticreadonlyintSkyColor1=Shader.PropertyToID("SkyColor");
privatestaticreadonlyintFogColor1=Shader.PropertyToID("FogColor");
privatestaticreadonlyintAmbient=Shader.PropertyToID("Ambient");
privatestaticreadonlyintShadowColor=Shader.PropertyToID("ShadowColor");
privatestaticreadonlyintShadowVis=Shader.PropertyToID("CastShadowVis");
publicstaticvoidSceneChangeSet()
Resources.Load<SceneLightLerp>("Light/DefaultLightLerp").SetLerpedLighting(.5f);
publicstaticvoidSetSceneLighting(_SceneLightingsceneLighting)
SetSunRot(Quaternion.Euler(sceneLighting.sunAngle.x,sceneLighting.sunAngle.y,0));
SunColor=sceneLighting.sunColor;
SunIntensity=sceneLighting.sunIntensity;
ColorsunColor=SunColor*SunIntensity;
ColorantiSunColor=newColor(Mathf.Max(0,1-sunColor.r),Mathf.Max(0,1-sunColor.g),Mathf.Max(0,1-sunColor.b));
Shader.SetGlobalColor(Color,sunColor);
Shader.SetGlobalColor(AntiSunColor,antiSunColor);
SkyColor=sceneLighting.skyColor;
Shader.SetGlobalColor(SkyColor1,SkyColor);
FogColor=sceneLighting.fogColor;
Shader.SetGlobalColor(FogColor1,sceneLighting.fogColor);
ShadowBrightness=sceneLighting.shadowBrightness;
CastShadowVis=sceneLighting.shadowVisibility;
RenderSettings.ambientLight=sceneLighting.ambientColor;
Shader.SetGlobalColor(Ambient,sceneLighting.ambientColor);
Shader.SetGlobalFloat(ShadowVis,CastShadowVis*(GameCam.CurrentSide.front?.6f:.85f));
constfloatshadowMulti=.2f;
Vector3shadowB=newVector3(Mathf.Clamp01(ShadowBrightness*2*SkyColor.r)*shadowMulti,
Mathf.Clamp01(ShadowBrightness*2*SkyColor.g)*shadowMulti,
Mathf.Clamp01(ShadowBrightness*2*SkyColor.b)*shadowMulti);
Shader.SetGlobalVector(ShadowColor,shadowB);
UpdateShader(LightManager.Front,!Application.isPlaying);
publicstaticvoidSetShadow(boolfront)
Vector3mirroredSun=Vector3.Reflect(SunDir,V3.forward);
ShadowDir=front?SunDir:newVector3(mirroredSun.x*.25f,mirroredSun.y,mirroredSun.z);
Shader.SetGlobalVector(Dir,-ShadowDir);
BounceRot=Quaternion.FromToRotation(Vector3.up,newVector3(-ShadowDir.x,-ShadowDir.y).normalized);
publicstaticvoidUpdateShader(boolfront,boolnone=false)
floatside=none?-1:front?-1:1;
Shader.SetGlobalFloat(Side,side);
Shader.SetGlobalFloat(SideMulti,side*.5f+.5f);
Shader.SetGlobalFloat(WallCastSideMulti,.65f+.35f*Mathf.Clamp01(-Side));
Shader.SetGlobalFloat(MegaSideMulti,1+.1f*Mathf.Clamp01(Side));
Shader.SetGlobalFloat(Wall,none?.001f:Level.WallDepth);
Shader.SetGlobalFloat(GamePlane,none?1:Level.WallDepth+Level.PlaneOffset);
Shader.SetGlobalFloat(ContactAdd,.125f-.025f*Mathf.Clamp01(side));
publicstaticvoidGetSceneLight(_SceneLightingsceneLighting)
sceneLighting.sunAngle=SunRot.eulerAngles;
sceneLighting.sunColor=SunColor;
sceneLighting.sunIntensity=SunIntensity;
sceneLighting.skyColor=SkyColor;
sceneLighting.ambientColor=RenderSettings.ambientLight;
sceneLighting.fogColor=FogColor;
sceneLighting.shadowBrightness=ShadowBrightness;
sceneLighting.shadowVisibility=CastShadowVis;
publicstaticvoidSetSunRot(Quaternionrot)
SunRot=rot;
SunDir=SunRot*V3.forward;
Shader.SetGlobalVector(SunAngle,-SunDir);
SunXFactor=-(SunDir*(1f/Mathf.Abs(SunDir.z)));
Shader.SetGlobalVector(SunFactors,SunXFactor);
SetShadow(LightManager.Front);
publicclassLightManager:Singleton<LightManager>
publicMapCamshadowCam;
publicMapCamlightCam;
publicstaticboolFront,ForceUpdate;
privatestaticboolUpdateRequested;
[Switch("Visuals/Shadows")]privatestaticboolShadows=true;
[Switch("Visuals/Lights")]privatestaticboolLights=true;
[Space(10)]
publicSpriteRenderershadowSpriteRef;
privateTexture2DfakeShadowTex;
privatestaticSceneLightLerplightLerp;
privatestaticMaterialPropertyBlock_propBlock;
publicstaticMaterialPropertyBlockPropBlock
get
if(_propBlock==null)
_propBlock=newMaterialPropertyBlock();
Inst.shadowSpriteRef.GetPropertyBlock(_propBlock);
return_propBlock;
privatevoidAwake()
lightLerp=Resources.Load<SceneLightLerp>("Light/DefaultLightLerp");
publicstaticvoidLightUpdate()
ForceUpdate=false;
if(Front!=GameCam.CurrentSide.front)
Front=GameCam.CurrentSide.front;
LightingSet.SetShadow(Front);
LightingSet.UpdateShader(Front);
ForceUpdate=true;
if(Shadows!=Inst.shadowCam.active)
Inst.shadowCam.SetActive(Shadows);
if(Lights!=Inst.lightCam.active)
Inst.lightCam.SetActive(Lights);
publicstaticvoidSetSunAngleLerp(Quaternionrot,floatlerp)
ForceUpdate=true;
lightLerp.SetLerpedLighting(lerp,rot);
publicclassMainMenu:MonoBehaviour
publicInputFieldinputField;
privatevoidOnEnable()
inputField.text=UserSave.Name;
publicvoidSelectSpinUp()
GameManager.LoadGameMode(Mode.SpinUp);
publicclassSunDir:MonoBehaviour
[Range(0,1)]
publicfloatlerpA,lerpB;
[Space(10)]
publicfloatsunRange;
publicfloatheightMulti,heightMultiB;
[Space(10)]publicboolanimLight,useSystemTime;
publicfloatanimSpeed;
[Range(.05f,.95f)]publicfloatt;
[Space(10)]
publicboolsetSunDir,draw;
publicfloatanimTime;
[Space(10)][Range(0,1)]publicfloatsunPowLerp;
privatestaticreadonlyintSunPowLerp=Shader.PropertyToID("SunPowLerp");
privatestaticreadonlyintBottomLightBounceMulti=Shader.PropertyToID("BottomLightBounceMulti");
privatestaticreadonlyintHeightLightAdd=Shader.PropertyToID("HeightLightAdd");
publicstaticfloatDayTimeLerp;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
if(Input.GetKeyDown(KeyCode.Alpha5))
animLight=!animLight;
if(animLight)
animTime+=Time.deltaTime*animSpeed*.005f;
else
if(useSystemTime)
constfloatminHour=5.04f,
maxHour=20.4f,
minSecond=minHour*60*60,
maxSecond=maxHour*60*60;
DateTimenow=DateTime.Now;
floatcurrentSecond=now.Hour*60*60+now.Minute*60+now.Second;
animTime=Mathf.InverseLerp(minSecond,maxSecond,currentSecond);
else
animTime=t;
DayTimeLerp=Mathf.Repeat(animTime,1);
floatrange=sunRange+GameCam.CurrentPos.y*heightMulti;
Vector3sunDir=GetDir(Mathf.Lerp(-range*.5f,range*.5f,DayTimeLerp));
if(setSunDir)
floatcolorLerp=Mathf.Lerp(DayTimeLerp,.5f,GameCam.CurrentPos.y*heightMultiB);
LightManager.SetSunAngleLerp(Quaternion.FromToRotation(Vector3.forward,-sunDir),colorLerp);
sunPowLerp=Mathf.PingPong(DayTimeLerp*2,1);
Shader.SetGlobalFloat(SunPowLerp,sunPowLerp);
Shader.SetGlobalFloat(BottomLightBounceMulti,.75f+(1-sunPowLerp)*1.25f);
Shader.SetGlobalFloat(HeightLightAdd,Mathf.Clamp01((1-sunPowLerp)*.2f));
if(draw)
Draw(sunDir);
privatevoidDraw(Vector3sunDir)
if(!setSunDir)
DRAW.GapVector(GameCam.CurrentPos.V3(Z.W),LightingSet.SunRot*Vector3.back*20,40).SetColor(COLOR.green.lime);
DRAW.GapVector(GameCam.CurrentPos.V3(Z.W),sunDir*20,40).SetColor(COLOR.red.firebrick);
constintsteps=100;
constfloatangle=360f/steps;
for(inti=0;i<steps;i++)
DRAW.Vector(GameCam.CurrentPos.V3(Z.W),GetDir(i*angle)*20).SetColor(COLOR.yellow.fresh.A(.15f));
privateVector3GetDir(floatangle)
Quaternionrot=Rot.Z(angle);
Vector3dir=rot*Vector3.up;
floattiltLerp=Mathf.Abs(Vector3.Dot(Vector3.up,dir));
returnVector3.Slerp(dir,Vector3.back,Mathf.SmoothStep(lerpA,lerpB,tiltLerp));
publicpartialclassTape
publicTape(boolcreateSerializer)
if(createSerializer)
tapeSerializer=newTapeSerializer();
privateconstintarrayLength=50;
privatereadonlyClip[]clips=newClip[arrayLength];
privateintmin,max;
privateintfirst{get{returnmin%arrayLength;}}
privateintlast{get{return(max-1)%arrayLength;}}
privateintlength{get{returnmax-min;}}
privatereadonlyTapeSerializertapeSerializer;
publicvoidClear()
while(length>0)
clips[last].Reset();
max--;
if(tapeSerializer!=null)
tapeSerializer.Reset();
publicClipGetClip(floattime)
intindex=-1;
for(inti=min;i<max;i++)
if(clips[i%arrayLength].startTime<=time)
index=i%arrayLength;
else
break;
if(index==-1||
length>0&&index==last&&clips[index].duration>0&&time>=clips[index].startTime+clips[index].duration)
returnNone.Get;
returnclips[index];
publicvoidSetClip(ClipnewClip)
AddToList(newClip);
if(!newClip.Type.IsAnyJump())
return;
Jumpjump=(Jump)newClip;
switch(jump.next)
caseClipType.Swing:
AddToList(Clip.Get_Clip_Swing(jump));
break;
caseClipType.Bump:
AddToList(Clip.Get_Bump(jump));
break;
privatevoidAddToList(ClipnewClip)
if(length==arrayLength)
Debug.Log("DamnTapeclipstooshort");
return;
Clipbefore=length>0?clips[last]:null;
newClip.SetClipBefore(before);
if(before!=null)
before.SetClipAfter(newClip);
max++;
clips[last]=newClip;
publicvoidClearAfter(floattime)
while(length>0&&clips[last].startTime>=time)
clips[last].Reset();
max--;
if(length>0)
clips[last].SetClipAfter(null);
publicvoidClearBefore(floattime)
while(length>3)
ClipthirdClip=clips[(min+2)%arrayLength];
if(thirdClip.startTime+thirdClip.duration<time)
ClipfirstClip=clips[first];
if(tapeSerializer!=null)
tapeSerializer.SerializeClip(firstClip);
firstClip.Reset();
min++;
if(length>0)
clips[first].before=null;
continue;
break;
publicbyte[]GetReplayBytes()
while(length>0)
Clipclip=clips[first];
tapeSerializer.SerializeClip(clip);
clip.Reset();
min++;
returntapeSerializer.serializableReplay?tapeSerializer.GetBytes():TapeSerializer.None;
publicpartialclassTape
privateclassTapeSerializer
privateintclipCount;
privatereadonlyMemoryStreamclipStream;
privatereadonlyBinaryWriterwriter;
publicboolserializableReplay;
publicstaticreadonlybyte[]None=newbyte[0];
publicTapeSerializer()
clipStream=newMemoryStream(10240);
writer=newBinaryWriter(clipStream);
publicvoidReset()
serializableReplay=true;
clipCount=0;
clipStream.SetLength(0);
publicvoidSerializeClip(Clipclip)
if(!clip.Type.IsSerializable()||!serializableReplay)
return;
writer.Write((sbyte)((int)clip.Type*clip.startSide.Sign));
serializableReplay=clip.Serialize(writer);
clipCount++;
publicbyte[]GetBytes()
byte[]infoArray=ByteReplay.Serialize(clipCount);
byte[]clipBytes=clipStream.ToArray();
byte[]ret=newbyte[infoArray.Length+clipBytes.Length];
Buffer.BlockCopy(infoArray,0,ret,0,infoArray.Length);
Buffer.BlockCopy(clipBytes,0,ret,infoArray.Length,clipBytes.Length);
returnret;
publicstaticclassUserSave
publicstaticintID
get{returnPlayerPrefs.GetInt("UserSave_Account_ID");}
set{PlayerPrefs.SetInt("UserSave_Account_ID",value);}
publicstaticstringName
get{returnPlayerPrefs.GetString("UserSave_Name");}
set{PlayerPrefs.SetString("UserSave_Name",value);}
publicstaticintHighscore
get{returnPlayerPrefs.GetInt("UserSave_Highscore");}
set{PlayerPrefs.SetInt("UserSave_Highscore",value);}
publicstaticfloatHeight
get{returnPlayerPrefs.GetFloat("UserSave_Height");}
set{PlayerPrefs.SetFloat("UserSave_Height",value);}
publicstaticintCoins
get{returnPlayerPrefs.GetInt("UserSave_Coins");}
set{PlayerPrefs.SetInt("UserSave_Coins",value);}
publicstaticintLevel
get{returnPlayerPrefs.GetInt("UserSave_Level");}
set{PlayerPrefs.SetInt("UserSave_Level",value);}
publicstaticfloatPlayTime
get{returnPlayerPrefs.GetFloat("UserSave_PlayTime");}
set{PlayerPrefs.SetFloat("UserSave_PlayTime",value);}
publicstaticbyteColorValue
get{return(byte)PlayerPrefs.GetInt("UserSave_ColorValue");}
set{PlayerPrefs.SetInt("UserSave_ColorValue",value);}
publicclassMode_SpinUp:IGameMode
publicvoidLoad()
Leaderboard.GetBoard();
UI_Manager.Show_SpinUp_UI();
publicvoidRestart()
Spinner.Get(0).Enable(BotPlayers.RandomName,newCostume());
Score.ResetScore();
Height.ResetHeight();
Mood.Reset();
publicvoidStateUpdate()
Mood.Update();
publicIEnumeratorGameOver()
Run.Inst.StartCoroutine(ReplaySaveLoad.SaveReplay());
Run.Inst.StartCoroutine(Score.CheckForHighScore());
while(Spinner.active.Count>0)
Spinner.active[0].Disable();
yieldreturnnull;
publicIEnumeratorHouseKeeping()
yieldbreak;
publicstaticclassElementEdit
publicstaticElementelement;
publicstaticItemitem;
publicstaticTracktrack;
publicstaticelementTypeelementType;
publicstaticSideside;
privatestaticVector2placementOffset,mouseStart,oldPos,hitStart;
privatestaticboolmovingElement;
publicstaticvoidSelect(Elementelement)
ElementEdit.element=element;
if(ElementEdit.element!=null)
elementType=element.elementType;
side=element.side;
boolisItem=Mask.AnyThing.Fits(element.elementType);
item=isItem?(Item)element:null;
track=!isItem?(Track)element:null;
UI_Creator.SetCurrentElement(element.elementType.ToString());
else
item=null;
track=null;
elementType=0;
publicstaticvoidUpdate()
boolactive=element!=null;
if(LinkEdit.LinkMode)
if(active)
Select(null);
return;
if(!UI_Manager.HitUI)
if(Input.GetMouseButtonDown(1)&&active)
Select(null);
return;
if(Input.GetKey(KeyCode.T))
return;
if(Input.GetMouseButtonDown(0))
hitStart=Level.HitPoint;
Vector2closestPoint;
ElementnewElement=Search.ClosestElement(hitStart,GTime.Now,GameCam.CurrentSide,Creator.currentFilter,outclosestPoint);
if(newElement==null)
Select(null);
else
if(newElement==item&&item.parent!=null)
Select(item.parent);
UI_Creator.SetCategory(3);
else
Select(newElement);
mouseStart=Input.mousePosition;
return;
if(Input.GetMouseButton(0))
Vector2hitNow=Level.HitPoint;
Vector2min=newVector2(Mathf.Min(hitStart.x,hitNow.x),Mathf.Min(hitStart.y,hitNow.y));
Vector2max=newVector2(Mathf.Max(hitStart.x,hitNow.x),Mathf.Max(hitStart.y,hitNow.y));
Vector2p=(min+max)*.5f,s=max-min;
DRAW.Rectangle(p,s).SetColor(Color.yellow).SetDepth(Z.W05);
DRAW.Rectangle(p,s).SetColor(Color.cyan).SetDepth(Z.W05).Fill(.1f,true);
if(active)
if(!movingElement&&Vector2.Distance(Input.mousePosition,mouseStart)>=7)
movingElement=true;
oldPos=element.rootPos;
placementOffset=oldPos-Level.HitPoint;
if(!movingElement)
return;
element.SetRootPos(Level.HitPoint+placementOffset).Refresh();
GTime.Now=GTime.LastFrame;
if(Mask.Warp_SideSwitch.Fits(elementType))
Elementbuddy=element.GetLink(linkType.Warp).GetOther(element);
if(buddy!=null)
buddy.SetRootPos(element.rootPos).Refresh();
if(Input.GetMouseButtonUp(0)&&movingElement)
movingElement=false;
if(element!=null&&LevelCheck.Overlapping(element))
Run.Inst.StartCoroutine(MoveBack());
if(Input.GetKeyDown(KeyCode.Backspace)&&active)
Select(null);
privatestaticIEnumeratorMoveBack()
Vector3start=element.rootPos;
floatt=0;
while(t<1)
t+=Time.deltaTime*4;
element.SetRootPos(Vector2.Lerp(start,oldPos,Mathf.SmoothStep(0,1,t))).Refresh();
yieldreturnnull;
publicstaticclassLevelCheck
privatestaticreadonlyint[]Highlight=newint[Item.TotalCount+Track.TotalCount],
Overlap=newint[Item.TotalCount+Track.TotalCount];
privatestaticintFrame;
publicstaticboolHighlighting{get{returnClosestElement!=null;}}
publicstaticElementClosestElement;
publicstaticVector2ElementPoint;
publicstaticLinkClosestLink;
publicstaticVector2LinkPoint;
publicstaticElementMaskFilter{get{returnCreator.currentFilter;}}
publicstaticboolItemCheck{get{returnFilter==Mask.IsItem;}}
privatestaticreadonlyVector2[]positions=newVector2[short.MaxValue];
publicstaticvoidCreatorUpdate()
Frame=Time.frameCount;
if(UI_Manager.HitUI||Input.GetKey(KeyCode.LeftAlt))
ClosestElement=null;
ClosestLink=Link.None;
else
ClosestElement=Search.ClosestElement(Level.HitPoint,GTime.Now,GameCam.CurrentSide,Filter,outElementPoint);
if(ClosestElement!=null)
Highlight[ClosestElement.ID]=Frame;
if(LinkEdit.LinkMode)
Vector2hitPoint=Level.HitPoint;
ClosestLink=Link.None;
floatdistance=Mth.IntPow(Level.CellSize*.5f,2);
if(LinkEdit.Creating)
return;
List<Link>links=GameCam.CurrentSide.front?Link.frontLinks:Link.backLinks;
intcount=links.Count;
for(inti=0;i<count;i++)
Linklink=links[i];
Vector2point=newLine(link.a.GetPos(GTime.Now),link.b.GetPos(GTime.Now)).ClosestPoint(hitPoint);
floatdist=(point-hitPoint).sqrMagnitude;
if(dist<distance)
distance=dist;
ClosestLink=link;
LinkPoint=point;
for(inti=0;i<Level.itemCount;i++)
positions[i]=Level.items[i].GetPos(GTime.Now);
boolitemCheck=ItemCheck;
for(inti=0;i<Level.itemCount;i++)
if(Filter.Fits(Level.items[i].elementType))
floataR=Level.items[i].radius;
Sideside=Level.items[i].side;
for(inte=0;e<Level.itemCount;e++)
if(i==e||side!=Level.items[e].side)
continue;
boolitemVSItem=itemCheck&&Mask.IsItem.Fits(Level.items[e].elementType);
floatbR=Level.items[e].radius;
floatrP=aR+bR+(itemVSItem?Level.PlacementRadius*2:0);
if((positions[i]-positions[e]).sqrMagnitude<Mth.IntPow(rP,2))
Overlap[Level.items[i].ID]=Frame;
Overlap[Level.items[e].ID]=Frame;
publicstaticboolHighLighted(Elementelement)
returnHighlight[element.ID]==Frame;
publicstaticboolOverlapping(Elementelement)
returnelement!=null&&Overlap[element.ID]==Frame;
publicstaticColorGetColor(Elementelement)
if(ElementEdit.element==element)
returnCOLOR.purple.orchid;
Colorcolor=element.elementType.DebugColor();
if(Overlapping(element))
color=COLOR.red.hot;
if(HighLighted(element))
color=color.Multi(1.7f);
returncolor;
publicstaticclassLinkEdit
publicstaticboolLinkMode,Creating;
privatestaticElementa;
publicstaticlinkTypelinkType;
publicstaticvoidUpdate()
if(Input.GetKeyDown(KeyCode.L))
LinkMode=!LinkMode;
UI_Creator.LinkButton.SetActive(LinkMode);
if(!LinkMode)
if(Creating)
a=null;
Creating=false;
return;
if(Input.GetKeyDown(KeyCode.Delete))
if(Creating)
a=null;
Creating=false;
else
if(LevelCheck.ClosestLink!=Link.None)
Link.Delete(LevelCheck.ClosestLink);
if(Input.GetKeyDown(KeyCode.O))
UI_Creator.LinkButton.NextPick();
Elementb=Creating?LevelCheck.ClosestElement:null;
if(b!=null&&(a==b||a.side!=b.side||linkType==linkType.Action&&!Mask.Action.Fits(b.elementType)))
b=null;
if(!UI_Manager.HitUI&&Input.GetMouseButtonDown(0))
if(!Creating)
a=LevelCheck.ClosestElement;
Creating=a!=null;
else
if(b!=null)
Creating=false;
Link.Create(linkType,a,b);
if(Creating)
Colorc=linkType.Color();
floatradius=Mask.AnyThing.Fits(a.elementType)?((Item)a).radius:.2f;
Vector2pos=a.GetPos(GTime.Now);
floatpump=Mth.SmoothPP(.8f,1,Time.realtimeSinceStartup*2);
DRAW.ZappCircle(pos,radius+pump,.6f,12,Time.realtimeSinceStartup*45).SetColor(c).SetDepth(Z.W05).Fill();
Vector2posB=b!=null?LevelCheck.ElementPoint:Level.HitPoint;
Link.DrawArrow(pos,posB,linkType,false,basItem);
publicpartialclassCreator
privatebooldragAdjusting,rotate,adjustOffset;
privatefloatstartAngle,startOffset,mouseStartX;
privatestaticvoidEditTrackSize()
if(!KeyMap.Hold(KeyCode.Keypad4,KeyCode.Alpha3)&&!KeyMap.Hold(KeyCode.Keypad6,KeyCode.Alpha4))
return;
if(KeyMap.Hold(KeyCode.Keypad4,KeyCode.Alpha3))
ElementEdit.track.SetSize(ElementEdit.track.size-Time.deltaTime*.6f).Refresh();
if(KeyMap.Hold(KeyCode.Keypad6,KeyCode.Alpha4))
ElementEdit.track.SetSize(ElementEdit.track.size+Time.deltaTime*.6f).Refresh();
GTime.Now=GTime.LastFrame;
privatestaticvoidEditTrackSpeed()
if(KeyMap.Down(KeyCode.Keypad2,KeyCode.Alpha1))
ElementEdit.track.ShiftSpeed(false);
if(KeyMap.Down(KeyCode.Keypad8,KeyCode.Alpha2))
ElementEdit.track.ShiftSpeed(true);
privatevoidEditTrackOffset()
if(Input.GetMouseButtonDown(2)&&!dragAdjusting)
dragAdjusting=adjustOffset=true;
startOffset=ElementEdit.track.offset;
mouseStartX=Input.mousePosition.x;
if(Input.GetMouseButton(2)&&adjustOffset)
ElementEdit.track.SetOffset(Mathf.Repeat(startOffset+(Input.mousePosition.x-mouseStartX)/Screen.width*5,1));
GTime.Now=GTime.LastFrame;
if(Input.GetMouseButtonUp(2))
if(adjustOffset&&dragAdjusting)
if(f.Same(ElementEdit.track.offset,startOffset))
ElementEdit.track.SetOffset(0);
dragAdjusting=false;
adjustOffset=false;
privatestaticvoidEditTrackCompletion()
if(!KeyMap.Hold(KeyCode.Keypad7,KeyCode.Alpha5)&&!KeyMap.Hold(KeyCode.Keypad9,KeyCode.Alpha6))
return;
if(KeyMap.Hold(KeyCode.Keypad7,KeyCode.Alpha5))
ElementEdit.track.SetCompletion(ElementEdit.track.growth-Time.deltaTime*.6f).Refresh();
if(KeyMap.Hold(KeyCode.Keypad9,KeyCode.Alpha6))
ElementEdit.track.SetCompletion(ElementEdit.track.growth+Time.deltaTime*.6f).Refresh();
GTime.Now=GTime.LastFrame;
privatevoidEditTrackAngle()
if(Input.GetMouseButtonDown(0)&&!dragAdjusting)
dragAdjusting=true;
rotate=Mask.TrackCanTurn.Fits(ElementEdit.elementType);
startAngle=ElementEdit.track.angle;
mouseStartX=Input.mousePosition.x;
if(Input.GetMouseButton(0)&&rotate)
ElementEdit.track.SetAngle(startAngle+(Input.mousePosition.x-mouseStartX)/Screen.width*250).Refresh();
if(Input.GetMouseButtonUp(1))
if(rotate&&dragAdjusting)
dragAdjusting=false;
rotate=false;
privatestaticvoidEditSelectionSide()
if(!Input.GetKeyDown(KeyCode.Keypad3))
return;
ElementEdit.element.SetSide(!ElementEdit.side).Refresh();
Elementbuddy=ElementEdit.element.GetLink(linkType.Warp).GetOther(ElementEdit.element);
if(buddy!=null)
buddy.SetSide(!buddy.side).Refresh();
privatestaticvoidAddTrackGap()
if(Input.GetKeyDown(KeyCode.Z))
Itemgap=Item.GetFreeItem;
gap.SetType(elementType.TrackGap).SetSide(ElementEdit.track.side);
ElementEdit.track.ParentThis(gap).ScanAndRefesh();
publicpartialclassCreator
privatestaticelementTypecurrentElementType=0;
publicstaticElementMaskcurrentFilter=null;
privatestaticboolTappedUI;
publicstaticvoidSetElementType(elementTypeelementType)
currentElementType=elementType;
TappedUI=true;
privatestaticvoidSetStartStick()
if(Input.GetKeyDown(KeyCode.Home))
Level.StartStick=(Item)ElementEdit.element;
publicstaticvoidNewLevel()
Level.ClearLevel();
privatestaticvoidCenterCam()
if(Input.GetKeyDown(KeyCode.C)&&!Input.GetKey(KeyCode.LeftControl))
MoveCam.pos=ElementEdit.element.GetPos(GTime.Now);
privatestaticvoidSaving()
if(Input.GetKeyDown(KeyCode.KeypadEnter))
UI_Creator.ShowSavePrompt(LevelSaveLoad.CurrentLevel);
publicpartialclassCreator:IGameMode
publicvoidLoad()
UI_Manager.Show_Edit_UI();
publicvoidRestart(){}
publicvoidStateUpdate()
if(UI_Creator.SavingOrLoading||TappedUI)
TappedUI=false;
return;
LevelCheck.CreatorUpdate();
if(!Input.GetKey(KeyCode.LeftAlt))
LinkEdit.Update();
ElementEdit.Update();
if(currentElementType!=0)
NewElement();
if(LevelCheck.Highlighting&&Mask.AnyThing.Fits(LevelCheck.ClosestElement.elementType))
GetVariation();
if(ElementEdit.element!=null)
DeleteSelection();
Duplicate();
EditSelectionSide();
CenterCam();
if(Mask.AnyThing.Fits(ElementEdit.elementType))
SetStartStick();
else
if(Input.GetKey(KeyCode.T))
AddTrackGap();
EditTrackSize();
EditTrackSpeed();
EditTrackOffset();
EditTrackAngle();
EditTrackCompletion();
Saving();
LevelDebug.ShowHitPoint();
publicIEnumeratorGameOver(){yieldbreak;}
publicIEnumeratorHouseKeeping(){yieldbreak;}
publicpartialclassCreator
privatestaticvoidNewElement()
if(!Input.GetKeyDown(KeyCode.Space)||Input.GetKey(KeyCode.LeftControl))
return;
if(Mask.AnyThing.Fits(currentElementType))
CreateNewItem();
else
ElementEdit.Select(CreateNewTrack());
privatestaticvoidCreateNewItem()
booladdToTrack=ElementEdit.element!=null&&Mask.IsTrack.Fits(ElementEdit.elementType);
if(addToTrack&&!Mask.CanMove.Fits(currentElementType))
return;
ItemitemA=Item.GetFreeItem;
itemA.SetType(currentElementType).SetSide(GameCam.CurrentSide);
if(!addToTrack)
itemA.SetRootPos(Level.HitPoint).Refresh();
if(Mask.Warp.Fits(currentElementType))
boolwarpIsExit=Mask.Warp_Start.Fits(currentElementType);
boolsameSideWarp=!Mask.Warp_SideSwitch.Fits(currentElementType);
ItemitemB=Item.GetFreeItem;
itemB.SetType(currentElementType.GetOtherEnd()).SetSide(sameSideWarp?itemA.side:!itemA.side);
if(sameSideWarp)
itemB.SetRootPos(itemA.rootPos+newVector2(0,Level.PlacementRadius*2+itemA.radius*2));
else
itemB.SetRootPos(itemA.rootPos);
itemB.Refresh();
Link.Create(linkType.Warp,warpIsExit?itemA:itemB,warpIsExit?itemB:itemA);
else
ElementEdit.track.ParentThis(itemA).ScanAndRefesh();
if(itemA.ID==1&&Item.Count==1)
Level.StartStick=itemA;
privatestaticTrackCreateNewTrack()
Tracktrack=Track.GetNewTrack(currentElementType);
track.SetSide(newSide(GameCam.CurrentSide.front)).
SetRootPos(Level.HitPoint).Refresh();
returntrack;
privatestaticvoidDeleteSelection()
if(!Input.GetKeyDown(KeyCode.Delete))
return;
if(Mask.AnyThing.Fits(ElementEdit.elementType))
if(Item.Count==1||Level.StartStick.Equals(ElementEdit.element))
Level.StartStick=null;
((Item)ElementEdit.element).Delete();
else
ElementEdit.track.Reset();
ElementEdit.Select(null);
privatestaticvoidDuplicate()
if(Input.GetKeyDown(KeyCode.Space)&&Input.GetKey(KeyCode.LeftControl))
if(Mask.AnyThing.Fits(ElementEdit.elementType))
if(ElementEdit.item.parent==null)
ItemoldItem=(Item)ElementEdit.element;
ItemnewItem=Item.GetFreeItem;
newItem.SetType(oldItem.elementType).
SetRootPos(Level.HitPoint).
SetSide(oldItem.side).
Refresh();
ElementEdit.Select(newItem);
ElementoldBuddy=oldItem.GetLink(linkType.Warp).GetOther(oldItem);
if(oldBuddy!=null)
boolwarpIsExit=Mask.Warp_Start.Fits(oldItem.elementType);
ItemnewOtherItem=Item.GetFreeItem;
newOtherItem.SetType(oldBuddy.elementType).
SetRootPos(Level.HitPoint).
SetSide(oldBuddy.side).
Refresh();
Link.Create(linkType.Warp,warpIsExit?newItem:newOtherItem,warpIsExit?newOtherItem:newItem);
else
TracknewTrack=Track.GetNewTrack(ElementEdit.elementType);
newTrack.SetRootPos(Level.HitPoint).SetSide(ElementEdit.side);
newTrack.offset=ElementEdit.track.offset;
newTrack.speed=ElementEdit.track.speed;
newTrack.angle=ElementEdit.track.angle;
newTrack.size=ElementEdit.track.size;
if(Mask.TrackCanGrow.Fits(newTrack.elementType))
((Track_Arc)newTrack).growth=((Track_Arc)ElementEdit.track).growth;
for(inti=0;i<ElementEdit.track.itemCount;i++)
ItemnewItem=Item.GetFreeItem;
newItem.SetType(ElementEdit.track.items[i].elementType);
newTrack.ParentThis(newItem);
newTrack.ScanAndRefesh();
ElementEdit.Select(newTrack);
privatestaticvoidGetVariation()
Itemitem=(Item)LevelCheck.ClosestElement;
if(Input.GetKeyDown(KeyCode.V))
elementTypenewType=item.elementType;
for(inti=0;i<Groups.All.Length;i++)
if(Groups.All[i].Contains(item.elementType))
newType=Groups.All[i].Next(item.elementType);
break;
if(newType!=item.elementType)
ItemnewItem=Item.GetFreeItem;
newItem.SetType(newType);
if(item.parent==null)
newItem.SetRootPos(item.rootPos).SetSide(item.side).Refresh();
item.Delete();
else
item.parent.ReplaceAt((Item)LevelCheck.ClosestElement,newItem).ScanAndRefesh();
UI_Creator.SetCurrentElement(newType.ToString());
publicstaticclassAudio
publicstaticclassMusic
publicstaticreadonlyAudioID
Menu=newAudioID("",1),
Pause=newAudioID("",1),
Morricone=newAudioID("m_morricone",1),
Moriat=newAudioID("m_moriat",1),
Katamari=newAudioID("m_katamari",1),
Plaid=newAudioID("m_plaid",1);
publicstaticclassAmbient
publicstaticreadonlyAudioID
Pause=newAudioID("",1),
CityLoop=newAudioID("a_cityloop",1),
Birds=newAudioID("a_birds",1);
publicstaticclassUI
publicstaticreadonlyAudioID
ScoreUp=newAudioID("u_scoreUp",.5f),
OldStick=newAudioID("u_oldStick",.7f),
HighScore=newAudioID("u_highscore",1);
publicstaticclassReaction
publicstaticreadonlyAudioID
DrummRoll=newAudioID("r_drumRoll",1),
SnareHit=newAudioID("r_snareHit",1),
CymbalHit=newAudioID("r_cymbalHit",.6f);
publicstaticclassSound
publicstaticreadonlyAudioID
StickContact=newAudioID("s_stickContact",.9f),
StickJump=newAudioID("s_stickJump",.9f),
StickWarp=newAudioID("s_stickWarp",.3f),
DeathHit=newAudioID("s_deathHit",.4f),
DeathAir=newAudioID("s_deathAir",1);
publicclassAudioID
publicreadonlyintclipHash;
publicreadonlyfloatvolume;
publicreadonlyintmixerHash;
publicAudioID(stringclipName,floatvolume,intmixerHash=0)
clipHash=clipName.GetHashCode();
this.volume=volume;
if(mixerHash==0&&clipName.Length>0)
switch(clipName[0])
default:this.mixerHash=Mixer.Master;break;
case'm':this.mixerHash=Mixer.Music;break;
case'u':this.mixerHash=Mixer.UI;break;
case'r':this.mixerHash=Mixer.Reactor;break;
case'a':
case's':this.mixerHash=Mixer.All;break;
else
this.mixerHash=mixerHash;
publicstaticclassMixer
publicstaticreadonlyint
Master="Master".GetHashCode(),
Music="Music".GetHashCode(),
UI="UI".GetHashCode(),
Reactor="Reactor".GetHashCode(),
Front="Front".GetHashCode(),
Back="Back".GetHashCode(),
All="All".GetHashCode();
publicclassCharacterAsMusicSourceTest:MonoBehaviour
privateSound.SoundObjectsound;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
/*if(Spinner.Get(1).IsActive&&sound==null)
sound=Sound.Get(Audio.Music.Katamari).SetSpinner(Spinner.Get(1)).Volume(.3f).Loop().Play();
if(!Spinner.Get(1).IsActive&&sound!=null)
sound.Stop();
sound=null;
publicclassHeightAmbience:MonoBehaviour
publicAudioSourcesource;
publicVector4heights;
privatefloatvolume;
privatevoidAwake()
volume=source.volume;
privatevoidLateUpdate()
floatcamHeight=GameCam.CurrentPos.y;
if(camHeight<=heights.w||camHeight>=heights.x)
source.volume=0;
return;
if(camHeight<=heights.z)
source.volume=volume*(1-Mathf.InverseLerp(heights.z,heights.y,camHeight));
return;
if(camHeight>=heights.y)
source.volume=volume*(1-Mathf.InverseLerp(heights.y,heights.x,camHeight));
return;
source.volume=volume;
publicclassMusicSideSpeed:MonoBehaviour
publicAudioSourcesource;
publicboolchangeSpeeds;
privateboolfront=true;
privatevoidLateUpdate()
if(!changeSpeeds)
return;
boolfrontNow=GameCam.CurrentSide.front;
if(frontNow!=front)
front=frontNow;
source.pitch=front?1:.95f;
publicstaticpartialclassSound
privatestaticboolCanPlay{get{return!SetVolume.Mute&&GameManager.Running&&!GTime.Paused;}}
privatestaticAudioMixermixer;
privatestaticSoundObject[]soundObjects;
privatestaticDictionary<int,AudioClip>audioClipDict;
privatestaticDictionary<int,AudioMixerGroup>mixerDict;
privatestaticboolfront;
publicstaticvoidGameLoad()
constintnrOfSounds=40;
soundObjects=newSoundObject[nrOfSounds];
GameObjectdummy=newGameObject("SoundObject",typeof(AudioSource));
AudioSourcesource=dummy.GetComponent<AudioSource>();
source.rolloffMode=AudioRolloffMode.Linear;
source.dopplerLevel=0;
source.playOnAwake=false;
Transformgroup=Application.isEditor?newGameObject("SoundObjects").transform:null;
if(group!=null)
group.SetParent(SceneLocator.Audio);
for(inti=0;i<nrOfSounds;i++)
soundObjects[i]=newSoundObject(Object.Instantiate(dummy,group));
Object.Destroy(dummy);
_SoundPacksoundPack=Resources.Load("Audio/SoundPack_Game")as_SoundPack;
audioClipDict=newDictionary<int,AudioClip>();
for(inti=0;i<soundPack.musicClips.Length;i++)
audioClipDict.Add(soundPack.musicClips[i].name.GetHashCode(),soundPack.musicClips[i]);
for(inti=0;i<soundPack.ambientClips.Length;i++)
audioClipDict.Add(soundPack.ambientClips[i].name.GetHashCode(),soundPack.ambientClips[i]);
for(inti=0;i<soundPack.uiClips.Length;i++)
audioClipDict.Add(soundPack.uiClips[i].name.GetHashCode(),soundPack.uiClips[i]);
for(inti=0;i<soundPack.reactorClips.Length;i++)
audioClipDict.Add(soundPack.reactorClips[i].name.GetHashCode(),soundPack.reactorClips[i]);
for(inti=0;i<soundPack.soundClips.Length;i++)
audioClipDict.Add(soundPack.soundClips[i].name.GetHashCode(),soundPack.soundClips[i]);
Resources.UnloadAsset(soundPack);
mixer=Resources.Load("Audio/Everything")asAudioMixer;
mixerDict=newDictionary<int,AudioMixerGroup>();
AudioMixerGroup[]allMixerGroups=mixer.FindMatchingGroups(string.Empty);
for(inti=0;i<allMixerGroups.Length;i++)
mixerDict.Add(allMixerGroups[i].name.GetHashCode(),allMixerGroups[i]);
privatestaticreadonlySoundObjectNoSound=newSoundObject(null);
publicstaticSoundObjectGet(AudioIDaudioID)
AudioClipclip;
audioClipDict.TryGetValue(audioID.clipHash,outclip);
if(clip==null)
returnNoSound;
AudioMixerGroupmixerGroup;
mixerDict.TryGetValue(audioID.mixerHash,outmixerGroup);
if(mixerGroup==null)
mixerGroup=mixerDict[Mixer.Master];
intsoundObjectsLength=soundObjects.Length;
for(inti=0;i<soundObjectsLength;i++)
if(!soundObjects[i].isPlaying)
returnsoundObjects[i].Setup(clip,audioID.volume,mixerGroup);
returnNoSound;
publicstaticvoidSoundUpdate()
Profiler.BeginSample("Sound.SoundUpdate()");
if(GameCam.CurrentSide.front!=front)
front=GameCam.CurrentSide.front;
mixer.SetFloat("FrontVolume",front?0:-5);
mixer.SetFloat("BackVolume",!front?0:-5);
mixer.SetFloat("FrontLow",front?22000:1500);
mixer.SetFloat("BackLow",!front?22000:1500);
mixer.SetFloat("FrontHigh",front?0:500);
mixer.SetFloat("BackHigh",!front?0:500);
intsoundObjectsLength=soundObjects.Length;
for(inti=0;i<soundObjectsLength;i++)
if(soundObjects[i].isPlaying)
soundObjects[i].Update();
if(SoundObject.Visualize)
Vector2hitPoint=Level.HitPoint;
floatz=(Level.WallDepth+.05f)*GameCam.CurrentSide.Sign;
floatvolume=SoundObject.GetVolumeAndPan(hitPoint.V3(z)).x;
DRAW.Text(volume.ToString("F3"),hitPoint.V3(z),COLOR.red.tomato,2,offset:V2.up*4);
DRAW.MultiCircle(hitPoint,.7f,4,1,20).SetColor(f.Same(volume,0)?COLOR.purple.violet:COLOR.red.tomato).SetDepth(z);
Profiler.EndSample();
publicstaticpartialclassSound
publicclassSoundObject
[Switch("Audio/Visualize")]publicstaticboolVisualize;
privatereadonlyGameObjectobj;
privatereadonlyAudioSourcesource;
privateItemitem;
privateSpinnerspinner;
privatefloatstartTime,length,fadeTime,volume,pitch,volMulti;
publicboolisPlaying;
privateboolMuted{get{returnobj==null||!CanPlay;}}
publicSoundObject(GameObjectobj)
if(obj==null)return;
this.obj=obj;
source=obj.GetComponent<AudioSource>();
obj.SetActive(false);
publicSoundObjectSetup(AudioClipaudioClip,floatvolume,AudioMixerGroupmixerGroup)
source.clip=audioClip;
this.volume=volume;
length=audioClip.length;
source.outputAudioMixerGroup=mixerGroup;
source.loop=false;
pitch=1;
item=null;
spinner=null;
fadeTime=0;
volMulti=1;
returnthis;
publicSoundObjectVolume(floatvolume,floatrandomRange=0)
if(Muted)
returnthis;
this.volume*=volume*1+Random.Range(-randomRange,randomRange);
returnthis;
publicSoundObjectPlayerMulti(Spinnerspinner)
if(Muted)
returnthis;
volume*=spinner.isFocus?1:.6f;
returnthis;
publicSoundObjectPitch(floatpitch,floatrandomRange=0)
if(Muted)
returnthis;
this.pitch*=pitch*1+Random.Range(-randomRange,randomRange);
returnthis;
publicSoundObjectLoop()
if(Muted)
returnthis;
source.loop=true;
returnthis;
publicSoundObjectFade(floatfadeTime)
if(Muted)
returnthis;
this.fadeTime=fadeTime;
returnthis;
publicSoundObjectSetSide(Sideside)
if(Muted)
returnthis;
source.outputAudioMixerGroup=mixerDict[side.front?Mixer.Front:Mixer.Back];
returnthis;
publicSoundObjectSetItem(Itemitem)
if(Muted)
returnthis;
Vector2volPan=GetVolumeAndPan(item.GetPos(GTime.Now).V3(Level.GetWallDist(item.side)));
if(f.Same(volPan.x,0))
returnNoSound;
volMulti=volPan.x;
source.panStereo=volPan.y;
this.item=item;
returnSetSide(item.side);
publicSoundObjectSetSpinner(Spinnerspinner)
if(Muted)
returnthis;
Clipclip=spinner.currentClip;
Vector3pos=clip.BasicPlacement(GTime.Now).pos;
Sideside=clip.GetSide(GTime.Now);
Vector2volPan=GetVolumeAndPan(pos.SetZ(Level.GetWallDist(side)));
volMulti=volPan.x;
source.panStereo=volPan.y;
this.spinner=spinner;
returnSetSide(clip.GetSide(GTime.Now));
publicSoundObjectPlay()
if(Muted)
returnthis;
obj.SetActive(true);
isPlaying=true;
source.volume=(!f.Same(fadeTime,0)?0:volume)*volMulti;
source.pitch=pitch;
source.Play();
startTime=Time.realtimeSinceStartup;
returnthis;
publicvoidUpdate()
constfloatadjustSpeed=3;
if(item!=null)
Vector2pos=item.GetPos(GTime.Now);
Vector2volPan=GetVolumeAndPan(pos.V3(Level.GetWallDist(item.side)));
volMulti=Mathf.Lerp(volMulti,volPan.x,Time.deltaTime*adjustSpeed);
source.panStereo=volPan.y;
if(Visualize&&GameCam.CurrentSide==item.side)
SoundDraw(pos);
if(spinner!=null)
Clipclip=spinner.currentClip;
Vector3pos=clip.BasicPlacement(GTime.Now).pos;
Sideside=clip.GetSide(GTime.Now);
Vector2volPan=GetVolumeAndPan(pos.SetZ(Level.GetPlaneDist(side)));
volMulti=Mathf.Lerp(volMulti,volPan.x,Time.deltaTime*adjustSpeed);
source.panStereo=volPan.y;
SetSide(side);
if(Visualize&&GameCam.CurrentSide==side)
SoundDraw(pos);
if(!f.Same(fadeTime,0))
floatlerp=Mathf.InverseLerp(startTime,startTime+fadeTime,Time.realtimeSinceStartup);
source.volume=volume*lerp*volMulti;
else
source.volume=volume*volMulti;
floatlerp=Mathf.Lerp(length,length/pitch,.01f);
if(!source.loop&&Time.realtimeSinceStartup>startTime+lerp)
Stop();
privatevoidSoundDraw(Vector2pos)
floatlerp=Mathf.InverseLerp(startTime,startTime+length,Time.realtimeSinceStartup);
Colorcolor=COLOR.red.tomato.A(1-lerp);
DRAW.Text(volMulti.ToString("F3"),pos.V3(Z.W05),color,2,offset:V2.up*4);
DRAW.MultiCircle(pos,.7f,4,1,20).SetColor(color).SetDepth(Z.W05);
publicvoidStop()
if(Muted)
return;
source.Stop();
obj.SetActive(false);
isPlaying=false;
item=null;
publicstaticVector2GetVolumeAndPan(Vector3worldPos)
Vector2vPos=GameCam.Cam.WorldToViewportPoint(worldPos).V2()*2-V2.one;
floatpan=vPos.x*.4f;
floatfactor=ScreenControll.Landscape?1f/GameCam.Cam.aspect:1;
returnnewVector2(Mathf.Min(ToVolume(vPos.x,factor),ToVolume(vPos.y)),pan);
privatestaticfloatToVolume(floatvalue,floatfactor=1)
constfloatiMargin=1f,oMargin=.5f;
floatlinear=1-Mathf.InverseLerp(1-iMargin*factor,1+oMargin*factor,Mathf.Abs(value));
return1-Mathf.Pow(1-linear,1.5f);
publicclassSoundSchedule:Singleton<SoundSchedule>
privatestructSoundToPlay
privatereadonlyAudioIDid;
privatereadonlyItemitem;
publicreadonlyfloattime;
privatereadonlyfloatvolume;
privatereadonlyfloatpitch;
publicSoundToPlay(AudioIDid,Itemitem,floattime,floatvolume,floatpitch)
this.id=id;
this.item=item;
this.time=time;
this.volume=volume;
this.pitch=pitch;
publicvoidPlaySound()
Sound.Get(id).Volume(volume).Pitch(pitch).SetItem(item).Play();
privatestaticreadonlyList<SoundToPlay>soundsToPlay=newList<SoundToPlay>(100);
privatevoidUpdate()
intcount=soundsToPlay.Count;
for(inti=0;i<count;i++)
if(soundsToPlay[i].time<=GTime.Now)
soundsToPlay.GetRemoveAt(i).PlaySound();
i--;
count--;
publicstaticvoidScheduleSound(AudioIDid,Itemitem,floattime,floatvolume,floatpitch)
soundsToPlay.Add(newSoundToPlay(id,item,time,volume,pitch));
publicclassByteReplays:Singleton<ByteReplays>
publicByteReplay[]replays;
privateconstinthowMany=3;
publicstaticintCount{privateset;get;}
publicstaticvoidResetCount()
Count=0;
publicstaticboolAddReplay()
if(Count<Inst.replays.Length)
Inst.replays[Count++].ParseBytes(ByteStream.reader);
returntrue;
returnfalse;
publicstaticvoidGameUpdate()
if(GameManager.Running&&Input.GetKeyDown(KeyCode.H))
LoadRandomReplayForAll();
privatestaticvoidLoadRandomReplayForAll()
for(inti=0;i<howMany;i++)
LoadRandomReplay(Spinner.Get(i+1));
publicstaticvoidLoadRandomReplayFor(Spinnerspinner)
LoadRandomReplay(spinner);
privatestaticvoidLoadRandomReplay(Spinnerspinner)
spinner.Disable();
intactiveCount=Spinner.active.Count;
while(true)
ByteReplayreplay=Inst.replays[UnityEngine.Random.Range(0,Count)];
boolisFine=true;
for(inti=0;i<activeCount;i++)
if(Spinner.active[i].name==replay.charName)
isFine=false;
if(isFine)
spinner.Enable(replay);
break;
[Serializable]
publicclassByteReplay
publicstringcharName,hex;
publicintscore,clipCount,byteCount;
[Space(5)]
publicCostumecostume;
publicVector3charSize;
privatereadonlybyte[]bytes=newbyte[10240];
publicstaticbyte[]Serialize(intclipCount)
Spinnerspinner=Spinner.GetPlayer;
MemoryStreamm=newMemoryStream();
writer.Write(ReplaySaveLoad.IDHex);
writer.Write(spinner.name);
writer.Write((ushort)Score.PlayerOneScore);
Costume.Serialize(spinner.costume,writer);
writer.Write(spinner.size.x);
writer.Write(spinner.size.y);
writer.Write(spinner.size.z);
writer.Write((ushort)clipCount);
m.Dispose();
returnm.ToArray();
publicvoidParseBytes(BinaryReaderreader,booldebug=false)
hex=reader.ReadString();
charName=reader.ReadString();
score=reader.ReadUInt16();
costume=Costume.Deserialize(reader);
charSize=newVector3(reader.ReadSingle(),
reader.ReadSingle(),
reader.ReadSingle());
clipCount=reader.ReadUInt16();
if(debug)
Debug.Log(("Name:"+charName).PadRight(20)+
("|Score:"+score.ToString().PadLeft(3)).PadRight(15)+
("|ClipCount:"+clipCount.ToString().PadLeft(3)).PadRight(20)+
"|Hex:"+hex);
longstartPos=reader.BaseStream.Position;
for(inti=0;i<clipCount;i++)
ClipTypetype=(ClipType)Mathf.Abs(reader.ReadSByte());
Clip.SkipClip(reader,type);
byteCount=(int)(reader.BaseStream.Position-startPos);
reader.BaseStream.Position=startPos;
for(inti=0;i<byteCount;i++)
bytes[i]=reader.ReadByte();
publicvoidDeserializeClips(Spinnerspinner,boolshift=false)
ByteStream.Set(bytes,byteCount);
floattimeShift=0;
if(shift)
ByteStream.stream.Position=1;
Clip.SkipClip(ByteStream.reader,ClipType.Spawn);
sbytetypeAndSide=ByteStream.reader.ReadSByte();
ClipTypeclipType=(ClipType)Mathf.Abs(typeAndSide);
Sideside=newSide(typeAndSide<0);
Clipclip=Clip.Deserialize(ByteStream.reader,spinner,clipType,side);
if(clip!=null)
floatstart=clip.startTime;
while(true)
if(start+timeShift<GTime.Now)
timeShift+=GTime.LoopTime;
else
break;
clip.Reset();
ByteStream.stream.Position=0;
Tapetape=spinner.tape;
tape.Clear();
for(inti=0;i<clipCount;i++)
sbytetypeAndSide=ByteStream.reader.ReadSByte();
ClipTypeclipType=(ClipType)Mathf.Abs(typeAndSide);
Sideside=newSide(typeAndSide<0);
Clipclip=Clip.Deserialize(ByteStream.reader,spinner,clipType,side,timeShift);
if(clip!=null)
tape.SetClip(clip);
if(i==0)
spinner.startTime=clip.startTime;
else
tape.Clear();
return;
publicstaticclassReplaySaveLoad
publicstaticstringIDHex{get{returnHexString+HexString;}}
privatestaticstringHexString{get{returnRandom.Range(0,65535).ToString("X4");}}
[Switch("Tape/SaveLocalReplay")]privatestaticboolSaveLocally;
privateconststringLocalReplayFolder=@"D:\_SYNCHARDER\SPINNER\LocalReplays\";
publicstaticIEnumeratorSaveReplay()
Spinnerspinner=Spinner.GetPlayer;
stringname=spinner.name;
byte[]bytes=spinner.GetReplayBytes();
if(bytes.Length==0)
Debug.Log("Replaywasn'tSerializable...".B_Yellow());
yieldbreak;
if(Application.isEditor&&SaveLocally)
SaveLocalReplay(bytes);
if(!Database.IsConnected)
yieldbreak;
Debug.Log("UploadingReplayfor"+name);
WWWFormform=newWWWForm();
form.AddField("i",BotPlayers.GetNameID(name));
form.AddField("s",Score.PlayerOneScore);
form.AddBinaryData("b",bytes);
UnityWebRequestwww=UnityWebRequest.Post(Database.UploadScorePHP,form);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.Log(www.error.B_Red());
www.Dispose();
publicstaticIEnumeratorGetReplayBytes(Action<byte[]>byteCallback)
if(!Database.IsConnected&&!Application.isMobilePlatform)
byteCallback(GetLocalReplay());
yieldbreak;
UnityWebRequestwww=UnityWebRequest.Get(Database.GetRandomReplayPHP);
yieldreturnwww.SendWebRequest();
if(!www.isNetworkError&&!www.isHttpError)
byteCallback(www.downloadHandler.data);
www.Dispose();
privatestaticvoidSaveLocalReplay(byte[]bytes)
stringpath=LocalReplayFolder+FancyString.GetRandom(10)+".rpl";
fs.Write(bytes,0,bytes.Length);
privatestaticbyte[]GetLocalReplay()
string[]files=Directory.GetFiles(LocalReplayFolder);
stringpath=files[Random.Range(0,files.Length)];
returnFile.ReadAllBytes(path);
publicclassSceneLocator:Singleton<SceneLocator>
publicTransformui,characters,items,fluff,collectables,level,scenery,camera,audio;
publicstaticTransformMain{get{returnApplication.isEditor?Inst.transform:null;}}
publicstaticTransformUI{get{returnApplication.isEditor?Inst.ui:null;}}
publicstaticTransformCharacters{get{returnApplication.isEditor?Inst.characters:null;}}
publicstaticTransformItems{get{returnApplication.isEditor?Inst.items:null;}}
publicstaticTransformFluff{get{returnApplication.isEditor?Inst.fluff:null;}}
publicstaticTransformCollectables{get{returnApplication.isEditor?Inst.collectables:null;}}
publicstaticTransformLevel{get{returnApplication.isEditor?Inst.level:null;}}
publicstaticTransformScenery{get{returnApplication.isEditor?Inst.scenery:null;}}
publicstaticTransformCamera{get{returnInst.camera;}}
publicstaticTransformAudio{get{returnApplication.isEditor?Inst.audio:null;}}
publicclassScreenControll:MonoBehaviour
privatestaticDeviceOrientationorientation=DeviceOrientation.Portrait;
privatestaticreadonlyDictionary<DeviceOrientation,ScreenOrientation>getScreenOrientation=newDictionary<DeviceOrientation,ScreenOrientation>
publicstaticfloatWidth,Height,Aspect;
publicstaticboolLandscape;
publicdelegatevoidOrientationChange();
publicstaticeventOrientationChangeonOrientationChange;
privatefloatcheckWidth,checkHeight;
publicstaticfloatPixelPerMilimeter{get{returnScreen.dpi*.048f;}}
privatevoidStart()
Screen.autorotateToLandscapeLeft=false;
Screen.autorotateToLandscapeRight=false;
Screen.autorotateToPortrait=false;
Screen.autorotateToPortraitUpsideDown=false;
CamUpdate();
SetNewOrientation();
CheckOrientation();
privatevoidUpdate()
CamUpdate();
if(GTime.Paused&&Input.deviceOrientation!=orientation)
SetNewOrientation();
CheckOrientation();
privatestaticvoidCamUpdate()
Cameracam=Camera.main;
Width=cam!=null?cam.pixelWidth:Screen.width;
Height=cam!=null?cam.pixelHeight:Screen.height;
Aspect=Width/Height;
Landscape=Width>=Height;
privatestaticvoidSetNewOrientation()
switch(Input.deviceOrientation)
caseDeviceOrientation.Portrait:
caseDeviceOrientation.LandscapeLeft:
caseDeviceOrientation.LandscapeRight:
orientation=Input.deviceOrientation;
Screen.orientation=getScreenOrientation[orientation];
break;
privatevoidCheckOrientation()
if(f.Same(checkWidth,Width)&&f.Same(checkHeight,Height))
return;
checkWidth=Width;
checkHeight=Height;
if(onOrientationChange!=null)
onOrientationChange();
publicclassWebGLMessageListener:MonoBehaviour
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
privatestaticvoidCreateInstanceIfWebGL()
if(Application.platform==RuntimePlatform.WebGLPlayer)
GameObjectnewObject=newGameObject("MessageListener");
newObject.AddComponent<WebGLMessageListener>();
privatevoidOnEnable()
Debug.Log("ActiveListenerName:"+gameObject.name);
publicvoidSendReplayURL(stringurl)
Debug.Log(url);
StartCoroutine(GetReplay(url));
privatestaticIEnumeratorGetReplay(stringurl)
WWWnewWWW=newWWW(url);
yieldreturnnewWWW;
Debug.Log(newWWW.bytes.Length);
publicclassBatchAndScale:MonoBehaviour
publicTransform[]exclude;
privatevoidAwake()
transform.localScale=newVector3(1,1,Level.WallDepth*2);
Transform[]parents=newTransform[exclude.Length];
for(inti=0;i<exclude.Length;i++)
parents[i]=exclude[i].parent;
exclude[i].SetParent(null);
StaticBatchingUtility.Combine(gameObject);
for(inti=0;i<exclude.Length;i++)
exclude[i].SetParent(parents[i]);
publicclassBatchThis:MonoBehaviour
privatevoidAwake()
StaticBatchingUtility.Combine(gameObject);
publicclassScaleWall:MonoBehaviour
privatevoidAwake()
transform.localScale=newVector3(1,1,Level.WallDepth*2);
GameObject[]c=newGameObject[transform.childCount];
GameObject[]cc=newGameObject[transform.childCount];
intnr=0;
foreach(Transformtintransform)
c[nr]=t.gameObject;
foreach(Transformttint)
cc[nr]=tt.gameObject;
c[nr].isStatic=true;
if(cc[nr]!=null)
cc[nr].isStatic=true;
nr++;
StaticBatchingUtility.Combine(c,gameObject);
if(cc[0]!=null)
StaticBatchingUtility.Combine(cc,gameObject);
publicclassWallAllign:MonoBehaviour
privatevoidOnEnable()
transform.localScale=newVector3(1,1,Level.WallDepth*2);
privatevoidLateUpdate()
if(!GameManager.Running&&!GTime.Paused)
return;
Vector3wallPos=Vector3.ProjectOnPlane(GameCam.frustum.focusPoint,V3.forward);
transform.position=newVector3(wallPos.x,wallPos.y,0);
publicclassWallMaster:Singleton<WallMaster>
publicTransformwalls,shadows;
[Serializable]
publicclassCellposMesh
publicintcellX,cellY;
publicMeshRendererrenderer;
privateboolvisible;
publicCellposMesh(MeshRendererrenderer)
this.renderer=renderer;
renderer.enabled=false;
publicvoidSetCellPos()
Vector2IntcellPos=Cell.ToCellPos(renderer.bounds.center);
cellX=cellPos.x;
cellY=cellPos.y;
publicvoidUpdateVisibility()
if(Level.CellIsVisible(cellX,cellY)!=visible)
visible=!visible;
renderer.enabled=visible;
privatestaticreadonlyCellposMesh[]wallMeshes=newCellposMesh[200],
cellMeshes=newCellposMesh[200];
privatestaticintwallCount,shadowCount;
privatevoidStart()
MeshRenderer[]meshRenderers=walls.GetComponentsInChildren<MeshRenderer>();
wallCount=meshRenderers.Length;
for(inti=0;i<wallCount;i++)
wallMeshes[i]=newCellposMesh(meshRenderers[i]);
MeshRenderer[]meshRenderers=shadows.GetComponentsInChildren<MeshRenderer>();
shadowCount=meshRenderers.Length;
for(inti=0;i<shadowCount;i++)
cellMeshes[i]=newCellposMesh(meshRenderers[i]);
publicstaticvoidGameStart()
for(inti=0;i<wallCount;i++)
wallMeshes[i].SetCellPos();
for(inti=0;i<shadowCount;i++)
cellMeshes[i].SetCellPos();
publicstaticvoidGameUpdate()
for(inti=0;i<wallCount;i++)
wallMeshes[i].UpdateVisibility();
for(inti=0;i<shadowCount;i++)
cellMeshes[i].UpdateVisibility();
publicclassAngleCam:MonoBehaviour
publicPauseCampauseCam;
publicSideSwitchersideSwitcher;
privateboolswiping;
privateVector2lastFingerPos;
privateQuaternionspin=Rot.Zero,smoothSpin=Rot.Zero;
publicQuaternionpivotRot=Quaternion.identity;
privateSideside;
privatevoidOnEnable()
Controll.onSwipe+=onSwipe;
privatevoidOnDisable()
Controll.onSwipe-=onSwipe;
privatevoidonSwipe(boolstart)
if(start)
if(!swiping&&(GTime.Paused||GameManager.Mode==Mode.Creator&&Input.GetKey(KeyCode.LeftAlt)))
swiping=true;
lastFingerPos=Controll.TouchPos;
spin=smoothSpin=Rot.Zero;
else
swiping=false;
publicvoidReset()
CamUpdate();
publicvoidCamUpdate()
if(!GTime.Paused||side!=GameCam.CurrentSide)
pivotRot=Quaternion.Slerp(sideSwitcher.pivotRot,pivotRot,pauseCam.blendWeight);
spin=smoothSpin=Quaternion.identity;
if(!GTime.Paused)
side=GameCam.CurrentSide;
return;
if(GameManager.Mode!=Mode.Creator||Input.GetKey(KeyCode.LeftAlt))
if(swiping)
Vector2moveDelta=(Controll.TouchPos-lastFingerPos)/ScreenControll.PixelPerMilimeter;
moveDelta=moveDelta.normalized*Mathf.Clamp(moveDelta.magnitude,0,5);
if(!GameCam.CurrentSide.front)
moveDelta=newVector2(moveDelta.x,-moveDelta.y);
spin=Quaternion.AngleAxis(moveDelta.magnitude*4.25f,moveDelta.normalized.Rot(90));
lastFingerPos=Controll.TouchPos;
else
spin=Rot.Zero;
smoothSpin=Quaternion.Slerp(smoothSpin,spin,Time.deltaTime*(swiping?7:3));
Quaternioncombined=ClampAngler(smoothSpin*pivotRot,GameCam.CurrentSide.front);
Vector3aim=combined*V3.forward;
if(float.IsNaN(aim.x))
aim=Vector3.forward;
pivotRot=Quaternion.LookRotation(aim,V3.up);
privatestaticQuaternionClampAngler(Quaternionrot,boolfront)
floatdot=Vector3.Dot(rot*V3.forward,V3.forward);
floatdotDistance=1-Mathf.Abs(dot);
floatnewDot=Mth.DampedRange(Mathf.Clamp(dotDistance,0,GameCam.MaxDot),GameCam.MaxDot*.4f,GameCam.MaxDot);
QuaternionsideForward=front?Quaternion.identity:Quaternion.Euler(0,180,0);
returnQuaternion.Slerp(sideForward,rot,newDot/dotDistance);
publicclassBlurCam:MonoBehaviour
publicCamerabackCam;
[Space(10)]
publicMaterialblurMat;
privateRenderTexturerenderTex;
[Switch("Camera/Blur")]privatestaticboolblurBackground=true;
privatevoidOnPreRender()
if(blurBackground)
renderTex=RenderTexture.GetTemporary((int)(ScreenControll.Width*1),(int)(ScreenControll.Height*1),8);
renderTex.filterMode=FilterMode.Trilinear;
backCam.targetTexture=renderTex;
else
if(backCam.targetTexture!=null)
backCam.targetTexture=null;
privatevoidOnPostRender()
if(!blurBackground)
return;
backCam.targetTexture=null;
Graphics.Blit(renderTex,null,blurMat);
RenderTexture.ReleaseTemporary(renderTex);
publicclassCamDebug:MonoBehaviour
[Switch("Camera/Frustum")]privatestaticboolshowFrustum=false;
[Switch("Camera/Attractors")]privatestaticboolshowAttractors=false;
[Switch("Camera/Anchor")]privatestaticboolshowAnchor=false;
[Switch("Camera/MapOutline")]privatestaticboolmapOutline=false;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
if(showFrustum)
GameCam.frustum.DebugDraw();
if(showAttractors)
ShowAttractors();
if(showAnchor)
ShowAnchor();
if(mapOutline)
MapCam.MapOutlineDRAW();
privatestaticvoidShowAttractors()
floatz=GameCam.CurrentSide.Sign*(Level.WallDepth+.1f);
Colorc=Color.Lerp(COLOR.yellow.fresh,COLOR.red.tomato,.5f);
DRAW.Circle(GameCam.frustum.focusPoint,.75f,12).SetColor(COLOR.red.tomato).SetDepth(z);
DRAW.Circle(GameCam.frustum.focusPoint,.55f,12).SetColor(c).SetDepth(z);
Clipclip=Spinner.CurrentFocusClip;
if(clip!=null&&clip.GetSide(GTime.Now).IsVisible)
Vector3playerPos=clip.BasicPlacement(GTime.Now).pos;
DRAW.DotVector(playerPos,GameCam.frustum.focusPoint-playerPos,.1f,.2f).
SetColor(COLOR.turquois.aquamarine).SetDepth(z);
DRAW.GapVector(playerPos.SetZ(z),playerPos.SetZ(Z.P)-playerPos.SetZ(z),5).SetColor(COLOR.red.tomato);
privatestaticvoidShowAnchor()
DRAW.Vector(GameCam.Cam.transform.position,GameCam.CurrentPivotPos).SetColor(COLOR.purple.violet);
DRAW.Vector(GameCam.CurrentPivotPos-Vector3.forward*1000,Vector3.forward*2000);
publicstaticclassCamManager
privatestaticGameCamgameCam;
privatestaticGameObjectcamInst;
privatestaticGameObjectuiCam;
publicstaticvoidGameLoad()
foreach(TransformchildinSceneLocator.Camera)
uiCam=child.gameObject;
camInst="Camera/GameCam".ResourceInst(SceneLocator.Camera);
gameCam=camInst.GetComponent<GameCam>();
DRAW.DrawCam=GameCam.Cam;
uiCam.SetActive(false);
publicstaticvoidGameStart()
gameCam.ResetCamera();
publicstaticvoidLateGameUpdate()
gameCam.CameraUpdate();
publicstaticclassConvexHull
privatestaticreadonlyint[]validPoints=newint[8];
privatestaticintquerryIndex;
privatestaticreadonlyVector2[]checkPoints=newVector2[8];
privatestaticreadonlyfloat[]checkAngles=newfloat[8];
publicstaticintGetHull(Vector2[]points,Vector2[]hull)
querryIndex++;
intpointCount=points.Length;
inthullCount=0;
intstartPoint=0;
floatstartX=float.MaxValue;
for(inte=0;e<pointCount;e++)
if(points[e].x<startX)
startX=points[e].x;
startPoint=e;
hull[hullCount++]=points[startPoint];
Vector2compareDir=Vector2.up;
intcurrentPoint=startPoint;
while(true)
intnextPoint=currentPoint;
floatbestAngle=float.MaxValue;
Vector2currentP=points[currentPoint];
for(inte=1;e<pointCount;e++)
intindex=(currentPoint+e)%pointCount;
if(validPoints[index]==querryIndex)
continue;
Vector2checkDir=points[index]-currentP;
floatdot=compareDir.x*checkDir.x+compareDir.y*checkDir.y;
floatdet=compareDir.x*checkDir.y-compareDir.y*checkDir.x;
floatangle=-Mathf.Atan2(det,dot);
if(angle>0&&angle<bestAngle)
bestAngle=angle;
nextPoint=index;
if(nextPoint==startPoint)
break;
Vector2nextP=points[nextPoint];
compareDir=nextP-currentP;
currentPoint=nextPoint;
hull[hullCount++]=nextP;
validPoints[currentPoint]=querryIndex;
returnhullCount;
publicstaticintGetHull(Quada,Quadb,Vector2[]hull)
querryIndex++;
intcount=0;
for(inti=0;i<4;i++)
if(!b.Contains(a[i]))
checkPoints[count++]=a[i];
for(inti=0;i<4;i++)
if(!a.Contains(b[i]))
checkPoints[count++]=b[i];
Vector2center=Vector3.zero;
for(inti=0;i<count;i++)
center+=checkPoints[i];
center/=count;
for(inti=0;i<count;i++)
checkAngles[i]=(checkPoints[i]-center).ToRadian();
querryIndex++;
for(inti=0;i<count;i++)
intbest=0;
floatmax=float.MinValue;
for(inte=0;e<count;e++)
if(validPoints[e]!=querryIndex&&checkAngles[e]>max)
best=e;
max=checkAngles[e];
validPoints[best]=querryIndex;
hull[i]=checkPoints[best];
returncount;
publicenumCellVis{None,Some,All}
publicclassFrustum
publicconstintcells=8,cellCount=cells*cells;
privatereadonlyCameracam;
privatereadonlyTransformcamTransform;
publicVector3focusPoint;
privatereadonlyVector3[]camRays=newVector3[4];
publicBounds2DfrontBounds,backBounds;
privatereadonlybool[]frontCellCheck=newbool[cellCount],
backCellCheck=newbool[cellCount];
privatereadonlyCellVis[]frontVis=newCellVis[cellCount],
backVis=newCellVis[cellCount];
privatereadonlyint[]min=newint[cells],max=newint[cells];
privateboolfront,isValid;
publicVector2IntminCell;
privatereadonlyfloat[]quadDepths={-Level.BorderDepth,-Level.WallDepth,Level.WallDepth,Level.BorderDepth};
privatereadonlyQuad[]quads=CollectionInit.Array<Quad>(4);
privatereadonlyQuadshadowQuad=newQuad();
privateColor[]colors;
privatestaticinthullCount;
privatereadonlyVector2[]hull=newVector2[6];
privatestaticreadonlyLine[]wrapLines=newLine[6];
publicFrustum(Cameracam)
this.cam=cam;
camTransform=cam.transform;
publicvoidUpdate()
Vector3camPos=camTransform.position;
Vector3camForward=camTransform.forward;
QuaternioncamRot=camTransform.rotation;
front=camPos.z<0;
floatyFac=Mathf.Tan(cam.fieldOfView*Mathf.Deg2Rad*.5f);
floatxFac=yFac*cam.aspect;
camRays[0]=camRot*newVector3(xFac,yFac,1);
camRays[1]=camRot*newVector3(xFac,-yFac,1);
camRays[2]=camRot*newVector3(-xFac,-yFac,1);
camRays[3]=camRot*newVector3(-xFac,yFac,1);
for(inti=0;i<4;i++)
if(camRays[i].z>0!=front)
isValid=false;
return;
isValid=true;
for(inti=0;i<4;i++)
Quadquad=quads[i];
floatdepth=quadDepths[i];
floattoQuad=Mathf.Abs(camPos.z-depth);
for(inte=0;e<4;e++)
intrayIndex=front?e:3-e;
quad[e]=camPos+camRays[rayIndex]*(toQuad/Mathf.Abs(camRays[rayIndex].z));
quad.CalcBounds();
constfloatmaxDist=300;
quad.bounds=quad.bounds.Clamp(camPos.x-maxDist,camPos.x+maxDist,camPos.y-maxDist,camPos.y+maxDist);
focusPoint=camForward*(-camPos.z.SignAdd(-Level.WallDepth)/camForward.z)+camPos;
MapCam.UpdateMapQuads(quads[front?1:2].bounds,quads[0].bounds.Add(quads[3].bounds));
minCell=Cell.ToCellPos((Mathf.Floor((focusPoint.x+Level.CellHalfSize)/Level.CellSize)+cells*-.5f)*Level.CellSize,
(Mathf.Round(focusPoint.y/Level.CellSize)+cells*-.5f)*Level.CellSize);
frontCellCheck.Clear();
backCellCheck.Clear();
FillVisCells(!front);
FillVisCells(front);
frontBounds=quads[0].bounds.Add(quads[1].bounds);
backBounds=quads[2].bounds.Add(quads[3].bounds);
for(inti=0;i<cellCount;i++)
boolfrontIsVisible=frontCellCheck[i];
boolbackIsVisible=backCellCheck[i];
Bounds2Db=newBounds2D();
if(frontIsVisible||backIsVisible)
Vector2cellPos=newVector2((i%cells+minCell.x)*Level.CellSize+Level.CellHalfSize,
(Mathf.Floor((float)i/cells)+minCell.y)*Level.CellSize+Level.CellHalfSize);
b=newBounds2D(cellPos).Pad(Level.CellHalfSize);
frontVis[i]=frontIsVisible?frontBounds.Contains(b)?CellVis.All:CellVis.Some:CellVis.None;
backVis[i]=backIsVisible?backBounds.Contains(b)?CellVis.All:CellVis.Some:CellVis.None;
privatevoidFillVisCells(boolfrontQuads)
Quadfar=quads[frontQuads?0:3];
Quadsurface=quads[frontQuads?1:2];
if(frontQuads&&front)
for(inti=0;i<4;i++)
shadowQuad[i]=surface[i];
Vector2shadowDir=-LightingSet.ShadowDir.SetZ(0).normalized;
for(inti=0;i<4;i++)
Vector2p1=shadowQuad[i];
Vector2p2=shadowQuad[i.IndexUp(4)];
Vector2dir=(p2-p1).Rot90().normalized;
floatdot=Mathf.Clamp01(Vector2.Dot(shadowDir,dir));
dir=dir.SetLength(3*dot);
wrapLines[i]=newLine(p1,p2).Move(dir);
for(inti=0;i<4;i++)
Vector2intersection;
if(wrapLines[i.IndexDown(4)].Contact(wrapLines[i],outintersection,true))
surface[i]=intersection;
surface.CalcBounds();
hullCount=ConvexHull.GetHull(far,surface,hull);
for(inti=0;i<8;i++)
min[i]=int.MaxValue;
max[i]=int.MinValue;
for(inti=0;i<hullCount;i++)
constfloatmulti=1f/Level.CellSize;
intcount;
Vector2Int[]cellPositions=SuperCover.GetLineCells(hull[i]*multi,hull[(i+1)%hullCount]*multi,outcount);
for(intc=0;c<count;c++)
Vector2IntcellPos=cellPositions[c];
introw=cellPos.y-minCell.y;
if(row>=0&&row<cells)
intx=cellPos.x-minCell.x;
min[row]=Mathf.Min(min[row],x);
max[row]=Mathf.Max(max[row],x);
bool[]vis=frontQuads?frontCellCheck:backCellCheck;
for(inty=0;y<cells;y++)
intstart=min[y],end=max[y]+1;
if(start<cells||end>0)
start=Mathf.Max(0,start);
end=Mathf.Min(cells,end);
for(intx=start;x<end;x++)
vis[y*cells+x]=true;
publicboolInFrustum(Bounds2DcheckBounds,boolfront)
if(!isValid)
returnfalse;
if(front&&frontBounds.Intersects(checkBounds))
for(inti=0;i<2;i++)
if(quads[i].Intersects(checkBounds))
returntrue;
if(!front&&backBounds.Intersects(checkBounds))
for(inti=2;i<4;i++)
if(quads[i].Intersects(checkBounds))
returntrue;
returnfalse;
publicvoidSetCellVis(Level.FrustumCellfrustumCell)
intcellIndex=GetCameraCellIndex(frustumCell.cellPos);
frustumCell.frontVis=frontVis[cellIndex];
frustumCell.backVis=backVis[cellIndex];
privateintGetCameraCellIndex(Vector2IntcellPos)
return(cellPos.y-minCell.y)*cells+(cellPos.x-minCell.x);
publicvoidDebugDraw()
if(colors==null)
colors=new[]
COLOR.red.tomato.A(.5f),
Color.Lerp(COLOR.yellow.fresh,COLOR.red.tomato,.5f).A(.5f),
COLOR.purple.maroon.A(.5f),
COLOR.purple.orchid.A(.5f)
for(inti=0;i<hullCount;i++)
DRAW.Vector(hull[i],hull[(i+1)%hullCount]-hull[i]).SetColor(COLOR.blue.cornflower).SetDepth(Z.W05);
for(inti=0;i<4;i++)
DRAW.Shapeshape=DRAW.Shape.Get(5);
for(inte=0;e<5;e++)
shape.Set(e,quads[i][e%4]);
shape.SetColor(colors[i]).SetDepth(quadDepths[i].SignAdd(.1f));
frontBounds.Draw().SetColor(Color.white).SetDepth(-(Level.WallDepth+Level.PlaneOffset));
backBounds.Draw().SetColor(Color.white).SetDepth(Level.WallDepth+Level.PlaneOffset);
/*for(inti=0;i<4;i++)
DRAW.Vector(quads[0][i].V3(quadDepths[0].SignAdd(.1f)),quads[1][i].V3(quadDepths[1].SignAdd(.1f))-quads[0][i].V3(quadDepths[0].SignAdd(.1f))).SetColor(colors[0]);
DRAW.Vector(quads[2][i].V3(quadDepths[2].SignAdd(.1f)),quads[3][i].V3(quadDepths[3].SignAdd(.1f))-quads[2][i].V3(quadDepths[2].SignAdd(.1f))).SetColor(colors[3]);
for(inti=0;i<4;i++)
DRAW.GapVector(quads[front?0:3][i].V3(quadDepths[front?0:3].SignAdd(.1f)),cam.transform.position-quads[front?0:3][i].V3(quadDepths[front?0:3].SignAdd(.1f)),5).SetColor(colors[front?1:2]);
DRAW.GapVector(focusPoint,cam.transform.position-focusPoint,20).SetColor(colors[front?0:3]);
publicclassGameCam:Singleton<GameCam>
[Switch("Camera/Zoom")]privatestaticboolzoom=false;
publicCameracam;
publicTransformcamPivot;
[Space(10)]
publicSideSwitchersideSwitcher;
publicMoveCammoveCam;
publicAngleCamangleCam;
publicPauseCampauseCam;
publicMultiCammultiCam;
[Space]
publicVector2xAngleAdjust;
publicfloatyOffset;
publicstaticVector2StartPos,CurrentPos;
publicstaticfloatStartDolly,CurrentDolly;
publicstaticSideStartSide,CurrentSide;
publicstaticVector3CurrentPivotPos;
publicstaticQuaternionCurrentPivotRot,RootRot;
publicstaticFrustumfrustum;
privatestaticreadonlyQuaternionlookUp=Quaternion.Euler(-1,0,0);
publicconstfloatgameZoom=-134,//-125,//-105,
closeZoom=-55,
farZoom=-250;
publicstaticCameraCam{get{returnInst!=null?Inst.cam:null;}}
privatevoidAwake()
frustum=newFrustum(cam);
publicstaticvoidSetStartValues(Vector2pos,floatzoom,Sideside)
if(GameManager.Mode==Mode.Creator)
StartPos=pos;
StartDolly=zoom;
StartSide=side;
else
StartPos=Level.StartStick.rootPos;
StartDolly=gameZoom;
StartSide=Level.StartStick.side;
publicvoidResetCamera()
moveCam.Reset();
sideSwitcher.Reset();
angleCam.Reset();
CamUpdate();
publicvoidCameraUpdate()
Profiler.BeginSample("GameCam.CameraUpdate()");
if(GameManager.Mode==Mode.Creator&&UI_Creator.SavingOrLoading)
Profiler.EndSample();
return;
sideSwitcher.CamUpdate();
angleCam.CamUpdate();
moveCam.CamUpdate();
pauseCam.CamUpdate(moveCam.movePos);
CamUpdate();
Profiler.EndSample();
privatevoidCamUpdate()
CurrentPivotRot=angleCam.pivotRot;
CurrentDolly=Mathf.Lerp(moveCam.dolly,pauseCam.dolly,pauseCam.blendWeight)*(zoom?.7f:1);
floatsideLerp=GTime.Paused?CurrentSide.front?-1:1:Mathf.Lerp(-1,1,sideSwitcher.sideLerp);
CurrentPivotPos=newVector3(0,0,(Level.WallDepth+Level.PlaneOffset)*sideLerp);
CurrentPos=Vector3.Lerp(moveCam.movePos,pauseCam.camPos,pauseCam.blendWeight)+newVector3(0,yOffset);
QuaternionbaseRot=sideSwitcher.camRot*Quaternion.Euler(ScreenControll.Landscape?xAngleAdjust.x:xAngleAdjust.y,0,0);
RootRot=Quaternion.Slerp(baseRot,pauseCam.camRot,pauseCam.blendWeight);
Quaternionrot=Rot.Y(PauseCam.Flip?180:0)*(CurrentPivotRot*RootRot)*lookUp;
camPivot.localRotation=rot;
camPivot.localPosition=(CurrentPivotPos+CurrentPivotRot*V3.forward*CurrentDolly).MultiXZ(PauseCam.Flip?-1:1);
transform.position=CurrentPos;
CurrentSide=camPivot.position.z<0?Side.Front:Side.Back;
multiCam.CamUpdate(rot);
publicconstfloatMaxDot=.9f;//1.15f;
publicstaticfloatRotZ(Quaternionrot)
floatdot=Vector3.Dot(rot*V3.forward,V3.forward);
Vector3flatForward=Vector3.ProjectOnPlane(rot*V3.forward,V3.forward).normalized;
floattiltLerp=Mathf.Abs(Vector3.Dot(V3.up.RotZ(45),flatForward));
returnMathf.Lerp(5f,-5f,tiltLerp)*Mathf.SmoothStep(0,1,(1-Mathf.Abs(dot))/MaxDot)*(dot>0?-1:1);
publicstaticvoidCheckThisOut(Vector3pos,boolfront)
Inst.moveCam.CheckThisOut(pos);
if(front!=CurrentSide.front)
Inst.sideSwitcher.ForcedSideSwitch();
publicclassMoveCam:MonoBehaviour
privateVector2lookAhead,keyMovement;
[HideInInspector]
publicfloatdolly;
[HideInInspector]
publicVector2movePos;
publicfloatoffsetRange=7.8f;
publicVector2offsetMin;
publicstaticVector2pos;
privatestaticboolkeyControll;
publicstaticboolKeyMove{get{returnGameManager.Mode==Mode.Creator||keyControll;}}
publicvoidReset()
lookAhead=V3.zero;
if(!KeyMove||GameManager.Mode==Mode.Creator)
pos=GameCam.StartPos;
if(f.Same(dolly,0))
dolly=GameCam.StartDolly;
currentWarp=MoveWarp.None;
warps.Clear();
publicvoidCamUpdate()
if(!GTime.Paused&&!UI_Manager.HitUI)
dolly=Mathf.Clamp(dolly+Controll.ScrollWheelDelta*5000,GameCam.farZoom,GameCam.closeZoom);
/*if(!Mathf.Approximately(Controll.ScrollWheelDelta,0))
Debug.Log(dolly);*/
if(KeyMap.Down(Key.Dev_CamModeToggle))
keyControll=!keyControll;
if(!KeyMove)
CheckForWarpMove();
Clipclip=Spinner.CurrentFocusClip;
if(clip!=null)
Vector2mV=clip.GetMV(GTime.Now)*GTime.Speed;
lookAhead=Vector2.Lerp(lookAhead,newVector2(mV.x,mV.y*(mV.y>0?.8f:1.13f)),Time.deltaTime*12);
Vector2goalPos=clip.spinner.currentPlacement.pos.V2()+lookAhead;
pos=Vector2.Lerp(pos,goalPos,Time.deltaTime);
else
Vector2currentControll=newVector2(Input.GetAxis("Horizontal")*GameCam.CurrentSide.Map(-1,1),Input.GetAxis("Vertical"));
floataccel=GameManager.Mode==Mode.SpinUp?4:18;
floatspeed=GameManager.Mode==Mode.SpinUp?50:55;
keyMovement=Vector2.Lerp(keyMovement,currentControll,Time.deltaTime*accel);
pos+=keyMovement*Time.deltaTime*speed;
floatmin=ScreenControll.Landscape?offsetMin.x:offsetMin.y;
floatmax=min+offsetRange;
pos=newVector2(pos.x,Mathf.Max(pos.y,min));
movePos=newVector2(pos.x,SineEaseOut(pos.y,max,min));
privatestaticfloatSineEaseOut(floatvalue,floatstart,floatend)
constfloatmulti=Mathf.PI*.5f;
floatrange=end-start;
start=end-range*multi;
floatlerp=(value-start)/(range*multi);
if(lerp<0)
returnvalue;
returnstart+range*multi*Mathf.Sin(Mathf.Clamp(lerp,0,multi));
publicstaticvoidSetWarp(floattime,Vector2start,Vector2end)
MoveWarpwarp=newMoveWarp(time,start,end);
intcount=warps.Count;
for(inti=0;i<count;i++)
if(warps[i]==warp)
return;
warps.Add(warp);
privatestaticvoidCheckForWarpMove()
if(warps.Count==0)
return;
while(true)
if(warps[0].time<GTime.Now-GTime.RewindTime*2)
warps.RemoveAt(0);
if(warps.Count>0)
continue;
currentWarp=MoveWarp.None;
return;
break;
intwarpCount=warps.Count;
MoveWarpnewWarp=GetCurrentWarp;
if(currentWarp!=newWarp)
Vector2warpOffset=Vector2.zero;
intstartIndex=-1;
for(inti=0;i<warpCount;i++)
if(warps[i]==currentWarp)
startIndex=i;
break;
boolnewWarpIsLater=currentWarp.time<newWarp.time;
Vector2checkPos;
if(newWarpIsLater)
for(inti=startIndex+1;i<warpCount;i++)
warpOffset+=warps[i].offset;
if(warps[i]==newWarp)
break;
checkPos=newWarp.end;
else
for(inti=startIndex;i>-1;i--)
if(warps[i]==newWarp)
break;
warpOffset-=warps[i].offset;
checkPos=currentWarp.start;
currentWarp=newWarp;
boolonScreen=GameCam.frustum.InFrustum(newBounds2D(checkPos).Pad(.01f),GameCam.CurrentSide.front);
if(!onScreen)
pos-=warpOffset;
privatestaticMoveWarpGetCurrentWarp
get
intcount=warps.Count;
MoveWarpwarp=MoveWarp.None;
for(inti=0;i<count;i++)
if(warps[i].time<GTime.Now)
warp=warps[i];
else
break;
returnwarp;
privatestaticMoveWarpcurrentWarp;
publicvoidCheckThisOut(Vector3checkPoint)
keyControll=true;
pos=checkPoint;
publicstructMoveWarp
publicreadonlyfloattime;
publicVector2start,end;
publicVector2offset
get{returnstart-end;}
publicMoveWarp(floattime,Vector2start,Vector2end)
this.time=time;
this.start=start;
this.end=end;
publicstaticbooloperator==(MoveWarpa,MoveWarpb)
returnf.Same(a.time,b.time);
publicstaticbooloperator!=(MoveWarpa,MoveWarpb)
return!f.Same(a.time,b.time);
publicstaticMoveWarpNone{get{returnnewMoveWarp(float.MinValue,Vector2.zero,Vector2.zero);}}
privatestaticreadonlyList<MoveWarp>warps=newList<MoveWarp>(100);
publicclassMultiCam:Singleton<MultiCam>
[Switch("Camera/Skew")]privatestaticboolskew=true;
[System.Serializable]
publicclassCam
publicCameracamera;
publicvoidSetFOV(floatfov)
camera.ResetProjectionMatrix();
camera.fieldOfView=fov;
publicvoidNewSkew(Vector2dir,floatcounterMove=0)
floatdir_M=dir.magnitude;
Matrix4x4rotMatrix=Matrix4x4.TRS(V3.zero,Quaternion.FromToRotation(V3.up,dir*(dir_M>0?1f/dir_M:0)),V3.one);
camera.projectionMatrix=Matrix4x4.Inverse(rotMatrix)*(Matrix4x4.Translate(V3.down*dir_M*.5f*counterMove)*(Matrix4x4.Scale(newVector3(1,1+dir_M,1))*(rotMatrix*camera.projectionMatrix)));
publicCammainCam,backCam;
[Space(10)]
publicAnimationCurveshakeTest;
privatestaticVector2bgShake;
privateQuaternioncurrentRot;
privateVector3change;
privatefloatxLerp,yLerp;
privatestaticfloataspectRatio,FOV;
privatestaticfloatGetFOV
get
if(!f.Same(aspectRatio,ScreenControll.Aspect))
aspectRatio=ScreenControll.Aspect;
constfloatportraitFov=17,
portraitAspect=9f/16f,
landscapeAspect=16f/9f,
radAngle=portraitFov*Mathf.Deg2Rad;
floatlerp=Mathf.InverseLerp(portraitAspect,landscapeAspect,aspectRatio);
floatradHFOV=2*Mathf.Atan(Mathf.Tan(radAngle*.5f)*portraitAspect);
FOV=Mathf.Lerp(portraitFov,Mathf.Rad2Deg*radHFOV,lerp);
returnFOV;
privatevoidAwake()
if(!Application.isMobilePlatform)
mainCam.camera.allowMSAA=true;
backCam.camera.allowMSAA=true;
publicvoidCamUpdate(QuaternioncamRot)
floatfov=GetFOV;
mainCam.SetFOV(fov);
backCam.SetFOV(fov);
if(skew)
Vector3oldForward=currentRot*V3.forward;
currentRot=camRot;
Vector3newForward=currentRot*V3.forward;
boolsideChange=!f.Same(Mathf.Sign(oldForward.z),Mathf.Sign(newForward.z));
change=sideChange?newVector3(0,change.magnitude,0):Quaternion.FromToRotation(oldForward,newForward).eulerAngles;
xLerp=Mathf.Lerp(xLerp,change.x.Euler180()*.12f,Time.deltaTime*50);
yLerp=Mathf.Lerp(yLerp,change.y.Euler180()*.12f,Time.deltaTime*50);
mainCam.NewSkew(newVector2(yLerp,xLerp)*.2f,.5f);
backCam.NewSkew(newVector2(yLerp,xLerp),.1f);
boolfront=GameCam.CurrentSide.front;
intcullingMask=mainCam.camera.cullingMask;
cullingMask|=front?Layers.MainA_bit:Layers.MainB_bit;
cullingMask&=~(front?Layers.MainB_bit:Layers.MainA_bit);
mainCam.camera.cullingMask=cullingMask;
backCam.camera.cullingMask=front?Layers.BackB_bit:Layers.BackA_bit;
publicstaticvoidShake(floatforce)
Inst.StartCoroutine(Inst.ShakeBack(force));
privateIEnumeratorShakeBack(floatforce)
floatcount=0;
Vector2backDir=V2.up.RotRad(Random.Range(0,Mth.FullRad));
while(count<1)
count+=Time.deltaTime*3;
bgShake=backDir*shakeTest.Evaluate(count)*(1+force*.1f);
yieldreturnnull;
publicclassPauseCam:MonoBehaviour
publicboolpauseSideFront;
privateboolswiping,zooming;
privatefloatdollyGoal,zoomLength;
publicfloatdolly,blendWeight;
publicstaticboolFlip;
publicVector2camPos;
publicQuaternioncamRot,pivotRot;
privatefloatDollyLerp{get{returnMathf.InverseLerp(-120,-55,dolly);}}
privatevoidOnEnable()
GTime.onPaused+=onPaused;
Controll.onZoom+=onZoom;
privatevoidOnDisable()
GTime.onPaused-=onPaused;
Controll.onZoom-=onZoom;
privatevoidonZoom(boolstart)
if(start)
if(!zooming&&GTime.Paused)
zooming=true;
zoomLength=Controll.ZoomLength;
else
zooming=false;
privatevoidonPaused(boolpaused)
if(paused)
camRot=GameCam.RootRot;
pivotRot=GameCam.CurrentPivotRot;
dolly=dollyGoal=GameCam.CurrentDolly;
pauseSideFront=GameCam.CurrentSide.front;
StartCoroutine(ToPause());
else
StartCoroutine(BackToGame());
privateIEnumeratorToPause()
floatlerp=0;
floatstartblend=blendWeight;
while(lerp<1&&GTime.Paused)
lerp+=Time.deltaTime*2.25f;
blendWeight=Mathf.Lerp(startblend,1,Curves.CameraBounce.Evaluate(lerp));
yieldreturnnull;
privateIEnumeratorBackToGame()
floatlerp=0;
floatstartblend=blendWeight;
while(lerp<1&&!GTime.Paused)
lerp+=Time.deltaTime*2.25f;
blendWeight=Mathf.Lerp(startblend,0,Curves.CameraBounce.Evaluate(lerp));
yieldreturnnull;
publicvoidCamUpdate(Vector2movePos)
Flip=GTime.Paused&&Spinner.CurrentFocusClip.GetSide(GTime.Now).front!=pauseSideFront;
if(!GTime.Paused)
return;
Vector2charPos=Spinner.CurrentFocusClip.BasicPlacement(GTime.Now,true).pos;
if(!Flip)
if(!Application.isMobilePlatform)
dollyGoal=Mathf.Clamp(dollyGoal+Controll.ScrollWheelDelta*5000,GameCam.gameZoom,GameCam.closeZoom);
if(zooming)
dollyGoal=Mathf.Clamp(dollyGoal+(Controll.ZoomLength-zoomLength)*4,GameCam.gameZoom,GameCam.closeZoom);
zoomLength=Controll.ZoomLength;
dolly=Mathf.Lerp(dolly,dollyGoal,Time.deltaTime*12);
camPos=MoveCam.KeyMove?MoveCam.pos:Vector2.Lerp(movePos,charPos,DollyLerp);
publicclassSideSwitcher:MonoBehaviour
privateconstfloatxAngle=-22,yAngle=44;
privatestaticreadonlyQuaternionfrontRot=Quaternion.Euler(xAngle,-yAngle,0),
backRot=Quaternion.Euler(xAngle,180+yAngle,0);
privatestaticreadonlyfloatfrontTilt=GameCam.RotZ(frontRot),
backTilt=GameCam.RotZ(backRot);
privateSidecurrentSide,forcedSide,clipSide;
privateSideSwaysideSwitch;
publicfloatsideLerp;
publicQuaternioncamRot,pivotRot;
privateboolforceUpdate;
publicboolanimating;
publicvoidReset()
currentSide=clipSide=forcedSide=GameCam.StartSide;
sideSwitch=newSideSway(currentSide,true);
forceUpdate=true;
CamUpdate();
publicvoidCamUpdate()
Profiler.BeginSample("SideSwitcher.UpdateAngle()");
Clipclip=Spinner.CurrentFocusClip;
if(clip!=null)
SidenewClipSide=clip.GetSide(GTime.Now);
if(clip.Type!=0&&clipSide!=newClipSide)
clipSide=forcedSide=newClipSide;
if(!GTime.Paused&&KeyMap.Down(Key.Dev_SideSwitch))
ForcedSideSwitch();
if(currentSide!=forcedSide)
sideSwitch=newSideSway(forcedSide);
currentSide=forcedSide;
animating=true;
floatlerp=sideSwitch.GetLerp();
boolfront=f.Same(Mathf.Round(lerp),0);
constfloatmax=1.2f,pow=2.65f;
sideLerp=front?max*Mathf.Pow(lerp,pow):
1-max*Mathf.Pow(1-lerp,pow);
if(animating&&(lerp>=1||lerp<=0))
animating=false;
if(animating||forceUpdate)
pivotRot=Quaternion.Slerp(frontRot,backRot,sideLerp);
camRot=Quaternion.Euler(0,0,Mathf.Lerp(frontTilt,backTilt,sideLerp));
animating=true;
forceUpdate=false;
Profiler.EndSample();
publicvoidForcedSideSwitch()
forcedSide=!forcedSide;
privatestructSideSway
privatereadonlyfloatstart,end;
privatefloattime;
publicSideSway(SidegoalSide,boolstayOnSide=false)
start=stayOnSide?goalSide.Map(1,0):goalSide.Map(0,1);
end=goalSide.Map(1,0);
time=0;
publicfloatGetLerp()
time+=Time.deltaTime*GTime.Speed;
returnMathf.Lerp(start,end,time*3.25f);
publicclassSkyUpdate:Singleton<SkyUpdate>
[Header("ZSizeBefore:200")]
publicVector3size;
publicfloatzOffset;
privatestaticboolfront;
privatestaticreadonlyintSkyCenter=Shader.PropertyToID("SkyCenter");
privatestaticreadonlyintSkySize=Shader.PropertyToID("SkySize");
privatevoidLateUpdate()
Shader.SetGlobalVector(SkyCenter,GameCam.CurrentPos.V3(GameCam.CurrentSide.Sign*zOffset));
Shader.SetGlobalVector(SkySize,size);
publicclassWireframe:MonoBehaviour
[Switch("Visuals/Wireframe")]privatestaticboolactive=false;
publicstaticboolActive
get{returnactive&&!Application.isMobilePlatform;}
privatevoidOnPreRender()
GL.wireframe=Active;
privatevoidOnPostRender()
GL.wireframe=false;
[ExecuteInEditMode]
publicclassFilterTest:MonoBehaviour
publicenumDownSampleMode{Off,Half,Quarter}
publicShader_shader;
publicDownSampleMode_downSampleMode=DownSampleMode.Quarter;
[Range(0,8)]
publicint_iteration=4;
publicMaterial_material;
voidOnRenderImage(RenderTexturesource,RenderTexturedestination)
if(_material==null)
_material=newMaterial(_shader);
_material.hideFlags=HideFlags.HideAndDontSave;
RenderTexturert1,rt2;
if(_downSampleMode==DownSampleMode.Half)
rt1=RenderTexture.GetTemporary(source.width/2,source.height/2);
rt2=RenderTexture.GetTemporary(source.width/2,source.height/2);
Graphics.Blit(source,rt1);
elseif(_downSampleMode==DownSampleMode.Quarter)
rt1=RenderTexture.GetTemporary(source.width/4,source.height/4);
rt2=RenderTexture.GetTemporary(source.width/4,source.height/4);
Graphics.Blit(source,rt1,_material,0);
else
rt1=RenderTexture.GetTemporary(source.width,source.height);
rt2=RenderTexture.GetTemporary(source.width,source.height);
Graphics.Blit(source,rt1);
for(vari=0;i<_iteration;i++)
Graphics.Blit(rt1,rt2,_material,1);
Graphics.Blit(rt2,rt1,_material,2);
Graphics.Blit(rt1,destination);
RenderTexture.ReleaseTemporary(rt1);
RenderTexture.ReleaseTemporary(rt2);
namespaceClips
publicenumClipType
Jump=1,
Swing=2,
Bump=3,
AirLaunch=4,
Dead=5,
Spawn=6,
SlipOff=7
publicstaticclassClipTypeFilter
publicstaticboolIsNotPlaying(thisClipTypeclipType)
switch(clipType)
case0:
caseClipType.Dead:returntrue;
returnfalse;
publicstaticboolIsSerializable(thisClipTypeclipType)
switch(clipType)
caseClipType.Jump:
caseClipType.AirLaunch:
caseClipType.Dead:
caseClipType.Spawn:returntrue;
returnfalse;
publicstaticboolIsAnyJump(thisClipTypeclipType)
switch(clipType)
caseClipType.Jump:
caseClipType.AirLaunch:
caseClipType.SlipOff:returntrue;
returnfalse;
publicstaticboolIsAnySwing(thisClipTypeclipType)
switch(clipType)
caseClipType.Swing:
caseClipType.Spawn:returntrue;
returnfalse;
/*publicstaticclassElementInfo
privateconstinfoStick=info.IsItem|info.Shake|info.Grab|info.Button;
privateconstinfoWarpStickA=info.IsItem|info.Shake|info.Grab|info.Button;
privateconstinfoWarpStickB=info.IsItem|info.Shake|info.Grab;
privateconstinfoWarpStickC=info.IsItem|info.Shake|info.Grab|info.Button;
privateconstinfoWarpStickD=info.IsItem|info.Shake|info.Grab;
privateconstinfoBouncy=info.IsItem|info.Shake|info.Button|info.Action;
privateconstinfoInOutStick=info.IsItem|info.Shake;
privateconstinfoBranch=info.IsItem|info.Shake|info.Grab|info.Button;
privateconstinfoProbe=info.IsItem|info.Shake|info.Button;
privateconstinfoStick_SmallTip=info.IsItem|info.Shake|info.Grab|info.Button;
privateconstinfoCoin=info.IsCollectable|info.Button;
privateconstinfoDebugCube=info.IsFluff|info.Hide|info.Button;
privateconstinfoFlower=info.IsFluff|info.Shake|info.Hide|info.Button;
privateconstinfoFlower2=info.IsFluff|info.Shake|info.Hide|info.Button;
privateconstinfoFlower3=info.IsFluff|info.Shake|info.Hide|info.Button;
privateconstinfoDebugCube2=info.IsFluff|info.Hide|info.Button;
privateconstinfoTrackGap=info.IsFluff|info.Hide;
privateconstinfoPingPong=info.IsTrack|info.Button;
privateconstinfoCircular=info.IsTrack|info.Button;
privateconstinfoArc=info.IsTrack|info.Button;
publicstaticinfoInfo(thiselementTypeelementType)
switch(elementType)
caseelementType.Stick:returnStick;
caseelementType.WarpStickA:returnWarpStickA;
caseelementType.WarpStickB:returnWarpStickB;
caseelementType.WarpStickC:returnWarpStickC;
caseelementType.WarpStickD:returnWarpStickD;
caseelementType.Bouncy:returnBouncy;
caseelementType.InOutStick:returnInOutStick;
caseelementType.Branch:returnBranch;
caseelementType.Probe:returnProbe;
caseelementType.Stick_SmallTip:returnStick_SmallTip;
caseelementType.Coin:returnCoin;
caseelementType.DebugCube:returnDebugCube;
caseelementType.Flower:returnFlower;
caseelementType.Flower2:returnFlower2;
caseelementType.Flower3:returnFlower3;
caseelementType.DebugCube2:returnDebugCube2;
caseelementType.TrackGap:returnTrackGap;
caseelementType.PingPong:returnPingPong;
caseelementType.Circular:returnCircular;
caseelementType.Arc:returnArc;
return0;
publicstaticboolAnyMatch(thisinfoa,infob)
return(a&b)!=0;
publicstaticboolMatches(thisinfoa,infob)
returnb==(a&b);
publicstaticboolAnyMatch(thiselementTypea,infob)
returna.Info().AnyMatch(b);
publicstaticboolMatches(thiselementTypea,infob)
returna.Info().Matches(b);
publicabstractclassElementMask
publicabstractboolFits(elementTypeelementType);
publicstaticclassMaskTypes
publicclassIsItem_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.InOutStick:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassIsCollectable_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:returntrue;
default:returnfalse;
publicclassIsFluff_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:
caseelementType.TrackGap:returntrue;
default:returnfalse;
publicclassIsTrack_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Arc:
caseelementType.Circular:
caseelementType.PingPong:returntrue;
default:returnfalse;
publicclassCanBeGrabbed_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Branch:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassAnyThing_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.Coin:
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.InOutStick:
caseelementType.Leaf:
caseelementType.LeafBlue:
caseelementType.Pill:
caseelementType.Pill_Green:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.TrackGap:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassDebug_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.InOutStick:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassMustShake_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.Coin:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.InOutStick:
caseelementType.Leaf:
caseelementType.LeafBlue:
caseelementType.Pill:
caseelementType.Pill_Green:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassShakeItem_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.InOutStick:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassShakeFluff_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:returntrue;
default:returnfalse;
publicclassHidingShakeFluff_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:returntrue;
default:returnfalse;
publicclassAction_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Bouncy:returntrue;
default:returnfalse;
publicclassCanMove_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Branch:
caseelementType.Coin:
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:
caseelementType.Pill:
caseelementType.Pill_Green:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.TrackGap:returntrue;
default:returnfalse;
publicclassHide_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.TrackGap:returntrue;
default:returnfalse;
publicclassCreatorButton_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Arc:
caseelementType.Bouncy:
caseelementType.Branch:
caseelementType.Circular:
caseelementType.Coin:
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:
caseelementType.Pill:
caseelementType.Pill_Green:
caseelementType.PingPong:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.WarpStickA:
caseelementType.WarpStickC:returntrue;
default:returnfalse;
publicclassTrackCanGrow_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Arc:returntrue;
default:returnfalse;
publicclassTrackCanTurn_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.Arc:
caseelementType.PingPong:returntrue;
default:returnfalse;
publicclassWarp_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returntrue;
default:returnfalse;
publicclassWarp_Start_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.WarpStickA:
caseelementType.WarpStickC:returntrue;
default:returnfalse;
publicclassWarp_SideSwitch_Mask:ElementMask
publicoverrideboolFits(elementTypeelementType)
switch(elementType)
caseelementType.WarpStickA:
caseelementType.WarpStickB:returntrue;
default:returnfalse;
publicstaticclassMask
publicstaticreadonlyMaskTypes.IsItem_MaskIsItem=newMaskTypes.IsItem_Mask();
publicstaticreadonlyMaskTypes.IsCollectable_MaskIsCollectable=newMaskTypes.IsCollectable_Mask();
publicstaticreadonlyMaskTypes.IsFluff_MaskIsFluff=newMaskTypes.IsFluff_Mask();
publicstaticreadonlyMaskTypes.IsTrack_MaskIsTrack=newMaskTypes.IsTrack_Mask();
publicstaticreadonlyMaskTypes.CanBeGrabbed_MaskCanBeGrabbed=newMaskTypes.CanBeGrabbed_Mask();
publicstaticreadonlyMaskTypes.AnyThing_MaskAnyThing=newMaskTypes.AnyThing_Mask();
publicstaticreadonlyMaskTypes.MustShake_MaskMustShake=newMaskTypes.MustShake_Mask();
publicstaticreadonlyMaskTypes.ShakeItem_MaskShakeItem=newMaskTypes.ShakeItem_Mask();
publicstaticreadonlyMaskTypes.ShakeFluff_MaskShakeFluff=newMaskTypes.ShakeFluff_Mask();
publicstaticreadonlyMaskTypes.HidingShakeFluff_MaskHidingShakeFluff=newMaskTypes.HidingShakeFluff_Mask();
publicstaticreadonlyMaskTypes.Action_MaskAction=newMaskTypes.Action_Mask();
publicstaticreadonlyMaskTypes.CanMove_MaskCanMove=newMaskTypes.CanMove_Mask();
publicstaticreadonlyMaskTypes.Hide_MaskHide=newMaskTypes.Hide_Mask();
publicstaticreadonlyMaskTypes.CreatorButton_MaskCreatorButton=newMaskTypes.CreatorButton_Mask();
publicstaticreadonlyMaskTypes.TrackCanGrow_MaskTrackCanGrow=newMaskTypes.TrackCanGrow_Mask();
publicstaticreadonlyMaskTypes.TrackCanTurn_MaskTrackCanTurn=newMaskTypes.TrackCanTurn_Mask();
publicstaticreadonlyMaskTypes.Warp_MaskWarp=newMaskTypes.Warp_Mask();
publicstaticreadonlyMaskTypes.Warp_Start_MaskWarp_Start=newMaskTypes.Warp_Start_Mask();
publicstaticreadonlyMaskTypes.Warp_SideSwitch_MaskWarp_SideSwitch=newMaskTypes.Warp_SideSwitch_Mask();
publicstaticreadonlyMaskTypes.Debug_MaskDebug=newMaskTypes.Debug_Mask();
namespaceLevelElements
publicenumelementType
Stick=1,
WarpStickA=2,
WarpStickB=3,
WarpStickC=4,
WarpStickD=5,
Bouncy=6,
InOutStick=7,
Branch=8,
Probe=9,
Probe_Orange=11,
Stick_SmallTip=10,
Coin=3000000,
Pill=3000001,
Pill_Green=3000002,
DebugCube=2000000,
Flower=2000001,
Flower2=2000002,
Flower3=2000003,
Leaf=2000006,
LeafBlue=2000007,
DebugCube2=2000004,
TrackGap=2000005,
PingPong=1000000,
Circular=1000001,
Arc=1000002
publicstaticclassElementTypeExt
publicstaticintInstanceCount(thiselementTypevalue)
switch(value)
caseelementType.Stick:
caseelementType.Bouncy:
caseelementType.Stick_SmallTip:return50;
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:
caseelementType.Branch:
caseelementType.Probe:
caseelementType.Probe_Orange:
caseelementType.Flower3:
caseelementType.DebugCube2:return20;
caseelementType.Coin:return400;
caseelementType.Pill:
caseelementType.Pill_Green:return200;
caseelementType.DebugCube:
caseelementType.Flower:
caseelementType.Leaf:
caseelementType.LeafBlue:return40;
caseelementType.Flower2:return30;
return0;
publicstaticfloatMass(thiselementTypevalue)
switch(value)
caseelementType.Bouncy:return2;
caseelementType.Branch:return.75f;
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:return.25f;
caseelementType.Flower:
caseelementType.Flower3:
caseelementType.Leaf:return.2f;
caseelementType.Flower2:return.22f;
caseelementType.LeafBlue:return.18f;
return1;
publicstaticfloatDamp(thiselementTypevalue)
switch(value)
caseelementType.Stick:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:
caseelementType.Stick_SmallTip:return15;
caseelementType.Bouncy:return14;
caseelementType.Branch:
caseelementType.Leaf:return8;
caseelementType.Probe:return5;
caseelementType.Probe_Orange:return4;
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:return275;
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:return10;
caseelementType.LeafBlue:return7;
return1;
publicstaticfloatAccel(thiselementTypevalue)
switch(value)
caseelementType.Stick:
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:
caseelementType.Stick_SmallTip:return.05f;
caseelementType.Bouncy:
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:return.3f;
caseelementType.Branch:return-0.05f;
caseelementType.Probe:return-0.15f;
caseelementType.Probe_Orange:return-0.17f;
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:return-0.2f;
return1;
publicstaticfloatLazyness(thiselementTypevalue)
switch(value)
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:
caseelementType.Flower:
caseelementType.Flower2:return.175f;
caseelementType.Flower3:
caseelementType.Leaf:
caseelementType.LeafBlue:return.195f;
return1;
publicstaticfloatRadius(thiselementTypevalue)
switch(value)
caseelementType.Bouncy:
caseelementType.Probe:
caseelementType.Probe_Orange:return1;
caseelementType.Branch:return.17f;
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:return1.25f;
caseelementType.DebugCube:
caseelementType.DebugCube2:return.5f;
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:return.7f;
caseelementType.Leaf:
caseelementType.LeafBlue:return.8f;
return.075f;
publicstaticintValue(thiselementTypevalue)
switch(value)
caseelementType.Coin:return100;
caseelementType.Pill:return200;
caseelementType.Pill_Green:return500;
return0;
publicstaticelementTypeGetOtherEnd(thiselementTypevalue)
switch(value)
caseelementType.WarpStickA:returnelementType.WarpStickB;
caseelementType.WarpStickB:returnelementType.WarpStickA;
caseelementType.WarpStickC:returnelementType.WarpStickD;
caseelementType.WarpStickD:returnelementType.WarpStickC;
returnvalue;
publicstaticintMaxItems(thiselementTypevalue)
switch(value)
caseelementType.Circular:return20;
return1;
publicstaticfloatDefaultVScale(thiselementTypevalue)
switch(value)
caseelementType.PingPong:return10;
caseelementType.Circular:
caseelementType.Arc:return5;
return0;
publicstaticColorDebugColor(thiselementTypevalue)
switch(value)
caseelementType.WarpStickA:
caseelementType.WarpStickB:
caseelementType.WarpStickC:
caseelementType.WarpStickD:returnCOLOR.green.lime;
caseelementType.Bouncy:
caseelementType.Circular:returnCOLOR.red.tomato;
caseelementType.PingPong:returnCOLOR.yellow.fresh;
returnCOLOR.blue.cornflower;
publicconstintLongestItemName=14;
publicconstintLongestCollectableName=10;
publicconstintLongestFluffName=10;
publicconstintLongestTrackName=8;
publicstaticstringName(thiselementTypevalue)
switch(value)
caseelementType.Stick:return"Stick";
caseelementType.WarpStickA:return"WarpStickA";
caseelementType.WarpStickB:return"WarpStickB";
caseelementType.WarpStickC:return"WarpStickC";
caseelementType.WarpStickD:return"WarpStickD";
caseelementType.Bouncy:return"Bouncy";
caseelementType.InOutStick:return"InOutStick";
caseelementType.Branch:return"Branch";
caseelementType.Probe:return"Probe";
caseelementType.Probe_Orange:return"Probe_Orange";
caseelementType.Stick_SmallTip:return"Stick_SmallTip";
caseelementType.Coin:return"Coin";
caseelementType.Pill:return"Pill";
caseelementType.Pill_Green:return"Pill_Green";
caseelementType.DebugCube:return"DebugCube";
caseelementType.Flower:return"Flower";
caseelementType.Flower2:return"Flower2";
caseelementType.Flower3:return"Flower3";
caseelementType.Leaf:return"Leaf";
caseelementType.LeafBlue:return"LeafBlue";
caseelementType.DebugCube2:return"DebugCube2";
caseelementType.TrackGap:return"TrackGap";
caseelementType.PingPong:return"PingPong";
caseelementType.Circular:return"Circular";
caseelementType.Arc:return"Arc";
return"???";
publicstructelementTypeComparer:IEqualityComparer<elementType>
publicboolEquals(elementTypex,elementTypey)
returnx==y;
publicintGetHashCode(elementTypeobj)
return(int)obj;
publicclassGroup
privatereadonlyelementType[]elements;
privatereadonlyDictionary<elementType,int>pos=newDictionary<elementType,int>(newelementTypeComparer());
publicreadonlyintLength;
publicGroup(elementType[]elements)
this.elements=elements;
Length=elements.Length;
for(inti=0;i<Length;i++)
pos.Add(elements[i],i);
publicelementTypeNext(elementTypevalue){returnGet((Pos(value)+1).Repeat(Length));}
publicelementTypePrev(elementTypevalue){returnGet((Pos(value)-1).Repeat(Length));}
publicelementTypeGetRandom{get{returnelements[Random.Range(0,Length)];}}
publicelementTypeGet(intindex)
returnelements[index];
privateintPos(elementTypevalue)
returnpos[value];
publicboolContains(elementTypevalue)
returnpos.ContainsKey(value);
publicstaticclassAliasTest
publicstaticVector2Anim(thiselementTypeelementType,floattime,intID,Vector2pos)
switch(elementType)
default:
returnpos;
caseelementType.Probe:
returnnewVector2(pos.x,Mth.SmoothPP(-.5f,.5f,(time+ID*.115f)/GTime.LoopTime*8)+pos.y);
caseelementType.Probe_Orange:
returnnewVector2(pos.x,Mth.SmoothPP(-.5f,.5f,(time+ID*.115f)/GTime.LoopTime*9)+pos.y);
caseelementType.Coin:
Vector2rot=Rot.Z((time+ID*12.13f)*360*4/GTime.LoopTime)*newVector2(0,.1f);
returnnewVector2(pos.x+rot.x,pos.y+rot.y);
publicstaticclassGroups
staticGroups()
Stick=newGroup(new[]{elementType.Stick,
elementType.Stick_SmallTip});
Probes=newGroup(new[]{elementType.Probe,
elementType.Probe_Orange});
Pills=newGroup(new[]{elementType.Coin,
elementType.Pill,
elementType.Pill_Green});
DebugCube=newGroup(new[]{elementType.DebugCube,
elementType.DebugCube2});
Flower=newGroup(new[]{elementType.Flower,
elementType.Flower2,
elementType.Flower3});
Leaves=newGroup(new[]{elementType.Leaf,
elementType.LeafBlue});
All=new[]{Stick,Probes,Pills,DebugCube,Flower,Leaves};
privatestaticreadonlyGroupStick,Probes,Pills,DebugCube,Flower,Leaves;
publicstaticreadonlyGroup[]All;
publicstaticGroupAlias(thiselementTypeelementType)
switch(elementType)
default:returnnull;
caseelementType.Stick:
caseelementType.Stick_SmallTip:returnStick;
caseelementType.Probe:
caseelementType.Probe_Orange:returnProbes;
caseelementType.Coin:
caseelementType.Pill:
caseelementType.Pill_Green:returnPills;
caseelementType.DebugCube:
caseelementType.DebugCube2:returnDebugCube;
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:returnFlower;
caseelementType.Leaf:
caseelementType.LeafBlue:returnLeaves;
/*[Flags]
publicenuminfo
IsItem=1<<0,
IsTrack=1<<1,
IsFluff=1<<2,
IsCollectable=1<<3,
Shake=1<<4,
Grab=1<<5,
Hide=1<<7,
Button=1<<13,
Action=1<<14
publicstructFilter
privatereadonlyinfoanyMatch,mustMatch;
privateFilter(infoanyMatch,infomustMatch)
this.anyMatch=anyMatch;
this.mustMatch=mustMatch;
publicboolMatches(elementTypeelementType)
return(anyMatch==0||elementType.AnyMatch(anyMatch))&&
(mustMatch==0||elementType.Matches(mustMatch));
publicboolMatches(infoinfo)
return(anyMatch==0||info.AnyMatch(anyMatch))&&
(mustMatch==0||info.Matches(mustMatch));
publicstaticbooloperator==(Filtera,Filterb)
returna.anyMatch==b.anyMatch&&a.mustMatch==b.mustMatch;
publicstaticbooloperator!=(Filtera,Filterb)
return!(a==b);
publicstaticFilterIsItem,IsTrack,IsFluff,IsCollectable,CanBeGrabbed,AnyThing,MustShake,
ShakeItems,ShakeFluff,None,Action;
staticFilter()
IsItem=newFilter(0,info.IsItem);
IsTrack=newFilter(0,info.IsTrack);
IsFluff=newFilter(0,info.IsFluff);
IsCollectable=newFilter(0,info.IsCollectable);
CanBeGrabbed=newFilter(0,info.Grab);
AnyThing=newFilter(info.IsItem|info.IsFluff|info.IsCollectable,0);
MustShake=newFilter(0,info.Shake);
ShakeItems=newFilter(0,info.IsItem|info.Shake);
ShakeFluff=newFilter(0,info.IsFluff|info.Shake);
None=newFilter(0,0);
Action=newFilter(0,info.Action);
publicoverridestringToString()
return"Any:"+anyMatch+"-Must:"+mustMatch;
publicstaticclassParseClipJSON
publicstaticJSONNodeGetJSON()
stringfileText=File.ReadAllText("Assets/00_Scripts/CodeGen/clips.json");
returnJSON.Parse(fileText);
publicstaticJSONNode[]JSON_Nodes()
JSONNodenode=GetJSON();
List<JSONNode>list=newList<JSONNode>();
for(inti=0;i<node.Count;i++)
foreach(JSONNodeiteminnode[i].Children)
list.Add(item);
returnlist.ToArray();
privateconststringcsPath="Assets/00_Scripts/CodeGen/clipType.cs";
privateconststringeName="ClipType",vName="clipType";
[MenuItem("CodeGen/clipType")]
publicstaticvoidReloadClipDefinition()
JSONNode[]nodes=JSON_Nodes();
newStreamWriter(csPath))
outfile.WriteLine("namespaceClips");
outfile.WriteLine("{");
outfile.CreateEnum(1,nodes);
outfile.Space(2);
outfile.WriteLine(T(1)+"publicstaticclassClipTypeFilter");
outfile.WriteLine(T(1)+"{");
outfile.CreateBoolMethod("IsNotPlaying","NotPlaying",2,nodes,true);
outfile.Space(2);
outfile.CreateBoolMethod("IsSerializable","Serializable",2,nodes);
outfile.Space(2);
outfile.CreateBoolMethod("IsAnyJump","IsJump",2,nodes);
outfile.Space(2);
outfile.CreateBoolMethod("IsAnySwing","IsSwing",2,nodes);
outfile.WriteLine(T(1)+"}");
outfile.WriteLine("}");
AssetDatabase.Refresh();
privatestaticstringGetBuff(thisstringcompareString,intmax)
intlength=max-compareString.Length;
stringbuffer="";
for(inti=0;i<length;i++)
buffer+="";
returnbuffer;
privatestaticstringT(inttabs)
conststringgap="";
stringtabSpace="";
for(inti=0;i<tabs;i++)
tabSpace+=gap;
returntabSpace;
privatestaticvoidCreateEnum(thisStreamWriteroutfile,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicenum"+eName);
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
for(inti=0;i<nodes.Length;i++)
items.Add(nodes[i]["name"]);
intlongest=items.MaxStringLength();
for(inti=0;i<nodes.Length;i++)
stringcomma=i<nodes.Length-1?",":"";
outfile.WriteLine(T(tabs+1)+items[i].PadRight(longest)+"="+(i+1)+comma);
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateBoolMethod(thisStreamWriteroutfile,stringname,stringkey,inttabs,JSONNode[]nodes,boolincludeZero=false)
outfile.WriteLine(T(tabs)+"publicstaticbool"+name+"(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains(key))
items.Add(nodes[i]["name"]);
break;
if(items.Count>0||includeZero)
intlongest=items.MaxStringLength();
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
if(includeZero)
stringresult=items.Count>0?":":":"+"".GetBuff(longest)+"returntrue;";
outfile.WriteLine(T(tabs+2)+"case0"+result);
for(inti=0;i<items.Count;i++)
stringresult=i<items.Count-1?":":":"+items[i].GetBuff(longest)+"returntrue;";
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+items[i]+result);
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"returnfalse;");
outfile.WriteLine(T(tabs)+"}");
publicstaticclassParseElementJSON
[MenuItem("CodeGen/elementType")]
publicstaticvoidParse()
ElementAttributes();
Masks();
ParseGroupJSON.ParseGroups();
privatestaticJSONNodeGetJSON()
stringfileText=File.ReadAllText("Assets/00_Scripts/CodeGen/elements.json");
returnJSON.Parse(fileText);
publicstaticJSONNode[]JSON_Nodes()
JSONNodenode=GetJSON();
List<JSONNode>list=newList<JSONNode>();
for(inti=0;i<node.Count;i++)
foreach(JSONNodeiteminnode[i].Children)
list.Add(item);
returnlist.ToArray();
privatestaticvoidElementAttributes()
JSONNode[]nodes=JSON_Nodes();
conststringcsPath="Assets/00_Scripts/CodeGen/elementType.cs";
newStreamWriter(csPath))
outfile.WriteLine("usingUnityEngine;");
outfile.Space(1);
outfile.WriteLine("namespaceLevelElements");
outfile.WriteLine("{");
outfile.CreateEnum(1,nodes);
outfile.Space(2);
outfile.WriteLine(T(1)+"publicstaticclassElementTypeExt");
outfile.WriteLine(T(1)+"{");
outfile.CreateIntMethod("InstanceCount","inst",0,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("Mass","mass",1,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("Damp","damp",1,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("Accel","accel",1,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("Lazyness","lazy",1,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("Radius","radius",Item.DefaultRadius,2,nodes);
outfile.Space(2);
outfile.CreateIntMethod("Value","value",0,2,nodes);
outfile.Space(2);
outfile.CreateWarpPairMethod("Warp_Start",2,nodes);
outfile.Space(2);
outfile.CreateIntMethod("MaxItems","max",1,2,nodes);
outfile.Space(2);
outfile.CreateFloatMethod("DefaultVScale","vector",0,2,nodes);
outfile.Space(2);
outfile.CreateDebugColorMethod(2,nodes);
outfile.Space(2);
outfile.CreateCategoryNameLengthMethod(2,nodes);
outfile.Space(2);
outfile.CreateNameMethod(2,nodes);
outfile.Space(2);
outfile.WriteLine(T(1)+"}");
outfile.WriteLine("}");
AssetDatabase.Refresh();
privatestaticstringT(inttabs)
conststringgap="";
stringtabSpace="";
for(inti=0;i<tabs;i++)
tabSpace+=gap;
returntabSpace;
privatestaticstringGetBuff(thisstringcompareString,intmax)
intlength=max-compareString.Length;
stringbuffer="";
for(inti=0;i<length;i++)
buffer+="";
returnbuffer;
privateconststringeName="elementType",vName="value";
privatestaticvoidCreateEnum(thisStreamWriteroutfile,inttabs,JSONNode[]nodes)
conststringelementIDPath="00_Scripts/CodeGen/Editor/elementIDs";
List<string>idLines=ProjectTxt.Read(elementIDPath).ToList();
outfile.WriteLine(T(tabs)+"publicenum"+eName);
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
for(inti=0;i<nodes.Length;i++)
items.Add(nodes[i]["name"]);
for(inti=0;i<idLines.Count;i++)
stringname=idLines[i].Split('|')[0];
for(inte=0;e<items.Count;e++)
if(name==items[e])
gotoItsFine;
idLines.RemoveAt(i);
i--;
Debug.Log("Removingidline"+name);
ItsFine:;
Dictionary<string,int>groupOffsets=newDictionary<string,int>()
stringgroupName="";
intoffset=0;
intlongest=items.MaxStringLength();
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains("!"))
if(groupName!="")
outfile.Space(2);
groupName=info.Value.Replace("!","");
offset=groupOffsets[groupName];
outfile.WriteLine(T(tabs)+"//"+groupName+"//");
break;
intbestID=-1;
stringname=items[i];
for(inte=0;e<idLines.Count;e++)
stringline=idLines[e];
if(line.Split('|')[0]==name)
bestID=int.Parse(line.Split('|')[1]);
break;
if(bestID==-1)
bestID=Mathf.Max(1,offset);
while(true)
for(inte=0;e<idLines.Count;e++)
intid=int.Parse(idLines[e].Split('|')[1]);
if(id==bestID)
bestID++;
gotoTryAgain;
idLines.Add(name+"|"+bestID);
break;
TryAgain:;
stringcomma=i<nodes.Length-1?",":"";
outfile.WriteLine(T(tabs+1)+name.PadRight(longest)+"="+bestID+comma);
ProjectTxt.Write(elementIDPath,idLines.ToArray());
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateIntMethod(thisStreamWriteroutfile,stringname,stringkey,intdefaultValue,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicstaticint"+name+"(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
List<string>ints=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodevalueNode=nodes[i][key];
if(valueNode!=null)
items.Add(nodes[i]["name"]);
ints.Add(valueNode.Value);
if(items.Count>0)
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
intlongest=items.MaxStringLength();
while(items.Count!=0)
stringr=ints[0];
intcount=0;
for(inti=0;i<ints.Count;i++)
if(ints[i]==r)
count++;
for(inti=0;i<count;i++)
for(inte=0;e<ints.Count;e++)
if(ints[e]==r)
boolshowResult=i==count-1;
stringresult=showResult?items[e].GetBuff(longest)+"return"+r+";":"";
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+items[e]+":"+result);
items.RemoveAt(e);
ints.RemoveAt(e);
break;
if(items.Count!=0)
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"return"+defaultValue+";");
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateFloatMethod(thisStreamWriteroutfile,stringname,stringkey,floatdefaultValue,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicstaticfloat"+name+"(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
List<string>floats=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodevalueNode=nodes[i][key];
if(valueNode!=null)
items.Add(nodes[i]["name"]);
floats.Add(valueNode.Value);
if(items.Count>0)
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
intlongest=items.MaxStringLength();
while(items.Count!=0)
stringr=floats[0];
intcount=0;
for(inti=0;i<floats.Count;i++)
if(floats[i]==r)
count++;
for(inti=0;i<count;i++)
for(inte=0;e<floats.Count;e++)
if(floats[e]==r)
boolshowResult=i==count-1;
stringresult=showResult?items[e].GetBuff(longest)+"return"+FloatString(r)+";":"";
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+items[e]+":"+result);
items.RemoveAt(e);
floats.RemoveAt(e);
break;
if(items.Count!=0)
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"return"+FloatString(defaultValue.ToString())+";");
outfile.WriteLine(T(tabs)+"}");
privatestaticstringFloatString(stringvalue)
if(value.Length>1&&value[0]=='0')
value=value.Remove(0,1);
if(value.Contains("."))
returnvalue+"f";
returnvalue;
privatestaticvoidCreateNameMethod(thisStreamWriteroutfile,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicstaticstringName(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
for(inti=0;i<nodes.Length;i++)
items.Add(nodes[i]["name"]);
if(items.Count>0)
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
intlongest=items.MaxStringLength();
for(inti=0;i<items.Count;i++)
stringresult=items[i].GetBuff(longest)+"return\""+items[i]+"\";";
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+items[i]+":"+result);
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"return\"???\";");
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateWarpPairMethod(thisStreamWriteroutfile,stringkey,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicstatic"+eName+"GetOtherEnd(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
foreach(JSONNodeinfoininfos.Children)
if(info.Value==key)
items.Add(nodes[i]["name"]);
items.Add(nodes[i+1]["name"]);
i++;
break;
if(items.Count>0)
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
intlongest=items.MaxStringLength();
for(inti=0;i<items.Count;i+=2)
stringa=items[i];
stringb=items[i+1];
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+a+":"+a.GetBuff(longest)+"return"+eName+"."+b+";");
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+b+":"+b.GetBuff(longest)+"return"+eName+"."+a+";");
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"return"+vName+";");
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateDebugColorMethod(thisStreamWriteroutfile,inttabs,JSONNode[]nodes)
outfile.WriteLine(T(tabs)+"publicstaticColorDebugColor(this"+eName+""+vName+")");
outfile.WriteLine(T(tabs)+"{");
List<string>items=newList<string>();
List<string>colors=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodevalueNode=nodes[i]["debug"];
if(valueNode!=null)
items.Add(nodes[i]["name"]);
colors.Add(valueNode.Value);
if(items.Count>0)
outfile.WriteLine(T(tabs+1)+"switch("+vName+")");
outfile.WriteLine(T(tabs+1)+"{");
intlongest=items.MaxStringLength();
while(items.Count!=0)
stringr=colors[0];
intcount=0;
for(inti=0;i<colors.Count;i++)
if(colors[i]==r)
count++;
for(inti=0;i<count;i++)
for(inte=0;e<colors.Count;e++)
if(colors[e]==r)
boolshowResult=i==count-1;
stringresult=showResult?items[e].GetBuff(longest)+"returnCOLOR."+r+";":"";
outfile.WriteLine(T(tabs+2)+"case"+eName+"."+items[e]+":"+result);
items.RemoveAt(e);
colors.RemoveAt(e);
break;
if(items.Count!=0)
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"}");
outfile.Space(1);
outfile.WriteLine(T(tabs+1)+"returnCOLOR.blue.cornflower;");
outfile.WriteLine(T(tabs)+"}");
privatestaticvoidCreateCategoryNameLengthMethod(thisStreamWriteroutfile,inttabs,JSONNode[]nodes)
intlongestG=0;
List<string>gNames=newList<string>();
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains("!"))
stringgN=info.Value.Replace("!","");
gNames.Add(gN);
longestG=Mathf.Max(longestG,gN.Length);
break;
for(intg=0;g<gNames.Count;g++)
intlongest=0;
boolcount=false;
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains("!"))
count=info.Value.Contains(gNames[g]);
break;
if(count)
longest=Mathf.Max(longest,nodes[i]["name"].ToString().Length-2);
stringname=("Longest"+gNames[g]+"Name").PadRight(longestG+11);
outfile.WriteLine(T(tabs)+"publicconstint"+name+"="+longest+";");
privatestaticvoidMasks()
JSONNode[]nodes=JSON_Nodes();
newStreamWriter("Assets/00_Scripts/CodeGen/ElementMask.cs"))
outfile.WriteLine("usingLevelElements;");
outfile.Space(2);
outfile.WriteLine("publicabstractclassElementMask");
outfile.WriteLine("{");
outfile.WriteLine(T(1)+"publicabstractboolFits(elementTypeelementType);");
outfile.WriteLine("}");
outfile.Space(2);
List<string>masks=newList<string>();
outfile.WriteLine("publicstaticclassMaskTypes");
outfile.WriteLine("{");
masks.Add(CreateMask(outfile,"IsItem",new[]{"IsItem"},nodes,1));
masks.Add(CreateMask(outfile,"IsCollectable",new[]{"IsCollectable"},nodes,1));
masks.Add(CreateMask(outfile,"IsFluff",new[]{"IsFluff"},nodes,1));
masks.Add(CreateMask(outfile,"IsTrack",new[]{"IsTrack"},nodes,1));
masks.Add(CreateMask(outfile,"CanBeGrabbed",new[]{"Grab"},nodes,1));
masks.Add(CreateMask(outfile,"AnyThing",new[]{"IsItem","IsCollectable","IsFluff"},nodes,1,false));
masks.Add(CreateMask(outfile,"MustShake",new[]{"Shake"},nodes,1));
masks.Add(CreateMask(outfile,"ShakeItem",new[]{"IsItem","Shake"},nodes,1));
masks.Add(CreateMask(outfile,"ShakeFluff",new[]{"IsFluff","Shake"},nodes,1));
masks.Add(CreateMask(outfile,"HidingShakeFluff",new[]{"IsFluff","Shake","Hide"},nodes,1));
masks.Add(CreateMask(outfile,"Action",new[]{"Action"},nodes,1));
masks.Add(CreateMask(outfile,"CanMove",new[]{"Move"},nodes,1));
masks.Add(CreateMask(outfile,"Hide",new[]{"Hide"},nodes,1));
masks.Add(CreateMask(outfile,"CreatorButton",new[]{"Button"},nodes,1));
masks.Add(CreateMask(outfile,"TrackCanGrow",new[]{"TrackGrow"},nodes,1));
masks.Add(CreateMask(outfile,"TrackCanTurn",new[]{"TrackTurn"},nodes,1));
masks.Add(CreateMask(outfile,"Warp",new[]{"Warp"},nodes,2));
masks.Add(CreateMask(outfile,"Warp_Start",new[]{"Warp_Start"},nodes,2));
masks.Add(CreateMask(outfile,"Warp_SideSwitch",new[]{"Warp_Side"},nodes,2));
outfile.WriteLine("}");
outfile.Space(2);
outfile.WriteLine("publicstaticclassMask");
outfile.WriteLine("{");
intcount=masks.Count;
intlongestMaskName=0;
for(inti=0;i<count;i++)
longestMaskName=Mathf.Max(longestMaskName,masks[i].Length);
for(inti=0;i<count;i++)
stringname=masks[i];
outfile.WriteLine(T(1)+"publicstaticreadonlyMaskTypes."+(name+"_Mask").PadRight(longestMaskName+6)+name.PadRight(longestMaskName)+"=newMaskTypes."+name+"_Mask();");
outfile.WriteLine("}");
privatestaticstringCreateMask(thisStreamWriteroutfile,stringmaskName,string[]masks,JSONNode[]nodes,inttabs,boolmatchAll=true)
List<string>items=newList<string>();
boolcheckGroups=false;
for(inti=0;i<masks.Length;i++)
if(masks[i].Substring(0,2)=="Is")
checkGroups=true;
break;
stringgroup="";
for(inti=0;i<nodes.Length;i++)
JSONNodeinfos=nodes[i]["info"];
boolanyMatch=false;
boolallMatch=true;
if(checkGroups)
foreach(JSONNodeinfoininfos.Children)
stringvalue=info.Value;
if(value.Contains("!"))
group=value.Replace("!","Is");
for(inte=0;e<masks.Length;e++)
stringmask=masks[e];
boolhasMatch=checkGroups&&group.Contains(mask);
if(!hasMatch)
if(mask.Contains("#"))
mask=mask.Replace("#","");
hasMatch=true;
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains(mask))
hasMatch=false;
else
foreach(JSONNodeinfoininfos.Children)
if(info.Value.Contains(mask))
hasMatch=true;
if(hasMatch)
anyMatch=true;
else
allMatch=false;
if(matchAll&&allMatch||!matchAll&&anyMatch)
stringitem=nodes[i]["name"];
items.AddUnique(item);
items.Sort();
outfile.WriteLine(T(tabs)+"publicclass"+maskName+"_Mask:ElementMask");
outfile.WriteLine(T(tabs)+"{");
outfile.WriteLine(T(tabs+1)+"publicoverrideboolFits(elementTypeelementType)");
outfile.WriteLine(T(tabs+1)+"{");
outfile.WriteLine(T(tabs+2)+"switch(elementType)");
outfile.WriteLine(T(tabs+2)+"{");
intlongestItemName=items.MaxStringLength();
for(inti=0;i<items.Count;i++)
outfile.WriteLine(T(tabs+3)+"caseelementType."+items[i].PadRight(longestItemName)+":"+(i==items.Count-1?"returntrue;":""));
outfile.Space(1);
outfile.WriteLine(T(4)+"default:returnfalse;");
outfile.WriteLine(T(tabs+2)+"}");
outfile.WriteLine(T(tabs+1)+"}");
outfile.WriteLine(T(tabs)+"}");
returnmaskName;
publicstaticclassParseGroupJSON
publicstaticvoidParseGroups()
List<GroupElements>groups=newList<GroupElements>();
JSONNode[]nodes=ParseElementJSON.JSON_Nodes();
for(inti=0;i<nodes.Length;i++)
JSONNodevalueNode=nodes[i]["group"];
if(valueNode!=null)
stringname=nodes[i]["name"];
foreach(JSONNodeinfoinvalueNode.Children)
stringgroupName=info.Value;
GroupElementsgroup=null;
for(inte=0;e<groups.Count;e++)
if(groups[e].name==groupName)
group=groups[e];
break;
if(group==null)
group=newGroupElements(groupName);
groups.Add(group);
group.elements.Add(name);
intlongest=0;
for(inti=0;i<groups.Count;i++)
longest=Mathf.Max(longest,groups[i].name.Length-2);
conststringcsPath="Assets/00_Scripts/CodeGen/Groups.cs";
newStreamWriter(csPath))
outfile.WriteLine("usingLevelElements;");
outfile.Space(1);
outfile.WriteLine("publicstaticclassGroups");
outfile.WriteLine("{");
outfile.WriteLine(T(1)+"staticGroups()");
outfile.WriteLine(T(1)+"{");
conststringgroupString="=newGroup(new[]{";
intgapLength=T(2).Length+longest+groupString.Length;
stringgap="";
for(inti=0;i<gapLength;i++)
gap+="";
intgroupCount=groups.Count;
for(inti=0;i<groupCount;i++)
GroupElementsgroup=groups[i];
intnameCount=group.elements.Count;
for(inte=0;e<group.elements.Count;e++)
stringline;
if(e==0)
line=T(2)+group.name.Replace("\"","").PadRight(longest)+groupString+"elementType."+group.elements[e];
else
line=gap+"elementType."+group.elements[e];
outfile.WriteLine(line+(e<nameCount-1?",":"});"));
if(i<groupCount-1)
outfile.Space(1);
outfile.Space(1);
stringline=T(2)+"All=new[]{";
for(inti=0;i<groupCount;i++)
line+=groups[i].name.Replace("\"","");
line+=i<groupCount-1?",":"};";
outfile.WriteLine(line);
outfile.WriteLine(T(1)+"}");
outfile.Space(2);
stringline=T(1)+"privatestaticreadonlyGroup";
for(inti=0;i<groupCount;i++)
line+=groups[i].name.Replace("\"","");
line+=i<groupCount-1?",":";";
outfile.WriteLine(line);
outfile.WriteLine(T(1)+"publicstaticreadonlyGroup[]All;");
outfile.Space(2);
outfile.WriteLine(T(1)+"publicstaticGroupAlias(thiselementTypeelementType)");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(2)+"switch(elementType)");
outfile.WriteLine(T(2)+"{");
outfile.WriteLine(T(3)+"default:returnnull;");
outfile.Space(1);
for(inti=0;i<groupCount;i++)
GroupElementsgroup=groups[i];
intnameCount=group.elements.Count;
for(inte=0;e<nameCount;e++)
outfile.WriteLine(T(3)+"caseelementType."+group.elements[e]+(e<nameCount-1?":":":return"+group.name+";"));
if(i<groupCount-1)
outfile.Space(1);
outfile.WriteLine(T(2)+"}");
outfile.WriteLine(T(1)+"}");
outfile.WriteLine("}");
AssetDatabase.Refresh();
privatestaticstringT(inttabs)
conststringgap="";
stringtabSpace="";
for(inti=0;i<tabs;i++)
tabSpace+=gap;
returntabSpace;
privateclassGroupElements
publicreadonlystringname;
publicreadonlyList<string>elements=newList<string>();
publicGroupElements(stringname)
this.name=name;
publicoverridestringToString()
stringvalue=name+"|";
for(inti=0;i<elements.Count;i++)
value+=""+elements[i];
returnvalue.B_Pink();
publicstaticclassControll
publicstaticvoidUpdate()
ScrollWheelDelta=!Application.isEditor||OnScreenInEditor?Input.GetAxis("MouseScrollWheel")*Time.deltaTime:0;
ZoomUpdate();
TouchUpdate();
ShakeUpdate();
publicstaticfloatScrollWheelDelta;
privatestaticboolOnScreenInEditor
get
Vector2viewPos=newVector2(Input.mousePosition.x/Screen.width,Input.mousePosition.y/Screen.height);
returnviewPos.x>0&&viewPos.x<1&&viewPos.y>0&&viewPos.y<1;
privatestaticfloatPixelPerMilimeter{get{returnScreen.dpi*.048f;}}
publicdelegatevoidSwipe(boolstart);publicstaticeventSwipeonSwipe;
publicdelegatevoidZoom(boolstart);publicstaticeventZoomonZoom;
publicdelegatevoidShake();publicstaticeventShakeonShake;
privatestaticVector2startPos;
privatestaticfloattouchStartTime;
privatestaticboolcanSwipe,swiping,zooming;
privatestaticintTouchID=NoTouchID;
privateconstintMouseID=int.MaxValue,
NoTouchID=int.MinValue;
publicstaticVector2TouchPos;
publicstaticfloatZoomLength;
privatestaticvoidTouchUpdate()
if(TouchStart)
if(!UI_Manager.HitUI&&!zooming)
swiping=false;
canSwipe=true;
startPos=TouchPos;
touchStartTime=Time.realtimeSinceStartup;
else
canSwipe=false;
if(Touching&&!swiping&&canSwipe&&!zooming)
if(Time.realtimeSinceStartup-touchStartTime>=.1f||Vector2.Distance(TouchPos,startPos)/PixelPerMilimeter>0)
if(onSwipe!=null)
onSwipe(true);
swiping=true;
if(TouchStop&&swiping)
if(onSwipe!=null)
onSwipe(false);
swiping=false;
privatestaticboolTouchStart
get
if(Application.isMobilePlatform)
if(!zooming&&Input.touchCount>0&&TouchID==NoTouchID)
for(inti=0;i<Input.touchCount;i++)
Touchtouch=Input.touches[i];
if(touch.phase!=TouchPhase.Canceled&&touch.phase!=TouchPhase.Ended)
TouchPos=touch.position;
TouchID=touch.fingerId;
returntrue;
else
if(Input.GetMouseButtonDown(0))
TouchPos=Input.mousePosition;
TouchID=MouseID;
returntrue;
returnfalse;
privatestaticboolTouching
get
if(Application.isMobilePlatform)
if(!zooming&&Input.touchCount>0)
for(inti=0;i<Input.touchCount;i++)
Touchtouch=Input.touches[i];
if(touch.fingerId==TouchID
&&touch.phase!=TouchPhase.Canceled
&&touch.phase!=TouchPhase.Ended)
TouchPos=touch.position;
returntrue;
else
if(Input.GetMouseButton(0))
TouchPos=Input.mousePosition;
returntrue;
returnfalse;
privatestaticboolTouchStop
get
if(Application.isMobilePlatform)
if(!zooming&&Input.touchCount>0)
for(inti=0;i<Input.touchCount;i++)
if(Input.touches[i].fingerId==TouchID
&&(Input.touches[i].phase==TouchPhase.Canceled||Input.touches[i].phase==TouchPhase.Ended))
TouchID=NoTouchID;
returntrue;
if(zooming||Input.touchCount==0&&TouchID!=NoTouchID&&TouchID!=MouseID)
TouchID=NoTouchID;
returntrue;
else
if(Input.GetMouseButtonUp(0))
TouchID=NoTouchID;
returntrue;
returnfalse;
privatestaticvoidZoomUpdate()
boolisZooming=Application.isMobilePlatform&&Input.touchCount==2;
if(isZooming)
ZoomLength=Vector3.Distance(Input.touches[0].position,Input.touches[1].position)/PixelPerMilimeter;
if(isZooming&&!zooming)
zooming=true;
if(onZoom!=null)
onZoom(true);
if(!isZooming&&zooming)
zooming=false;
if(onZoom!=null)
onZoom(false);
privatestaticVector3lowPassValue;
privatestaticvoidShakeUpdate()
if(!Application.isMobilePlatform)
if(KeyMap.Down(Key.Rewind)&&onShake!=null)
onShake();
else
Vector3acceleration=Input.acceleration;
lowPassValue=Vector3.Lerp(lowPassValue,acceleration,Time.deltaTime*4);
Vector3deltaAcceleration=acceleration-lowPassValue;
constfloatthreshold=.75f*.75f;
if(deltaAcceleration.sqrMagnitude>=threshold&&onShake!=null)
onShake();
publicclassShakeRewind:Singleton<ShakeRewind>
publicstaticboolRewinding;
publicstaticfloatCheckTime
get
if(!GameManager.Running)
return0;
Clipclip=Spinner.CurrentPlayerClip;
if(clip==null)
return0;
if(!clip.Type.IsAnyJump())
returnGTime.Now;
returnclip.after!=null?GTime.Now-(clip.after.startTime-clip.startTime):GTime.Now-GTime.RewindTime;
privatevoidOnEnable()
Rewinding=false;
Controll.onShake+=onShake;
privatevoidOnDisable()
Controll.onShake-=onShake;
privatevoidonShake()
if(!Rewinding&&GameManager.Running&&!GTime.Paused&&
Spinner.CurrentPlayerClip!=null)
StartCoroutine(Rewind(Spinner.CurrentPlayerClip));
privatestaticIEnumeratorRewind(Clipclip)
floatstartTime=0;
switch(clip.Type)
default:yieldbreak;
caseClipType.Jump:
caseClipType.AirLaunch:
caseClipType.SlipOff:
startTime=clip.startTime;
break;
caseClipType.Bump:
startTime=clip.before.startTime;
break;
Rewinding=true;
while(GTime.Now>startTime)
GTime.Speed=Mathf.Max(GTime.Speed-Time.deltaTime*30,-2);
yieldreturnnull;
Spinner.Squash.ClearAfterFor(clip.spinner,startTime);
ActorAnimator.ClearAllAfter(clip.spinner,startTime);
ScoreStick.ClearAllAfter(clip.spinner,startTime);
Poof.ClearAfter(clip.spinner,startTime);
Collector.ClearAfter(clip.spinner,startTime);
clip.spinner.ClearClipsAfter(startTime);
MultiCam.Shake(Mathf.Abs(GTime.Speed));
GTime.Speed=1;
Rewinding=false;
publicstaticclassCharColors
privatestaticreadonlyList<Color32>colors=newList<Color32>(short.MaxValue);
publicstaticvoidColorize(thisMeshmesh,CostumeColorscostumeColors=null,List<byte>colorMask=null,List<byte>shadeMask=null)
if(costumeColors==null)
costumeColors=CostumeColors.RandomScheme;
mesh.GetColors(colors);
booluseMask=colorMask!=null,
useShade=shadeMask!=null;
intcount=useMask?colorMask.Count:colors.Count;
for(inti=0;i<count;i++)
colors[i]=costumeColors.GetColor(colorMask[i],useShade?shadeMask[i]:(byte)255);
mesh.SetColors(colors);
publicenumCharPartType:byte
Skin=0,
Eye=1,
Pupil=2,
Mouth=3,
Nose=4,
Ear=5,
Brow=6,
Hair=7,
Beard=8,
Shirt=9,
Pants=10,
Socks=11,
Underwear=12,
Accessory=13,
Belt=14,
Skin_B=64,
Eye_B=65,
Pupil_B=66,
Mouth_B=67,
Nose_B=68,
Ear_B=69,
Brow_B=70,
Hair_B=71,
Beard_B=72,
Shirt_B=73,
Pants_B=74,
Socks_B=75,
Underwear_B=76,
Accessory_B=77,
Belt_B=78,
Skin_C=128,
Eye_C=129,
Pupil_C=130,
Mouth_C=131,
Nose_C=132,
Ear_C=133,
Brow_C=134,
Hair_C=135,
Beard_C=136,
Shirt_C=137,
Pants_C=138,
Socks_C=139,
Underwear_C=140,
Accessory_C=141,
Belt_C=142,
Skin_D=192,
Eye_D=193,
Pupil_D=194,
Mouth_D=195,
Nose_D=196,
Ear_D=197,
Brow_D=198,
Hair_D=199,
Beard_D=200,
Shirt_D=201,
Pants_D=202,
Socks_D=203,
Underwear_D=204,
Accessory_D=205,
Belt_D=206,
[CreateAssetMenu(menuName="Scriptable/CostumeColors")]
publicclassCostumeColors:ScriptableObject
publicList<CostumeColor>colors;
publicColor32GetColor(bytemapIndex,byteshade)
intcount=colors.Count;
for(inti=0;i<count;i++)
if((byte)colors[i].partType==mapIndex)
returncolors[i].GetColor(shade);
returncolors[0].GetColor(shade);
privatestaticCostumeColors[]resourceSchemes;
publicstaticCostumeColorsRandomScheme
get
if(resourceSchemes==null)
Object[]objects=Resources.LoadAll("ColorSchemes");
resourceSchemes=newCostumeColors[objects.Length];
for(inti=0;i<objects.Length;i++)
resourceSchemes[i]=objects[i]asCostumeColors;
returnresourceSchemes[Random.Range(0,resourceSchemes.Length-1)];
publicstringLog()
List<Color>col=newList<Color>();
for(inti=0;i<colors.Count;i++)
col.Add(colors[i].realColor);
returncol.Log()+""+name;
[System.Serializable]
publicclassCostumeColor
publicCharPartTypepartType;
publicshortcolorID;
publicbytematCap;
publicColorrealColor;
publicColor32GetColor(byteshade)
intmatCapOffset=Mathf.FloorToInt(colorID/256f);
intcolorValue=colorID%256;
intmatCapValue=matCapOffset*16+matCap;
floatr=colorValue/256.0f;
floatg=matCapValue/256.0f;
bytebyteR=(byte)Mathf.RoundToInt(r*255f);
bytebyteG=(byte)Mathf.RoundToInt(g*255f);
returnnewColor32(byteR,byteG,0,shade);
[CustomEditor(typeof(CostumeColors))]
publicclassCostumeColorsEditor:Editor
publicoverridevoidOnInspectorGUI()
if(!Palette.Initialized)
Palette.Load();
GUI.color=Color.white;
CostumeColorscC=targetasCostumeColors;
GUILayout.BeginHorizontal();
GUILayout.BeginVertical();
for(inti=0;i<cC.colors.Count;i++)
GUILayout.BeginHorizontal();
CostumeColors.CostumeColorpart=cC.colors[i];
EditorGUILayout.ColorField(part.realColor);
EditorGUI.BeginChangeCheck();
part.partType=(CharPartType)EditorGUILayout.EnumPopup("",part.partType,GUILayout.Width(100));
if(EditorGUI.EndChangeCheck())
EditorUtility.SetDirty(cC);
if(part.colorID>=Palette.Colors.Length)
part.colorID=(byte)Mathf.Repeat(part.colorID,Palette.Colors.Length);
GUI.color=Palette.Colors[part.colorID];
if(GUILayout.Button(part.colorID.ToString(),GUILayout.Width(50),GUILayout.Height(14)))
/*part.colorID=(byte)Mathf.Repeat(part.colorID+(Event.current.button==0?-1:1),Palette.Colors.Length);
if(Application.isPlaying)
Spinner.SetColorScheme(cC);
EditorUtility.SetDirty(cC);*/
GUI.color=Color.white;
if(GUILayout.Button(part.matCap.ToString(),GUILayout.Width(50),GUILayout.Height(14)))
part.matCap=(byte)Mathf.Repeat(part.matCap+(Event.current.button==0?-1:1),4);
if(Application.isPlaying)
Spinner.SetColorScheme(cC);
EditorUtility.SetDirty(cC);
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
GUILayout.EndVertical();
GUILayout.BeginVertical();
if(Application.isPlaying&&GUILayout.Button(">>",GUILayout.Width(32),GUILayout.Height(32)))
Spinner.SetColorScheme(cC);
GUILayout.FlexibleSpace();
GUILayout.EndVertical();
GUILayout.EndHorizontal();
publicclassCreateCharPartsIndex:MonoBehaviour
[MenuItem("Tools/CreateCharPartsIndex")]
publicstaticvoidCCPI()
conststringcsPath="Assets/00_Scripts/Costumes/CharPartIndex.cs";
newStreamWriter(csPath))
outfile.WriteLine("publicenumCharPartType:byte");
outfile.WriteLine("{");
for(inti=0;i<4;i++)
into=i*64;
Part("Skin",0+o,outfile);
Part("Eye",1+o,outfile);
Part("Pupil",2+o,outfile);
Part("Mouth",3+o,outfile);
Part("Nose",4+o,outfile);
Part("Ear",5+o,outfile);
Part("Brow",6+o,outfile);
Part("Hair",7+o,outfile);
Part("Beard",8+o,outfile);
Part("Shirt",9+o,outfile);
Part("Pants",10+o,outfile);
Part("Socks",11+o,outfile);
Part("Underwear",12+o,outfile);
Part("Accessory",13+o,outfile);
Part("Belt",14+o,outfile);
outfile.WriteLine("");
outfile.WriteLine("}");
AssetDatabase.Refresh();
privatestaticvoidPart(stringname,intvalue,StreamWriteroutfile)
stringsub;
intsubIndex=Mathf.FloorToInt(value/64f);
switch(subIndex)
default:sub="";break;
case1:sub="_B";break;
case2:sub="_C";break;
case3:sub="_D";break;
outfile.WriteLine(T(1)+(name+sub).PadRight(15)+"="+value+",");
privatestaticstringT(inttabs)
conststringgap="";
stringtabSpace="";
for(inti=0;i<tabs;i++)
tabSpace+=gap;
returntabSpace;
publicstaticclassColorTools
[MenuItem("Colors/Palette/SetOldColors")]
privatestaticvoidSetOld()
Palettepalette=Resources.Load<Palette>("Palette");
palette.colors=PaletteSource.Get.oldColors;
EditorUtility.SetDirty(palette);
Palette.Load();
SetIDsToCostumes();
[MenuItem("Colors/Palette/SetNewColors")]
privatestaticvoidSetNew()
Palettepalette=Resources.Load<Palette>("Palette");
palette.colors=PaletteSource.Get.newColors;
EditorUtility.SetDirty(palette);
Palette.Load();
SetIDsToCostumes();
privatestaticvoidSetIDsToCostumes()
CostumeColors[]costumes=Assets.FindAll<CostumeColors>();
for(inti=0;i<costumes.Length;i++)
CostumeColorscostume=costumes[i];
for(inte=0;e<costume.colors.Count;e++)
CostumeColors.CostumeColorcolor=costume.colors[e];
color.colorID=(short)color.realColor.ClosestColorIndex(Palette.Colors);
EditorUtility.SetDirty(costume);
[MenuItem("Colors/DebugCostume")]
privatestaticvoidDebugCostume()
if(!GameManager.Running)
return;
Rigrig=Spinner.Get(0).rig;
Debug.Log(rig.cC.Log());
Selection.activeObject=rig.cC;
LogMesh(rig.GetComponent<SkinnedMeshRenderer>().sharedMesh);
[MenuItem("Colors/Houdini/Export")]
privatestaticvoidExport()
HoudiniVexExport(PaletteSource.Get.newColors);
HoudiniPyExport("gamecolors",PaletteSource.Get.newColors);
HoudiniPyExport("oldColors",NewColorGen.HoudiniUsed(true));
[MenuItem("Colors/Houdini/GetUsed")]
privatestaticvoidShowHoudiniUsed()
NewColorGen.HoudiniUsed();
privatestaticvoidHoudiniVexExport(Color[]colors)
conststringtab="",tabtab=tab+tab;
List<string>houdiniLines=newList<string>();
houdiniLines.Add("intcount()");
houdiniLines.Add("{");
houdiniLines.Add(tab+"return"+colors.Length+";");
houdiniLines.Add("}\n\n");
houdiniLines.Add("vectorcolor(intpick)");
houdiniLines.Add("{");
houdiniLines.Add(tab+"vectorpalette[]=");
houdiniLines.Add(tab+"{");
for(inti=0;i<colors.Length;i++)
houdiniLines.Add(tabtab+"{"+ColorString(colors[i])+"}"+(i<colors.Length?",":""));
houdiniLines.Add(tab+"};");
houdiniLines.Add("");
houdiniLines.Add(tab+"returnpalette[pick%len(palette)];");
houdiniLines.Add("}");
string[]colorToolLines=File.ReadAllLines(Application.dataPath+"/04_TextFiles/HoudiniTemplates/ColorTools.h");
for(inti=0;i<colorToolLines.Length;i++)
houdiniLines.Add(colorToolLines[i]);
File.WriteAllLines(@"D:\HoudiniProjects\SpinUp\vex\include/gamecolors.h",houdiniLines.ToArray());
privatestaticvoidHoudiniPyExport(stringlibraryName,Color[]colors)
conststringtab="",colorTab=tab+tab+tab+tab;
List<string>houdiniLines=newList<string>();
houdiniLines.Add("importnumpyasnp\n\n");
for(inti=0;i<colors.Length;i++)
stringfirst=i==0?"colors=np.array([":colorTab;
stringend=i==colors.Length-1?"])":",";
houdiniLines.Add(first+"["+ColorString(colors[i])+"]"+end);
string[]colorToolLines=File.ReadAllLines(Application.dataPath+"/04_TextFiles/HoudiniTemplates/ColorTools.py");
for(inti=0;i<colorToolLines.Length;i++)
houdiniLines.Add(colorToolLines[i]);
File.WriteAllLines(@"D:\HoudiniProjects\SpinUp\vex\include/"+libraryName+".py",houdiniLines.ToArray());
privatestaticstringFloatString(floatvalue)
stringreturnString=value.ToString(CultureInfo.InvariantCulture);
if(returnString.Length>1&&returnString[0]=='0')
returnString=returnString.Substring(1,returnString.Length-1);
returnreturnString;
privatestaticstringColorString(Colorcolor)
returnFloatString(color.r)+","+FloatString(color.g)+","+FloatString(color.b);
[MenuItem("Assets/ColorIDsandMatCaps")]
privatestaticvoidMeshCheck()
if(Selection.activeObject==null)
return;
Meshmesh=Selection.activeObjectasMesh;
if(mesh!=null)
LogMesh(mesh);
privatestaticvoidLogMesh(Meshmesh)
Color[]colors=mesh.colors;
List<Color>cols=newList<Color>();
List<int>colorIDs=newList<int>();
List<int>matcaps=newList<int>();
for(inti=0;i<colors.Length;i++)
intcolorValue=Mathf.RoundToInt(colors[i].r*256f);
intmatCapValue=Mathf.RoundToInt(colors[i].g*256f);
intmatCapOffset=Mathf.FloorToInt(matCapValue/16.0f);
intresultID=matCapOffset*256+colorValue;
if(colorIDs.AddUnique(resultID))
cols.Add(Palette.Colors[resultID]);
matcaps.Add(matCapValue%16);
Debug.Log("Colors:"+colorIDs.Log());
Debug.Log("Colors:"+cols.Log());
Debug.Log("MatCaps:"+matcaps.Log());
[MenuItem("Assets/ColorIDsandMatCaps",true)]
privatestaticboolNewMenuOptionValidation()
returnSelection.activeObjectisMesh;
/*[MenuItem("Colors/FixCostumes")]
privatestaticvoidFixCostumes()
CostumeColors[]costumes=Assets.FindAll<CostumeColors>();
for(inti=0;i<costumes.Length;i++)
for(inte=0;e<costumes[i].colors.Count;e++)
CostumeColors.CostumeColorcc=costumes[i].colors[e];
cc.realColor=PaletteSource.Get.oldColors[cc.color];
EditorUtility.SetDirty(costumes[i]);
/*[MenuItem("Colors/SaveoldColors")]
privatestaticvoidSaveOld()
if(PaletteSource.Get.oldColors.Length>0)
return;
Palettepalette=Resources.Load<Palette>("Palette");
PaletteSource.Get.oldColors=palette.colors;
EditorUtility.SetDirty(PaletteSource.Get);
publicstaticclassListMaterials
[MenuItem("Tools/ProjectInfo/ListMats")]
privatestaticvoidList()
Material[]mats=GetAllMats();
List<string>matShaders=newList<string>();
List<string>lines=newList<string>();
for(inti=0;i<mats.Length;i++)
Materialmat=mats[i];
stringassetPath=AssetDatabase.GetAssetPath(mat);
matShaders.Add(assetPath);
lines.Add(mat.name+"<-"+mat.shader.name+"|"+assetPath);
intlongest=0;
for(inti=0;i<lines.Count;i++)
longest=Mathf.Max(longest,lines[i].Split('<')[0].Length);
for(inti=0;i<lines.Count;i++)
string[]parts=lines[i].Split('<');
lines[i]=parts[0].PadRight(longest)+"<"+parts[1];
intlongest=0;
for(inti=0;i<lines.Count;i++)
longest=Mathf.Max(longest,lines[i].Split('|')[0].Length);
for(inti=0;i<lines.Count;i++)
string[]parts=lines[i].Split('|');
lines[i]=parts[0].PadRight(longest)+"|"+parts[1];
ProjectTxt.Write("04_TextFiles/Materials",lines.ToArray());
List<string>shaderPaths=GetAllShadersPaths();
for(inti=0;i<shaderPaths.Count;i++)
stringpath=shaderPaths[i];
for(inte=0;e<matShaders.Count;e++)
if(path==matShaders[e])
shaderPaths.RemoveAt(i);
i--;
break;
for(inti=0;i<shaderPaths.Count;i++)
Debug.Log(shaderPaths[i]);
privatestaticMaterial[]GetAllMats()
string[]files=Directory.GetFiles(Application.dataPath,"*.mat*",SearchOption.AllDirectories);
List<Material>mats=newList<Material>();
foreach(stringfileinfiles)
stringfullPath=file.Replace(@"\","/");
stringassetPath="Assets"+fullPath.Replace(Application.dataPath,"");
Materialmaterial=AssetDatabase.LoadAssetAtPath(assetPath,typeof(Material))asMaterial;
if(material!=null)
mats.Add(material);
returnmats.ToArray();
privatestaticList<string>GetAllShadersPaths()
string[]files=Directory.GetFiles(Application.dataPath,"*.shader*",SearchOption.AllDirectories);
List<string>shaders=newList<string>();
foreach(stringfileinfiles)
stringfullPath=file.Replace(@"\","/");
stringassetPath="Assets"+fullPath.Replace(Application.dataPath,"");
Shadershader=AssetDatabase.LoadAssetAtPath(assetPath,typeof(Shader))asShader;
if(shader!=null)
shaders.Add(assetPath);
returnshaders;
publicstaticclassListMenuItems
[MenuItem("Tools/ProjectInfo/ListMenuItems")]
privatestaticvoidList()
string[]files=Directory.GetFiles(Application.dataPath,"*.cs",SearchOption.AllDirectories);
List<string>lines=newList<string>();
for(inti=0;i<files.Length;i++)
if(files[i].Contains("ListMenuItems"))
continue;
string[]fileLines=File.ReadAllLines(files[i]);
for(inte=0;e<fileLines.Length;e++)
stringline=fileLines[e];
if(line.Contains("MenuItem")&&
!line.Contains("ExecuteMenuItem"))
stringtrimmedLine=line.Split('"')[1];
string[]lineParts=trimmedLine.Split('');
stringlast=lineParts[lineParts.Length-1];
if(last.Contains("#")||last.Contains("&")||last.Contains("_")||last.Contains("%"))
stringadjustedLine="";
for(intl=0;l<lineParts.Length-1;l++)
adjustedLine+=lineParts[l]+"";
adjustedLine+="!";
adjustedLine+=last;
lines.Add(adjustedLine);
intlongest=0;
for(inti=0;i<lines.Count;i++)
longest=Mathf.Max(longest,lines[i].Split('!')[0].Length);
for(inti=0;i<lines.Count;i++)
string[]parts=lines[i].Split('!');
lines[i]=parts[0].PadRight(longest)+parts[1];
lines.Sort();
ProjectTxt.Write("04_TextFiles/MenuItems",lines.ToArray());
publicstaticclassUsedKeys
[MenuItem("Tools/ProjectInfo/FindusedKeys")]
publicstaticvoidFindKeys()
string[]file=Directory.GetFiles(Application.dataPath,"*.cs",SearchOption.AllDirectories);
List<string>keyLines=newList<string>();
for(inti=0;i<file.Length;i++)
if(file[i].Contains("UsedKeys"))
continue;
string[]lines=File.ReadAllLines(file[i]);
for(inte=0;e<lines.Length;e++)
stringline=lines[e];
if(!line.Contains("KeyCode"))
continue;
stringfileName=file[i].Split('\\').Last().Replace(".cs","");
if(!AddIf(line,"Input.GetKey(","",fileName,keyLines))
if(!AddIf(line,"Input.GetKeyDown(","",fileName,keyLines))
AddIf(line,"Input.GetKeyUp(","",fileName,keyLines);
Pad(keyLines);
List<string>merged=newList<string>();
while(keyLines.Count>0)
stringline=keyLines[0];
keyLines.RemoveAt(0);
stringkeyPress=line.Split('|')[0];
for(inti=0;i<keyLines.Count;i++)
string[]parts=keyLines[i].Split('|');
stringthisKeyPress=parts[0];
if(thisKeyPress==keyPress)
line+=parts[1];
keyLines.RemoveAt(i);
i--;
merged.Add(line);
List<string>alphabet=newList<string>();
for(inti=0;i<merged.Count;i++)
stringkeyPress=merged[i].Split('|')[0].Replace("","");
if(keyPress.Length==1)
alphabet.Add(merged[i]);
merged.RemoveAt(i);
i--;
List<string>numbers=newList<string>();
for(inti=0;i<merged.Count;i++)
stringkeyPress=merged[i].Split('|')[0];
if(keyPress.Contains("Alpha"))
numbers.Add(merged[i]);
merged.RemoveAt(i);
i--;
alphabet.Sort();
numbers.Sort();
merged.Sort();
List<string>all=newList<string>();
all.AddRange(alphabet);
all.Add("");
all.AddRange(numbers);
all.Add("");
all.AddRange(merged);
ProjectTxt.Write("04_TextFiles/UsedKeys",all.ToArray());
privatestaticboolAddIf(stringline,stringsearchString,stringsymbol,stringfileName,List<string>lines)
if(line.Contains(searchString))
stringkeyCode=line.Split(new[]{searchString},StringSplitOptions.None)[1].Split(')')[0].Replace("KeyCode.","");
lines.Add(keyCode+"|"+symbol+""+fileName);
returntrue;
returnfalse;
privatestaticvoidPad(List<string>lines)
intlongest=0;
for(inti=0;i<lines.Count;i++)
if(lines[i].Contains("|"))
longest=Mathf.Max(longest,lines[i].Split('|')[0].Length);
for(inti=0;i<lines.Count;i++)
if(lines[i].Contains("|"))
string[]parts=lines[i].Split('|');
lines[i]=parts[0].PadRight(longest)+"|"+parts[1];
[System.Serializable]
publicstructArc
publicconstfloatLineTipPathRatio=2.265039f;
publicVector2center;
publicfloatradius,angle,bend;
publicArc(Vector2center,floatradius,floatangle,floatbend)
this.center=center;
this.radius=radius;
this.angle=angle;
this.bend=bend;
publicArc(Lineline,floatbend,floatlerp=.5f)
floatdir_M=line.dir.magnitude;
Vector2lineM=line.l1+line.dir*lerp;
this.bend=bend;
floatbendSign=Mathf.Sign(bend);
radius=Mathf.Abs(1/bend/2/Mth.*dir_M);
center=lineM+(Rot.Z(90)*line.dir*((dir_M>0?1f/dir_M:0)*radius*bendSign)).V2();
angle=(lineM-center).Angle_Sign(Vector2.up)-180*Mathf.Abs(bend)+Mathf.Lerp(180,-180,lerp)*bend+180*(1-(bendSign*.5f+.5f));
publicVector2GetClosestPoint(Vector2point)
returnLerpPos(Mathf.Clamp01(GetClosestLerp(point)));
publicfloatGetClosestLerp(Vector2point)
floatabsBend=Mathf.Abs(bend);
Vector2centerDir=Vector2.up.Rot(angle+absBend*180)*Mathf.Sign(bend);
floatradAngle=centerDir.RadAngle(point-center);
floatlerp=(absBend*Mth.+radAngle)/(absBend*Mth.FullRad);
returnbend<0?1-lerp:lerp;
publicVector2LerpPos(floatlerp)
if(bend<0)
lerp=1-lerp;
floatrad=lerp*Mth.FullRad*Mathf.Abs(bend)+angle*Mathf.Deg2Rad;
floatsignedRadius=SignedRadius;
returnnewVector2(-Mathf.Sin(rad)*signedRadius+center.x,
Mathf.Cos(rad)*signedRadius+center.y);
publicVector2LerpDir(floatlerp)
if(bend<0)
lerp=1-lerp;
floatrad=lerp*Mth.FullRad*Mathf.Abs(bend)+(angle+180)*Mathf.Deg2Rad;
returnrad.ToRadDir();
publicArcSetPos(Vector2pos,floatposLerp=.5f)
Vector2lerpPos=LerpPos(posLerp);
Vector2newCenter=newVector2(pos.x+(center.x-lerpPos.x),pos.y+(center.y-lerpPos.y));
returnnewArc(newCenter,radius,angle,bend);
publicArcSetCenterPos(Vector2pos)
returnnewArc(pos,radius,angle,bend);
publicArcRotate(floatrotAngle,floatrotLerp=.5f)
Vector2lerpPos=LerpPos(rotLerp);
Vector2toCenter=(center-lerpPos).Rot(rotAngle);
returnnewArc(lerpPos+toCenter,radius,angle+rotAngle,bend);
publicArcRotateCenter(floatrotAngle)
returnnewArc(center,radius,angle+rotAngle,bend);
publicArcSetBend(floatbend,floatlerp=.5f)
returnnewArc(newLine(this,lerp),bend,lerp);
publicintContact(Lineline,outVector2i1,outVector2i2,boolunclamped=false)
Vector2c1,c2;
intcircleHits=newCircle(center,radius).Contact(line,outc1,outc2,unclamped);
constfloatthresh=.000005f,upper=1+thresh,lower=-thresh;
switch(circleHits)
case2:
floatl2=GetClosestLerp(c2);
if(l2<lower||l2>upper)
circleHits--;
floatl1=GetClosestLerp(c1);
if(l1<lower||l1>upper)
if(circleHits==2)
c1=c2;
circleHits--;
break;
case1:
floatl1=GetClosestLerp(c1);
if(l1<lower||l1>upper)
circleHits=0;
break;
i1=c1;
i2=circleHits==2?c2:c1;
returncircleHits;
publicboolRayCast(Vector2root,Vector2dir,outVector2hitPoint)
Vector2i1,i2;
intarcHits=Contact(newLine(root,root+dir),outi1,outi2,true);
switch(arcHits)
case2:
if(Vector2.Dot(i2-root,dir)<0)
arcHits--;
if(Vector2.Dot(i1-root,dir)<0)
if(arcHits==2)
i1=i2;
arcHits--;
break;
case1:
if(Vector2.Dot(i1-root,dir)<0)
arcHits=0;
break;
hitPoint=arcHits==2?(i1-root).sqrMagnitude<(i2-root).sqrMagnitude?i1:i2:arcHits==1?i1:root;
returnarcHits>0;
publicArcShift(floatamount)
returnnewArc(center,radius+amount*-Mathf.Sign(bend),angle,bend);
publicfloatGet_Length{get{returnMathf.Abs(radius*Mth.FullRad*bend);}}
publicfloatGet_ChordLength{get{return2*radius*Mathf.Sin(Mathf.Abs(bend*Mathf.PI));}}
publicfloatGet_Height
get
floatchord=Get_ChordLength;
returnradius-Mathf.Sqrt(radius*radius-chord*chord*.25f);
publicfloatSignedRadius{get{returnradius*Mathf.Sign(bend);}}
namespaceGeoMath
[System.Serializable]
publicstructBounds2D
publicfloatminX,maxX,minY,maxY;
publicVector2Center{get{returnnewVector2(minX+(maxX-minX)*.5f,minY+(maxY-minY)*.5f);}}
publicVector2Size{get{returnnewVector2(maxX-minX,maxY-minY);}}
publicVector2TR{get{returnnewVector2(maxX,maxY);}}
publicVector2BR{get{returnnewVector2(maxX,minY);}}
publicVector2BL{get{returnnewVector2(minX,minY);}}
publicVector2TL{get{returnnewVector2(minX,maxY);}}
publicfloatMaxSide{get{returnMathf.Max(maxX-minX,maxY-minY);}}
publicfloatAspect{get{return(BR.x-BL.x)/(TL.y-BL.y);}}
publicfloatArea{get{return(BR.x-BL.x)*(TL.y-BL.y);}}
publicBounds2D(Vector2point)
minX=maxX=point.x;
minY=maxY=point.y;
privateBounds2D(floatminX,floatmaxX,floatminY,floatmaxY)
this.minX=minX;
this.maxX=maxX;
this.minY=minY;
this.maxY=maxY;
publicstaticBounds2DGetViaString(stringvalue)
string[]parts=value.Split('|');
string[]cParts=parts[0].Replace("(","").Replace(")","").Split(',');
string[]sParts=parts[1].Replace("(","").Replace(")","").Split(',');
Vector2c=newVector2(float.Parse(cParts[0]),float.Parse(cParts[1]));
Vector2s=newVector2(float.Parse(sParts[0]),float.Parse(sParts[1]));
returnnewBounds2D(c-s*.5f).Add(c+s*.5f);
publicBounds2DAdd(Vector2pos)
returnnewBounds2D(Mathf.Min(minX,pos.x),
Mathf.Max(maxX,pos.x),
Mathf.Min(minY,pos.y),
Mathf.Max(maxY,pos.y));
publicBounds2DAdd(Bounds2DotherBound)
returnnewBounds2D(Mathf.Min(minX,otherBound.minX),
Mathf.Max(maxX,otherBound.maxX),
Mathf.Min(minY,otherBound.minY),
Mathf.Max(maxY,otherBound.maxY));
publicBounds2DPad(floatby)
returnnewBounds2D(minX-by,maxX+by,
minY-by,maxY+by);
publicBounds2DClamp(floatminX,floatmaxX,floatminY,floatmaxY)
returnnewBounds2D(Mathf.Max(this.minX,minX),
Mathf.Min(this.maxX,maxX),
Mathf.Max(this.minY,minY),
Mathf.Min(this.maxY,maxY));
publicboolIntersects(Bounds2Dother)
returnminX<=other.maxX&&minY<=other.maxY&&maxX>=other.minX&&maxY>=other.minY;
publicfloatIntersectLerp(Bounds2Dother)
floatx_overlap=Mathf.Max(0,Mathf.Min(maxX,other.maxX)-Mathf.Max(minX,other.minX));
floaty_overlap=Mathf.Max(0,Mathf.Min(maxY,other.maxY)-Mathf.Max(minY,other.minY));
return(x_overlap*y_overlap)/Area;
publicboolXAxisOverlap(Bounds2Dother)
returnminX<=other.maxX&&maxX>=other.minX;
publicboolYAxisOverlap(Bounds2Dother)
returnminY<=other.maxY&&maxY>=other.minY;
publicboolContains(Bounds2Dother)
returnminX<=other.minX&&minY<=other.minY&&maxX>=other.maxX&&maxY>=other.maxY;
publicboolContains(Vector2point)
returnpoint.x>minX&&point.x<maxX&&point.y>minY&&point.y<maxY;
publicfloatOverlapArea(Bounds2Dother)
floatx=Mathf.Min(maxX,other.maxX)-Mathf.Max(minX,other.minX);
floaty=Mathf.Min(maxY,other.maxY)-Mathf.Max(minY,other.minY);
returnx>0&&y>0?x*y:0;
publicfloatDistanceSqr(Vector2point)
floatx=0;
if(point.x<minX)
x=minX-point.x;
if(point.x>maxX)
x=point.x-maxX;
floaty=0;
if(point.y<minY)
y=minY-point.y;
if(point.y>maxY)
y=point.y-maxY;
returnx*x+y*y;
publicfloatDistanceSqr(Bounds2Dother)
floatx=0;
if(other.maxX<minX)
x=minX-other.maxX;
if(other.minX>maxX)
x=other.minX-maxX;
floaty=0;
if(other.maxY<minY)
y=minY-other.maxY;
if(other.minY>maxY)
y=other.minY-maxY;
returnx*x+y*y;
publicfloatDistanceSqr(Vector2p1,Vector2p2)
if(Contains(p1)||Contains(p2))
return0;
Lineline=newLine(p1,p2);
returnMathf.Min(
Mathf.Min(newLine(TL,TR).LineDistSqr(line),newLine(TR,BR).LineDistSqr(line)),
Mathf.Min(newLine(BR,BL).LineDistSqr(line),newLine(BL,TL).LineDistSqr(line))
);
publicfloatInsideDistance(Bounds2Dother)
floatdist=maxX-other.maxX;
dist=Mathf.Min(dist,maxY-other.maxY);
dist=Mathf.Min(dist,other.minX-minX);
returnMathf.Min(dist,other.minY-minY);
publicboolContainsLine(Vector2p1,Vector2p2)
if(Contains(p1)||Contains(p2))
returntrue;
Lineline=newLine(p1,p2);
return
newLine(TL,TR).Contact(line)||
newLine(TR,BR).Contact(line)||
newLine(BR,BL).Contact(line)||
newLine(BL,TL).Contact(line);
publicboolBorderIntersect(Quadquad)
returnContainsLine(quad.TL,quad.TR)
||ContainsLine(quad.TR,quad.BR)
||ContainsLine(quad.BR,quad.BL)
||ContainsLine(quad.BL,quad.TL);
publicstringGetString()
returnCenter.ToString("F4")+"|"+Size.ToString("F4");
usingUnityEngine;
namespaceGeoMath
[System.Serializable]
publicstructCircle
publicVector2center;
publicfloatradius;
publicCircle(floatradius)
center=Vector2.zero;
this.radius=radius;
publicCircle(Vector2center,floatradius)
this.center=center;
this.radius=radius;
publicboolContains(Vector2point)
floatx=point.x-center.x;
floaty=point.y-center.y;
returnx*x+y*y<=radius*radius;
publicboolContact(Circleother)
floatdist=(other.center-center).sqrMagnitude;
returndist<=Mth.IntPow(radius+other.radius,2)&&
dist>=Mth.IntPow(Mathf.Abs(radius-other.radius),2);
publicboolContact(Circleother,outinthits,outVector2p1,outVector2p2)
floatdist=Vector2.Distance(center,other.center);
if(dist>radius+other.radius||dist<Mathf.Abs(radius-other.radius))
p1=p2=Vector2.zero;
hits=0;
returnfalse;
floata=(radius*radius-other.radius*other.radius+dist*dist)/(2*dist);
floath=Mathf.Sqrt(radius*radius-a*a);
Vector2c=center+a*(other.center-center)/dist;
p1=newVector2(c.x+h*(other.center.y-center.y)/dist,c.y-h*(other.center.x-center.x)/dist);
p2=newVector2(c.x-h*(other.center.y-center.y)/dist,c.y+h*(other.center.x-center.x)/dist);
hits=f.Same(dist,radius+other.radius)?1:2;
returntrue;
publicintContact(Lineline,outVector2i1,outVector2i2,boolunclamped=false)
Vector2p1=line.l1;
floatdx=line.dir.x;
floatdy=line.dir.y;
floatA=dx*dx+dy*dy;
floatB=2*(dx*(p1.x-center.x)+dy*(p1.y-center.y));
floatC=(p1.x-center.x)*(p1.x-center.x)+(p1.y-center.y)*(p1.y-center.y)-radius*radius;
floatdet=B*B-4*A*C;
if(A<=0.0000001f||det<0)
i1=newVector2(float.NaN,float.NaN);
i2=newVector2(float.NaN,float.NaN);
return0;
if(f.Same(det,0))
floattA=-B/(2*A);
i1=newVector2(p1.x+tA*dx,p1.y+tA*dy);
i2=newVector2(float.NaN,float.NaN);
return1;
floatdetRoot=Mathf.Sqrt(det);
floattA=(-B+detRoot)/(2*A);
floattB=(-B-detRoot)/(2*A);
boolvalidA=unclamped||tA>=0&&tA<=1;
boolvalidB=unclamped||tB>=0&&tB<=1;
if(validA&&validB)
i1=newVector2(p1.x+tA*dx,p1.y+tA*dy);
i2=newVector2(p1.x+tB*dx,p1.y+tB*dy);
return2;
if(validA)
i1=newVector2(p1.x+tA*dx,p1.y+tA*dy);
i2=newVector2(float.NaN,float.NaN);
return1;
if(validB)
i1=newVector2(float.NaN,float.NaN);
i2=newVector2(p1.x+tB*dx,p1.y+tB*dy);
return1;
i1=newVector2(float.NaN,float.NaN);
i2=newVector2(float.NaN,float.NaN);
return0;
publicboolContact(Lineline,boolunclamped=false)
Vector2p1=line.l1;
floatdx=line.dir.x;
floatdy=line.dir.y;
floatA=dx*dx+dy*dy;
floatB=2*(dx*(p1.x-center.x)+dy*(p1.y-center.y));
floatC=(p1.x-center.x)*(p1.x-center.x)+(p1.y-center.y)*(p1.y-center.y)-radius*radius;
floatdet=B*B-4*A*C;
if(A<=0.0000001f||det<0)
returnfalse;
if(f.Same(det,0))
returntrue;
floatdetRoot=Mathf.Sqrt(det);
floattA=(-B+detRoot)/(2*A);
floattB=(-B-detRoot)/(2*A);
boolvalidA=unclamped||tA>=0&&tA<=1;
boolvalidB=unclamped||tB>=0&&tB<=1;
if(validA||validB)
returntrue;
returnfalse;
publicfloatGetArcAngle(floatchordLength)
if(chordLength>radius+radius)
return0;
returnMathf.PI-Mathf.Acos(chordLength*.5f/radius)*2;
publicstaticfloatGetSegmentRad(floatlength,floatradius)
if(length>=Mathf.Abs(radius)*2)
returnMathf.PI*.5f*Mathf.Sign(radius);
returnMathf.Asin(length*.5f/radius);
publicstaticVector3GetPos(floatradius,floatsegmentAngle)
returnnewVector3(Mathf.Cos(segmentAngle)*radius,Mathf.Sin(segmentAngle)*radius,0);
publicstaticboolCircleCast(Vector2p1,Vector2p2,floatcastRadius,Vector2center,floatradius,refVector2hitPos)
Vector2castDir=p2-p1;
Vector2projectedPoint=newLine(p1,castDir).ClosestPoint(center,true);
floatlineDistSqr=(projectedPoint-center).sqrMagnitude;
boolinside=(p1-center).sqrMagnitude<radius*radius;
floatcheckRadius=radius+(inside?-castRadius:castRadius);
floatcheckSqr=checkRadius*checkRadius;
if(!inside&&lineDistSqr>checkSqr)
returnfalse;
Vector2checkDir=castDir.SetLength(inside?1:-1);
Vector2point=projectedPoint+checkDir*Mathf.Sqrt(checkSqr-lineDistSqr);
floatlerp=V2.InverseLerp(p1,castDir,point);
if(lerp<0||lerp>1)
returnfalse;
hitPos=point;
returntrue;
publicfloatGet_Circumference{get{returnradius*Mth.FullRad;}}
privateboolFindTangents(
Vector2external_point,outVector2pt1,outVector2pt2)
floatdx=center.x-external_point.y;
floatdy=center.x-external_point.y;
floatD_squared=dx*dx+dy*dy;
floatL=Mathf.Sqrt(D_squared-radius*radius);
/*FindCircleCircleIntersections(
center.X,center.Y,radius,
external_point.X,external_point.Y,(float)L,
outpt1,outpt2);*/
pt1=Vector2.zero;
pt2=Vector2.zero;
returntrue;
namespaceGeoMath
[System.Serializable]
publicstructLine
publicVector2l1,dir;
publicfloatLength{get{returndir.magnitude;}}
publicLine(Vector2l1,Vector2l2)
this.l1=l1;
dir=newVector2(l2.x-l1.x,l2.y-l1.y);
publicVector2ClosestPoint(Vector2point,boolunclamped=false)
Vector2AP=newVector2(point.x-l1.x,point.y-l1.y);
floatABAPproduct=Vector2.Dot(AP,dir);
floatlerp=unclamped?ABAPproduct/dir.sqrMagnitude:Mathf.Clamp01(ABAPproduct/dir.sqrMagnitude);
returnnewVector2(l1.x+dir.x*lerp,l1.y+dir.y*lerp);
publicfloatGetClosestLerp(Vector2point)
Vector2AP=newVector2(point.x-l1.x,point.y-l1.y);
floatABAPproduct=Vector2.Dot(AP,dir);
returnABAPproduct/dir.sqrMagnitude;
publicfloatSqrDistance(Vector2point,boolunclamped=false)
return(ClosestPoint(point,unclamped)-point).sqrMagnitude;
publicboolContact(Lineother,boolunclamped=false)
Vector2dummy;
returnContact(other,outdummy,unclamped);
publicboolContact(Lineother,outVector2point,boolunclamped=false)
point=Vector2.zero;
if(!unclamped&&!BoundsContact(other))
returnfalse;
Vector2dirB=other.dir;
floatcompareDot=Vector2.Dot(dir.normalized,dirB.normalized);
if(!(compareDot>-1&&compareDot<1))
returnfalse;
/*if(Mathf.Approximately(Vector2.Dot(dir,dirB),0))
returnfalse;*/
floatdenominator=dir.y*dirB.x-dir.x*dirB.y;
floatt1=((l1.x-other.l1.x)*dirB.y+(other.l1.y-l1.y)*dirB.x)/denominator;
if(!unclamped&&(t1<0||t1>1))
returnfalse;
floatt2=((other.l1.x-l1.x)*dir.y+(l1.y-other.l1.y)*dir.x)/-denominator;
if(!unclamped&&(t2<0||t2>1))
returnfalse;
point=newVector2(l1.x+dir.x*t1,l1.y+dir.y*t1);
returntrue;
privateboolBoundsContact(Lineother)
Vector2a1=l1,a2=l1+dir;
Vector2b1=other.l1,b2=other.l1+other.dir;
returnMathf.Min(a1.x,a2.x)<=Mathf.Max(b1.x,b2.x)&&
Mathf.Min(a1.y,a2.y)<=Mathf.Max(b1.y,b2.y)&&
Mathf.Min(b1.x,b2.x)<=Mathf.Max(a1.x,a2.x)&&
Mathf.Min(b1.y,b2.y)<=Mathf.Max(a1.y,a2.y);
publicboolRayCast(Vector2root,Vector2dir,outVector2hitPoint)
returnContact(newLine(root,root+dir*10000),outhitPoint);
publicboolLineIsCloserSqr(Lineother,floatsqrDist,boolunclamped=false)
if(Contact(other,unclamped))
returntrue;
if(SqrDistance(other.l1,unclamped)<=sqrDist||
SqrDistance(other.l1+other.dir,unclamped)<=sqrDist)
returntrue;
if(other.SqrDistance(l1,unclamped)<=sqrDist||
other.SqrDistance(l1+dir,unclamped)<=sqrDist)
returntrue;
returnfalse;
publicfloatLineDistSqr(Lineother,boolunclamped=false)
if(Contact(other,unclamped))
return0;
returnMathf.Min(
Mathf.Min(SqrDistance(other.l1,unclamped),SqrDistance(other.l1+other.dir,unclamped)),
Mathf.Min(other.SqrDistance(l1,unclamped),other.SqrDistance(l1+dir,unclamped))
);
publicVector2GetL2()
returnl1+dir;
publicLine(Arcarc,floatlerp=.5f)
Vector2arcPos=arc.LerpPos(lerp);
Vector2arcDir=arc.LerpDir(lerp);
floatlength=arc.Get_Length;
l1=arcPos-arcDir*lerp*length;
dir=arcDir*length;
publicfloatGetBend(floatradius)
return1/radius/2/Mth.*dir.magnitude;
publicLineRotate(floatangle,floatturnLerp=.5f)
Vector2turnPoint=newVector2(l1.x+dir.x*turnLerp,l1.y+dir.y*turnLerp);
Vector2turnDir=dir.Rot(angle);
Vector2newL1=newVector2(turnPoint.x-turnDir.x*turnLerp,turnPoint.y-turnDir.y*turnLerp);
Vector2newL2=newVector2(newL1.x+turnDir.x,newL1.y+turnDir.y);
returnnewLine(newL1,newL2);
publicLineRotateAround(Vector2point,floatangle)
Vector2turnDir=dir.Rot(angle);
Vector2newL1=(l1-point).Rot(angle)+point;
Vector2newL2=newVector2(newL1.x+turnDir.x,newL1.y+turnDir.y);
returnnewLine(newL1,newL2);
publicLineSetPos(Vector2pos,floatposLerp=.5f)
Vector2newL1=newVector2(pos.x-dir.x*posLerp,pos.y-dir.y*posLerp);
Vector2newL2=newVector2(newL1.x+dir.x,newL1.y+dir.y);
returnnewLine(newL1,newL2);
publicLineMove(Vector2move)
Vector2newL1=newVector2(l1.x+move.x,l1.y+move.y);
returnnewLine(newL1,newVector2(newL1.x+dir.x,newL1.y+dir.y));
publicVector2LerpPos(floatlerp)
returnnewVector2(l1.x+dir.x*lerp,l1.y+dir.y*lerp);
publicLineGetPerpendicular(floatlineLerp=0)
returnRotate(-90,lineLerp);
publicfloatGetAngle(Lineother)
returnVector2.Angle(dir,other.dir);
publicstaticLineNewMidDirLine(Vector2center,Vector2dir)
returnnewLine(newVector2(center.x-dir.x*.5f,center.y-dir.y*.5f),
newVector2(center.x+dir.x*.5f,center.y+dir.y*.5f));
publicstaticLineRay(Vector2root,Vector2dir)
returnnewLine(root,root+dir.SetLength(short.MaxValue));
namespaceGeoMath
publicclassQuad
publicVector2TR,BR,BL,TL;
publicVector2this[intindex]
get
switch(index)
default:returnTR;
case1:returnBR;
case2:returnBL;
case3:returnTL;
set
switch(index)
default:TR=value;break;
case1:BR=value;break;
case2:BL=value;break;
case3:TL=value;break;
publicBounds2Dbounds;
privateBounds2DcontainedBounds;
publicvoidSetRect(Vector2pos,Vector2dimensions,floatangle)
TR=pos+newVector2(dimensions.x*.5f,dimensions.y*.5f).Rot(angle);
BR=pos+newVector2(dimensions.x*.5f,dimensions.y*-.5f).Rot(angle);
BL=pos+newVector2(dimensions.x*-.5f,dimensions.y*-.5f).Rot(angle);
TL=pos+newVector2(dimensions.x*-.5f,dimensions.y*.5f).Rot(angle);
CalcBounds();
publicvoidCalcBounds()
bounds=newBounds2D(TR).Add(BR).Add(BL).Add(TL);
floatmaxX=Mathf.Min(TR.x,BR.x);
floatminX=Mathf.Max(BL.x,TL.x);
floatmaxY=Mathf.Min(TL.y,TR.y);
floatminY=Mathf.Max(BR.y,BL.y);
containedBounds=newBounds2D(newVector2(maxX,maxY)).Add(newVector2(maxX,minY))
.Add(newVector2(minX,minY)).Add(newVector2(minX,maxY));
publicboolContains(Vector2point)
returnTri.Contains(TR,BR,BL,point)||Tri.Contains(BL,TL,TR,point);
publicboolIntersects(Bounds2DcheckBounds)
if(!bounds.Intersects(checkBounds))
returnfalse;
if(containedBounds.Intersects(checkBounds))
returntrue;
if(Contains(checkBounds.TR)||Contains(checkBounds.BR)||
Contains(checkBounds.BL)||Contains(checkBounds.TL)||
checkBounds.Contains(TR)||checkBounds.Contains(BR)||
checkBounds.Contains(BL)||checkBounds.Contains(TL))
returntrue;
returnShapeCollision.Intersects(this,checkBounds);
publicboolIntersects(Circlecircle)
Bounds2Db=newBounds2D(circle.center).Pad(circle.radius);
if(!bounds.Intersects(b))
returnfalse;
if(containedBounds.Intersects(b))
returntrue;
returnTri.Contains(TR,BR,BL,circle)||Tri.Contains(BL,TL,TR,circle);
publicboolIntersects(QuadotherQuad)
returnShapeCollision.Intersects(this,otherQuad);
publicvoidExtrude(floatextrude)
Vector2dir1=newVector2(BR.x-TR.x,BR.y-TR.y).normalized;
Vector2dir2=newVector2(BL.x-BR.x,BL.y-BR.y).normalized;
Vector2dir3=newVector2(TL.x-BL.x,TL.y-BL.y).normalized;
Vector2dir4=newVector2(TR.x-TL.x,TR.y-TL.y).normalized;
TR=GetExtrudePoint(TR,dir4,dir1,extrude);
BR=GetExtrudePoint(BR,dir1,dir2,extrude);
BL=GetExtrudePoint(BL,dir2,dir3,extrude);
TL=GetExtrudePoint(TL,dir3,dir4,extrude);
CalcBounds();
privatestaticVector2GetExtrudePoint(Vector2point,Vector2dir1,Vector2dir2,floatextrude)
Vector2nP1=point+newVector2(-dir1.y,dir1.x)*extrude;
Vector2nP2=point+newVector2(-dir2.y,dir2.x)*extrude;
floathalfBetween=(nP2-nP1).magnitude*.5f;
floatangle=Mathf.Acos(halfBetween/extrude);
floatdistance=halfBetween/Mathf.Sin(angle);
returnnP1+dir1*distance;
namespaceGeoMath
publicstaticclassRectangle
publicstaticVector2FitRotationSize(Vector2size,floatangle)
floatfactor=1;
for(intcorner=0;corner<2;corner++)
Vector2point=V2.zero;
Vector2toCorner=newVector2(size.x*(corner==0?.5f:-.5f),size.y*.5f).Rot(angle);
Lineline=newLine(V2.zero,toCorner);
for(intside=0;side<4;side++)
Lineother;
switch(side)
default:
other=newLine(newVector2(-size.x*.5f,size.y*.5f),newVector2(size.x*.5f,size.y*.5f));
break;
case1:
other=newLine(newVector2(size.x*.5f,size.y*.5f),newVector2(size.x*.5f,-size.y*.5f));
break;
case2:
other=newLine(newVector2(size.x*.5f,-size.y*.5f),newVector2(-size.x*.5f,-size.y*.5f));
break;
case3:
other=newLine(newVector2(-size.x*.5f,-size.y*.5f),newVector2(-size.x*.5f,size.y*.5f));
break;
if(line.Contact(other,outpoint))
break;
floatnewFactor=point.magnitude/toCorner.magnitude;
if(newFactor<factor)
factor=newFactor;
returnnewVector2(size.x*factor,size.y*factor);
namespaceGeoMath
publicstaticclassShapeCollision
publicstaticboolIntersects(Quadquad,QuadquadB)
return!AxisProjectionsAreSeperate((quad.TR-quad.TL).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quad.BR-quad.TR).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quad.BL-quad.BR).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quad.TL-quad.BL).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quadB.TR-quadB.TL).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quadB.BR-quadB.TR).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quadB.BL-quadB.BR).Rot90(),quad,quadB)&&
!AxisProjectionsAreSeperate((quadB.TL-quadB.BL).Rot90(),quad,quadB);
publicstaticboolIntersects(Quadquad,Bounds2Dbounds)
return!AxisProjectionsAreSeperate((quad.TR-quad.TL).Rot90(),quad,bounds)&&
!AxisProjectionsAreSeperate((quad.BR-quad.TR).Rot90(),quad,bounds)&&
!AxisProjectionsAreSeperate((quad.BL-quad.BR).Rot90(),quad,bounds)&&
!AxisProjectionsAreSeperate((quad.TL-quad.BL).Rot90(),quad,bounds)&&
!AxisProjectionsAreSeperate(V2.right,quad,bounds)&&
!AxisProjectionsAreSeperate(V2.up,quad,bounds);
privatestaticboolAxisProjectionsAreSeperate(Vector2axis,QuadquadA,QuadquadB)
floatminQuadA,maxQuadA,minQuadB,maxQuadB;
GetProjectionMinMax(axis,quadA,outminQuadA,outmaxQuadA);
GetProjectionMinMax(axis,quadB,outminQuadB,outmaxQuadB);
returnminQuadA>maxQuadB||minQuadB>maxQuadA;
privatestaticboolAxisProjectionsAreSeperate(Vector2axis,QuadquadA,Bounds2Dbounds)
floatminQuad,maxQuad,minBounds,maxBounds;
GetProjectionMinMax(axis,quadA,outminQuad,outmaxQuad);
GetProjectionMinMax(axis,bounds,outminBounds,outmaxBounds);
returnminQuad>maxBounds||minBounds>maxQuad;
privatestaticvoidGetProjectionMinMax(Vector2axis,Quadquad,outfloatmin,outfloatmax)
floatdot=Vector2.Dot(axis,quad.TR);
min=max=dot;
dot=Vector2.Dot(axis,quad.BR);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
dot=Vector2.Dot(axis,quad.BL);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
dot=Vector2.Dot(axis,quad.TL);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
privatestaticvoidGetProjectionMinMax(Vector2axis,Bounds2Dbounds,outfloatmin,outfloatmax)
floatdot=Vector2.Dot(axis,bounds.TR);
min=max=dot;
dot=Vector2.Dot(axis,bounds.BR);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
dot=Vector2.Dot(axis,bounds.BL);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
dot=Vector2.Dot(axis,bounds.TL);
max=Mathf.Max(dot,max);
min=Mathf.Min(dot,min);
publicstaticclassSuperCover
privatestaticreadonlyVector2Int[]cells=newVector2Int[100];
publicstaticVector2Int[]GetLineCells(Vector2p0,Vector2p1,outintcount)
Vector2dir=p1-p0;
floatdx=Mathf.Sqrt(1+Mth.IntPow(dir.y/dir.x,2));
floatdy=Mathf.Sqrt(1+Mth.IntPow(dir.x/dir.y,2));
intcx=Mathf.FloorToInt(p0.x),
cy=Mathf.FloorToInt(p0.y);
intsx=dir.x<0?-1:1;
intsy=dir.y<0?-1:1;
floatox=(dir.x<0?p0.x-cx:cx+1-p0.x)*dx;
floatoy=(dir.y<0?p0.y-cy:cy+1-p0.y)*dy;
floatlength=dir.sqrMagnitude;
intindex=0;
while(true)
cells[index++]=newVector2Int(cx,cy);
if(Mathf.Min(ox*ox,oy*oy)<length)
if(ox<oy)
ox+=dx;
cx+=sx;
else
oy+=dy;
cy+=sy;
else
break;
count=index;
returncells;
namespaceGeoMath
publicstaticclassTri
publicstaticVector2HitPoint,HitNormal;
publicstaticVector2HitNormalInverse{get{return-HitNormal;}}
/*publicstaticboolContains(Vector2p1,Vector2p2,Vector2p3,Vector2point)
boolb1=Sign(point,p1,p2)<0f;
boolb2=Sign(point,p2,p3)<0f;
boolb3=Sign(point,p3,p1)<0f;
returnb1==b2&&(b2==b3);
privatestaticfloatSign(Vector2p1,Vector2p2,Vector2p3)
return(p1.x-p3.x)*(p2.y-p3.y)-(p2.x-p3.x)*(p1.y-p3.y);
publicstaticboolContains(Vector2v1,Vector2v2,Vector2v3,Vector2p)
floatd=(v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y);
floatf1=p.x-v3.x,
f2=p.y-v3.y;
floatw1=((v2.y-v3.y)*f1+(v3.x-v2.x)*f2)/d;
if(w1<0)
returnfalse;
floatw2=((v3.y-v1.y)*f1+(v1.x-v3.x)*f2)/d;
if(w2<0)
returnfalse;
return1-w1-w2>=0;
publicstaticVector3BaryWeight(Vector2v1,Vector2v2,Vector2v3,Vector2p)
floatd=(v2.y-v3.y)*(v1.x-v3.x)+(v3.x-v2.x)*(v1.y-v3.y);
floatf1=p.x-v3.x,
f2=p.y-v3.y;
floatw1=((v2.y-v3.y)*f1+(v3.x-v2.x)*f2)/d;
floatw2=((v3.y-v1.y)*f1+(v1.x-v3.x)*f2)/d;
returnnewVector3(w1,w2,1-w1-w2);
publicstaticboolContains(Vector2p1,Vector2p2,Vector2p3,Circlecircle)
if(circle.Contains(p1))
HitPoint=p1;
HitNormal=(HitPoint-circle.center).normalized;
returntrue;
if(circle.Contains(p2))
HitPoint=p2;
HitNormal=(HitPoint-circle.center).normalized;
returntrue;
if(circle.Contains(p3))
HitPoint=p3;
HitNormal=(HitPoint-circle.center).normalized;
returntrue;
if(Contains(p1,p2,p3,circle.center))
HitPoint=circle.center;
returntrue;
returnIntersectsLine(circle,p1,p2)||IntersectsLine(circle,p2,p3)||IntersectsLine(circle,p3,p1);
privatestaticboolIntersectsLine(Circlecircle,Vector2pointA,Vector2pointB)
Vector2toPoint=newVector2(circle.center.x-pointA.x,circle.center.y-pointA.y);
Vector2toB=newVector2(pointB.x-pointA.x,pointB.y-pointA.y);
floatdot=Vector2.Dot(toPoint,toB);
floatdistOnLine=dot/toB.sqrMagnitude;
if(distOnLine<0||distOnLine>1)
returnfalse;
Vector2pointOnLine=newVector2(pointA.x+toB.x*distOnLine,pointA.y+toB.y*distOnLine);
HitPoint=pointOnLine;
HitNormal=(HitPoint-circle.center).normalized;
returnnewVector2(circle.center.x-pointOnLine.x,circle.center.y-pointOnLine.y).sqrMagnitude<=circle.radius*circle.radius;
publicclassAllTrackMeshes:MonoBehaviour
publicGameObjecttrackMeshPrefab;
privateList<TrackMesh>meshes;
privatevoidUpdate()
if(meshes==null&&GameManager.Running)
meshes=newList<TrackMesh>();
for(inti=0;i<Track.active.Count;i++)
GameObjectgO=Instantiate(trackMeshPrefab,transform);
TrackMeshtM=gO.GetComponent<TrackMesh>();
tM.trackToSkin=Track.active[i].ID;
gO.name=Track.active[i].ID.ToString();
meshes.Add(tM);
namespaceGeneration
[Serializable]
publicpartialclassCell
[Switch("Dev/HideOccluded")]privatestaticboolHideOccluded=true;
publicreadonlyContentfront=newContent(),
back=newContent();
publicreadonlySidePiece[]bgPieces=newSidePiece[1000];
publicintbgPieceCount;
privatereadonlyBounds2D[]solids=newBounds2D[100],edges=newBounds2D[100];
privateintsolidCount,edgeCount;
publicvoidAdd(Elementelement)
(element.side==Side.Front?front:back).Add(element);
if(GameManager.Mode==Mode.Creator)
RefreshOcclusion();
publicvoidRemove(Elementelement)
(element.side==Side.Front?front:back).Remove(element);
if(GameManager.Mode==Mode.Creator)
RefreshOcclusion();
publicvoidAdd(intbgMeshIndex,intside)
bgPieceCount=bgPieces.Add(newSidePiece(bgMeshIndex,side),bgPieceCount);
publicvoidRemove(intbgMeshIndex,intside)
bgPieceCount=bgPieces.ShiftRemove(newSidePiece(bgMeshIndex,side),bgPieceCount);
publicvoidClear()
front.Clear();
back.Clear();
solidCount=0;
privateboolIsOccluded(Bounds2Dbounds)
boolintersectsSolid=false;
for(inti=0;i<solidCount;i++)
if(solids[i].Intersects(bounds))
intersectsSolid=true;
break;
if(intersectsSolid)
for(inti=0;i<edgeCount;i++)
if(edges[i].Intersects(bounds))
returnfalse;
returntrue;
returnfalse;
publicvoidAddBound(Bounds2Dbounds,boolsolid)
if(solid)
solids[solidCount++]=bounds;
else
edges[edgeCount++]=bounds;
RefreshOcclusion();
publicvoidClearOccluders()
solidCount=0;
edgeCount=0;
RefreshOcclusion();
privatevoidRefreshOcclusion()
front.SetOcclusion(this);
back.SetOcclusion(this);
publicstaticVector2IntToCellPos(Vector2position)
returnnewVector2Int(Mathf.FloorToInt(position.x/Level.CellSize),
Mathf.FloorToInt(position.y/Level.CellSize));
publicstaticVector2IntToCellPos(floatx,floaty)
returnnewVector2Int(Mathf.FloorToInt(x/Level.CellSize),
Mathf.FloorToInt(y/Level.CellSize));
publicstaticVector2ToPos(Vector2Intpos)
returnnewVector2(pos.x*Level.CellSize+Level.CellHalfSize,
pos.y*Level.CellSize+Level.CellHalfSize);
publicstaticBounds2DGetBounds(Vector2IntcellPos)
returnnewBounds2D(cellPos*Level.CellSize).Add(cellPos*Level.CellSize+V2.one*Level.CellSize);
publicvoidDrawBGBounds()
intcamSide=(int)GameCam.CurrentSide.Sign;
for(inti=0;i<bgPieceCount;i++)
SidePiecepiece=bgPieces[i];
if(piece.side==camSide||piece.side==0)
PlacerMeshes.DrawPieceBounds(piece.index);
publicpartialclassCell
[Serializable]
publicclassContent
privatereadonlyItem[]items=newItem[100];
publicreadonlyItem[]soloItems=newItem[100];
publicreadonlyTrack[]tracks=newTrack[100];
publicintitemCount,soloItemCount,trackCount;
publicvoidAdd(Elementelement)
if(!Mask.IsTrack.Fits(element.elementType))
itemCount=items.Add((Item)element,itemCount);
soloItemCount=soloItems.Add((Item)element,soloItemCount);
else
Tracktrack=(Track)element;
trackCount=tracks.Add(track,trackCount);
for(inti=0;i<track.itemCount;i++)
itemCount=items.Add(track.items[i],itemCount);
publicvoidRemove(Elementelement)
if(!Mask.IsTrack.Fits(element.elementType))
Itemitem=(Item)element;
if(item.parent==null)
soloItemCount=soloItems.ShiftRemove(item,soloItemCount);
itemCount=items.ShiftRemove(item,itemCount);
else
Tracktrack=(Track)element;
trackCount=tracks.ShiftRemove(track,trackCount);
for(inti=0;i<track.itemCount;i++)
itemCount=items.ShiftRemove(track.items[i],itemCount);
publicvoidClear()
itemCount=0;
soloItemCount=0;
trackCount=0;
publicvoidSetOcclusion(Cellcell)
for(inti=0;i<itemCount;i++)
Itemitem=items[i];
item.isOccluded=HideOccluded&&(Mask.Hide.Fits(item.elementType)||cell.IsOccluded(item.bounds));
for(inti=0;i<trackCount;i++)
Tracktrack=tracks[i];
intsubCount=track.subBoundCount;
boolallSubsOccluded=true;
boolallSubsVisible=true;
for(inte=0;e<subCount;e++)
boolsubIsOccluded=cell.IsOccluded(track.GetSubBound(e).bounds);
track.subOcclusion[e]=subIsOccluded;
if(!subIsOccluded)
allSubsOccluded=false;
else
allSubsVisible=false;
track.allSubsOccluded=allSubsOccluded;
track.allSubsVisible=allSubsVisible;
publicintHit(Bounds2Dbounds2D)
intsoloHit=0;
for(inti=0;i<soloItemCount;i++)
if(bounds2D.Intersects(soloItems[i].bounds))
soloHit=Mathf.Max(soloHit,soloItems[i].elementType==elementType.Bouncy?2:1);
if(soloHit>0)
returnsoloHit;
for(inti=0;i<trackCount;i++)
Tracktrack=tracks[i];
if(bounds2D.Intersects(track.bounds))
boolallGood=false;
for(inte=0;e<track.itemCount;e++)
elementTypeitemType=track.items[e].elementType;
switch(itemType)
caseelementType.Stick:
caseelementType.Stick_SmallTip:
caseelementType.Flower:
caseelementType.Flower2:
caseelementType.Flower3:
caseelementType.DebugCube:
caseelementType.DebugCube2:
caseelementType.Branch:
allGood=true;
break;
if(allGood)
break;
if(allGood)
for(inte=0;e<tracks[i].subBoundCount;e++)
if(bounds2D.Intersects(tracks[i].GetSubBound(e).bounds))
return1;
return0;
[Serializable]
publicstructSidePiece
publicintindex;
publicintside;
publicSidePiece(intindex,intside)
this.index=index;
this.side=side;
publicpartialclassCell
publicstaticintStepID;
publicintid;
publicCell()
id=StepID++;
publicstructMeshPlacement
publicreadonlyVector2pos;
publicreadonlyintpieceInfo;
publicreadonlyHouseGen.CornerIDscorners;
publicreadonlyintside;
publicMeshPlacement(Vector2pos,intpieceInfo,HouseGen.CornerIDscorners,intside)
this.pos=pos;
this.pieceInfo=pieceInfo;
this.corners=corners;
this.side=side;
publicstaticclassEnvironmentor
publicstaticvoidGameLoad()
publicstaticclassItemCheck
publicstaticboolFirstHit(floatstart,floatend,floatstepLength,Clipclip,Itemitem,floatcheckDist,outfloatcheckTime)
checkTime=start;
while(checkTime<end)
Vector2player=clip.BasicPlacement(checkTime).pos;
Vector2getPos=item.GetPos(checkTime);
floatsqrDist=(player-getPos).sqrMagnitude;
if(sqrDist<=checkDist)
floatstep=stepLength*.5f;
checkTime-=step;
for(inte=0;e<5;e++)
player=clip.BasicPlacement(checkTime).pos;
getPos=item.GetPos(checkTime);
sqrDist=(player-getPos).sqrMagnitude;
step*=.5f;
checkTime+=sqrDist<=checkDist?-step:step;
returntrue;
checkTime+=stepLength;
returnfalse;
publicpartialclassLevel:Singleton<Level>
staticLevel()
items=newItem[Item.TotalCount];
tracks=newTrack[MaxActiveElements];
oldItems=newItem[Item.TotalCount];
addedItems=newItem[MaxActiveElements];
removedItems=newItem[MaxActiveElements];
elementCheck=newint[Item.TotalCount+Track.TotalCount];
pieceCheck=newint[10000];
frustumCells=newFrustumCell[Frustum.cellCount];
pieces=newint[10000];
oldPieces=newint[10000];
addedPieces=newint[10000];
removedPieces=newint[10000];
publicenumLevelType{New_Generator,HandMade}
publicLevelTypelevelType;
publicclassFrustumCell
publicVector2IntcellPos;
publicCellcell;
publicCellVisfrontVis,backVis;
publicboolvisible{get{returnfrontVis!=CellVis.None||backVis!=CellVis.None;}}
publicvoidSetCellPos(Vector2IntcellPos)
this.cellPos=cellPos;
cell=ValidCell(cellPos)?Generator.GetCellAt(cellPos):null;
publicstaticreadonlyFrustumCell[]frustumCells;
publicstaticItemStartStick;
publicstaticLevelGeneratorGenerator;
publicstaticreadonlyItem[]items;
privatestaticreadonlyItem[]oldItems,addedItems,removedItems;
publicstaticintitemCount;
publicstaticreadonlyTrack[]tracks;
publicstaticinttrackCount;
privatestaticreadonlyint[]pieces,oldPieces,addedPieces,removedPieces;
privatestaticintpieceCount;
privatestaticreadonlyint[]elementCheck,pieceCheck;
[Switch("Dev/CountUniqueMeshes")]privatestaticboolmeshCounter;
publicstaticvoidGameStart()
Generator.StartGame();
HouseGen.GameStart();
publicstaticvoidClearPieces()
if(pieceCount==0)
return;
PlacerMeshes.UpdateVisiblePieces(addedPieces,0,pieces,pieceCount);
pieceCount=0;
publicstaticvoidClearLevel()
LevelSaveLoad.NewLevel();
Element.ClearAll();
Refresh();
publicstaticIEnumeratorGameLoad()
for(inti=0;i<Frustum.cellCount;i++)
frustumCells[i]=newFrustumCell();
switch(Inst.levelType)
caseLevelType.New_Generator:
Generator=Inst.GetComponent<New_LevelBrain>();
break;
caseLevelType.HandMade:
Generator=Inst.GetComponent<LevelSaveLoad>();
break;
ActorAnimator.GameLoad();
yieldreturnGenerator.LoadGame();
HouseGen.GameLoad();
publicstaticvoidRefresh()
Frustumfrustum=GameCam.frustum;
frustum.Update();
intindex=0;
for(inty=0;y<Frustum.cells;y++)
for(intx=0;x<Frustum.cells;x++)
frustumCells[index++].SetCellPos(newVector2Int(x,y)+frustum.minCell);
for(inti=0;i<Frustum.cellCount;i++)
frustum.SetCellVis(frustumCells[i]);
intoldItemCount=0;
for(inti=0;i<itemCount;i++)
Itemitem=items[i];
intid=item.ID;
if(elementCheck[id]!=-1)
oldItems[oldItemCount++]=item;
elementCheck.Clear();
intoldPieceCount=pieceCount;
for(inti=0;i<pieceCount;i++)
intid=pieces[i];
oldPieces[i]=id;
pieceCheck.Clear();
itemCount=0;
trackCount=0;
pieceCount=0;
Bounds2DcamFront=frustum.frontBounds;
Bounds2DcamBack=frustum.backBounds;
for(inti=0;i<Frustum.cellCount;i++)
if(!frustumCells[i].visible||frustumCells[i].cell==null)
continue;
CellVisfrontVis=frustumCells[i].frontVis;
CellVisbackVis=frustumCells[i].backVis;
Cellcell=frustumCells[i].cell;
for(intside=0;side<2;side++)
Cell.Contentcontent=side==0?cell.front:cell.back;
CellVischeckVis=side==0?frontVis:backVis;
Bounds2DcheckBounds=side==0?camFront:camBack;
intcellItemCount=content.soloItemCount;
for(inte=0;e<cellItemCount;e++)
Itemitem=content.soloItems[e];
if(!item.elementType.ShowThis())
continue;
if(elementCheck[item.ID]==0&&(checkVis==CellVis.All||checkVis==CellVis.Some&&item.bounds.Intersects(checkBounds))&&
IsNotOccluded(item))
items[itemCount++]=item;
elementCheck[item.ID]=1;
boolcamSide=(GameCam.CurrentSide==Side.Front)==(side==0);
intcellTrackCount=content.trackCount;
for(inte=0;e<cellTrackCount;e++)
Tracktrack=content.tracks[e];
if(!camSide&&track.allSubsOccluded||
elementCheck[track.ID]==1||
checkVis==CellVis.None||
!track.bounds.Intersects(checkBounds))
continue;
tracks[trackCount++]=track;
elementCheck[track.ID]=1;
if(checkBounds.Contains(track.bounds)&&(camSide||track.allSubsVisible))
for(intiI=0;iI<track.itemCount;iI++)
Itemitem=track.items[iI];
if(!item.elementType.ShowThis()||elementCheck[item.ID]==1||!IsNotOccluded(item))
continue;
items[itemCount++]=item;
elementCheck[item.ID]=1;
else
track.FillSubBounds(GTime.Now,Mask.AnyThing);
intgotItems=0;
for(intsub=0;sub<track.subBoundCount;sub++)
Track.SubBoundsB=track.GetSubBound(sub);
if(sB.Intersects(checkBounds)&&(camSide||!track.subOcclusion[sub]))
for(intiI=0;iI<sB.itemCount;iI++)
Itemitem=sB.items[iI];
if(!item.elementType.ShowThis())
continue;
if(elementCheck[item.ID]==0&&IsNotOccluded(item))
items[itemCount++]=item;
elementCheck[item.ID]=1;
gotItems++;
if(gotItems>=track.itemCount)
break;
intcamSide=(int)GameCam.CurrentSide.Sign;
for(inte=0;e<cell.bgPieceCount;e++)
Cell.SidePiecepiece=cell.bgPieces[e];
intid=piece.index;
if(pieceCheck[id]==0&&(piece.side==camSide||piece.side==0))
pieceCheck[id]=1;
pieces[pieceCount++]=id;
intaddCount=0;
intremoveCount=0;
for(inti=0;i<oldItemCount;i++)
Itemitem=oldItems[i];
if(elementCheck[item.ID]==0)
removedItems[removeCount++]=item;
else
elementCheck[item.ID]=0;
for(inti=0;i<itemCount;i++)
Itemitem=items[i];
if(elementCheck[item.ID]==1)
addedItems[addCount++]=item;
if(addCount>0||removeCount>0)
if(meshCounter&&Application.isEditor)
ListUniqueMeshes.CountEm();
ActorAnimator.UpdateVisibleActors(addedItems,addCount,removedItems,removeCount);
intaddCount=0;
intremoveCount=0;
for(inti=0;i<oldPieceCount;i++)
intid=oldPieces[i];
if(pieceCheck[id]==0)
removedPieces[removeCount++]=id;
else
pieceCheck[id]=0;
for(inti=0;i<pieceCount;i++)
intid=pieces[i];
if(pieceCheck[id]==1)
addedPieces[addCount++]=id;
if(addCount>0||removeCount>0)
PlacerMeshes.UpdateVisiblePieces(addedPieces,addCount,removedPieces,removeCount);
if(meshCounter&&Application.isEditor&&Input.GetKeyDown(KeyCode.C))
ListUniqueMeshes.ListEm();
publicstaticvoidCantShowItem(Itemitem)
elementCheck[item.ID]=-1;
privatestaticboolIsNotOccluded(Itemitem)
returnitem.side==GameCam.CurrentSide||!item.isOccluded;
publicstaticvoidAddElementToCells(Elementelement)
Search.Cells(element.bounds);
for(inti=0;i<Search.cellCount;i++)
Search.boundCells[i].Add(element);
publicstaticvoidRemoveElementFromCells(Elementelement)
Search.Cells(element.bounds);
for(inti=0;i<Search.cellCount;i++)
Search.boundCells[i].Remove(element);
publicstaticvoidAddBGMeshToCells(intbgMeshIndex,Bounds2Dbounds,intside)
/*CellbestCell=Search.BestCell(bounds);
if(bestCell!=null)
bestCell.Add(bgMeshIndex,side);*/
Search.Cells(bounds);
for(inti=0;i<Search.cellCount;i++)
Search.boundCells[i].Add(bgMeshIndex,side);
publicstaticvoidRemoveBGMeshFromCells(intbgMeshIndex,Bounds2Dbounds,intside)
Search.Cells(bounds);
for(inti=0;i<Search.cellCount;i++)
Search.boundCells[i].Remove(bgMeshIndex,side);
publicstaticboolValidCell(Vector2IntcellPos)
return!(cellPos.x>=cellXmax||cellPos.x<cellXmin||
cellPos.y>=cellYmax||cellPos.y<cellYmin);
publicstaticboolCellIsVisible(intx,inty)
x-=GameCam.frustum.minCell.x;
y-=GameCam.frustum.minCell.y;
returnx>=0&&x<Frustum.cells&&
y>=0&&y<Frustum.cells&&
frustumCells[Frustum.cells*y+x].visible;
publicstaticvoidAddWallBound(Bounds2Dbound,boolsolid)
if(Generator==null)
return;
Search.Cells(bound);
for(inti=0;i<Search.cellCount;i++)
Search.boundCells[i].AddBound(bound,solid);
publicstaticvoidClearOccluders()
if(Generator==null)
return;
Cell[]cells=Generator.Cells;
for(inti=0;i<cells.Length;i++)
cells[i].ClearOccluders();
publicinterfaceLevelGenerator
IEnumeratorLoadGame();
voidStartGame();
CellGetCellAt(Vector2IntcellPos);
voidGetDimensions(outVector2Intmin,outVector2Intmax);
Cell[]Cells{get;}
publicstaticclassSearch
staticSearch()
boundCells=newCell[100];
boundItems=newItem[200];
boundTracks=newTrack[100];
callCheck=newbool[Item.TotalCount+Track.TotalCount];
publicstaticreadonlyCell[]boundCells;
publicstaticreadonlyItem[]boundItems;
publicstaticreadonlyTrack[]boundTracks;
publicstaticintcellCount,itemCount,trackCount,linkCount;
privatestaticreadonlybool[]callCheck;
publicstaticvoidCells(Bounds2Dbounds)
constfloatmulti=1f/Level.CellSize;
intminX=Mathf.Max(Level.cellXmin,Mathf.FloorToInt(bounds.minX*multi));
intmaxX=Mathf.Min(Level.cellXmax,Mathf.FloorToInt(bounds.maxX*multi));
intminY=Mathf.Max(Level.cellYmin,Mathf.FloorToInt(bounds.minY*multi));
intmaxY=Mathf.Min(Level.cellYmax,Mathf.FloorToInt(bounds.maxY*multi));
intxRange=maxX-minX+1;
intyRange=maxY-minY+1;
cellCount=0;
for(inty=0;y<yRange;y++)
for(intx=0;x<xRange;x++)
Cellcell=Level.Generator.GetCellAt(newVector2Int(minX+x,minY+y));
if(cell!=null)
boundCells[cellCount++]=cell;
publicstaticCellBestCell(Bounds2Dbounds)
constfloatmulti=1f/Level.CellSize;
intminX=Mathf.Max(Level.cellXmin,Mathf.FloorToInt(bounds.minX*multi));
intmaxX=Mathf.Min(Level.cellXmax,Mathf.FloorToInt(bounds.maxX*multi));
intminY=Mathf.Max(Level.cellYmin,Mathf.FloorToInt(bounds.minY*multi));
intmaxY=Mathf.Min(Level.cellYmax,Mathf.FloorToInt(bounds.maxY*multi));
intxRange=maxX-minX+1;
intyRange=maxY-minY+1;
CellbestCell=null;
floatbestArea=float.MinValue;
for(inty=0;y<yRange;y++)
for(intx=0;x<xRange;x++)
Vector2IntcellPos=newVector2Int(minX+x,minY+y);
Cellcell=Level.Generator.GetCellAt(cellPos);
if(cell==null)
continue;
floatarea=bounds.OverlapArea(Cell.GetBounds(cellPos));
if(area>bestArea)
bestCell=cell;
bestArea=area;
returnbestCell;
publicstaticvoidItemsAndTracks(Bounds2Dbounds,Sideside,ElementMaskfilter)
callCheck.Clear();
itemCount=trackCount=0;
boolall=filter==Mask.AnyThing;
Cells(bounds);
for(inti=0;i<cellCount;i++)
Cell.Contentcontent=side.front?boundCells[i].front:boundCells[i].back;
intcellItemCount=content.soloItemCount;
for(inte=0;e<cellItemCount;e++)
Itemitem=content.soloItems[e];
if(!callCheck[item.ID]&&
(all||filter.Fits(item.elementType))&&item.bounds.Intersects(bounds))
boundItems[itemCount++]=item;
callCheck[item.ID]=true;
intcellTrackCount=content.trackCount;
for(inte=0;e<cellTrackCount;e++)
if(all||content.tracks[e].AnyItemMatchesMask(filter))
if(!callCheck[content.tracks[e].ID]&&
content.tracks[e].bounds.Intersects(bounds))
boundTracks[trackCount++]=content.tracks[e];
callCheck[content.tracks[e].ID]=true;
publicstaticvoidItems(Bounds2Dbounds,Sideside,floattime,ElementMaskfilter)
callCheck.Clear();
itemCount=0;
boolall=filter==Mask.AnyThing;
Cells(bounds);
for(inti=0;i<cellCount;i++)
Cell.Contentcontent=side.front?boundCells[i].front:boundCells[i].back;
intcellItemCount=content.soloItemCount;
for(inte=0;e<cellItemCount;e++)
Itemitem=content.soloItems[e];
if(!callCheck[item.ID]&&
(all||filter.Fits(item.elementType))&&item.bounds.Intersects(bounds))
boundItems[itemCount++]=item;
callCheck[item.ID]=true;
intcellTrackCount=content.trackCount;
for(inte=0;e<cellTrackCount;e++)
Tracktrack=content.tracks[e];
if(!callCheck[track.ID]&&
(all||track.AnyItemMatchesMask(filter))&&
track.bounds.Intersects(bounds))
callCheck[content.tracks[e].ID]=true;
if(track.subBoundCount==1)
for(intf=0;f<track.itemCount;f++)
Itemitem=track.items[f];
if(filter.Fits(item.elementType)&&!callCheck[item.ID])
boundItems[itemCount++]=item;
callCheck[item.ID]=true;
else
boolprepearedTrack=false;
intgotItems=0;
for(intsubBound=0;subBound<track.subBoundCount;subBound++)
Track.SubBoundsB=track.GetSubBound(subBound);
if(sB.Intersects(bounds))
if(!prepearedTrack)
track.FillSubBounds(time,filter);
prepearedTrack=true;
for(intsubI=0;subI<sB.itemCount;subI++)
Itemitem=sB.items[subI];
if(!callCheck[item.ID])
boundItems[itemCount++]=item;
callCheck[item.ID]=true;
gotItems++;
if(gotItems>=track.itemCount)
break;
publicstaticvoidTracks(Bounds2Dbounds,Sideside)
callCheck.Clear();
trackCount=0;
Cells(bounds);
for(inti=0;i<cellCount;i++)
Cell.Contentcontent=side.front?boundCells[i].front:boundCells[i].back;
intcellTrackCount=content.trackCount;
for(inte=0;e<cellTrackCount;e++)
if(!callCheck[content.tracks[e].ID]&&
content.tracks[e].bounds.Intersects(bounds))
boundTracks[trackCount++]=content.tracks[e];
callCheck[content.tracks[e].ID]=true;
/*publicstaticvoidLinks(Bounds2Dbounds,Sideside)
linkCount=0;
callID++;
Cells(bounds);
for(inti=0;i<cellCount;i++)
Cellcell=boundCells[i];
for(inte=0;e<cell.links.Count;e++)
intcheckID=cell.links[e].ID+Item.TotalCount+Track.TotalCount;
if(callCheck[checkID]!=callID&&cell.links[e].bounds.Intersects(bounds))
boundLinks[linkCount++]=cell.links[e];
callCheck[checkID]=callID;
publicstaticItemClosestItem(Vector2pos,floattime,Sideside,ElementMaskfilter)
Bounds2Db=newBounds2D(pos).Pad(Level.CellSize*.5f);
Items(b,side,time,filter);
floatclosestItemDistance=float.MaxValue;
ItemclosestItem=null;
for(inti=0;i<itemCount;i++)
floatsqrtDistance=(boundItems[i].GetLagPos(time)-pos).sqrMagnitude;
if(sqrtDistance<closestItemDistance)
closestItemDistance=sqrtDistance;
closestItem=boundItems[i];
returnclosestItem;
publicstaticTrackClosestTrack(Vector2pos,floattime,Sideside)
Bounds2Db=newBounds2D(pos).Pad(Level.CellSize*.5f);
Tracks(b,side);
floatclosestTrackDistance=float.MaxValue;
TrackclosestTrack=null;
for(inti=0;i<trackCount;i++)
floatsqrtDistance=(boundTracks[i].rootPos-pos).sqrMagnitude;
if(sqrtDistance<closestTrackDistance)
closestTrackDistance=sqrtDistance;
closestTrack=boundTracks[i];
returnclosestTrack;
publicstaticTrackClosestTrack(Vector2pos,Sideside)
Bounds2Db=newBounds2D(pos).Pad(Level.CellSize*.5f);
Tracks(b,side);
floatclosestTrackDistance=float.MaxValue;
TrackclosestTrack=null;
for(inti=0;i<trackCount;i++)
floatsqrtDistance=(boundTracks[i].GetClosestPoint(pos)-pos).sqrMagnitude;
if(sqrtDistance<closestTrackDistance)
closestTrackDistance=sqrtDistance;
closestTrack=boundTracks[i];
returnclosestTrack;
publicstaticElementClosestElement(Vector2pos,floattime,Sideside,ElementMaskmask,outVector2closestPoint)
closestPoint=pos;
if(mask==null)
returnnull;
Bounds2Db=newBounds2D(pos).Pad(Level.CellSize*.5f);
if(mask==Mask.IsTrack)
Tracks(b,side);
floatclosestTrackDistance=float.MaxValue;
TrackclosestTrack=null;
for(inti=0;i<trackCount;i++)
Vector2closestTrackPoint=boundTracks[i].GetClosestPoint(pos);
Vector2dir=pos-closestTrackPoint;
floatdir_M=dir.magnitude;
floatdistance=Mathf.Max(0,dir_M-boundTracks[i].maxItemRadius);
if(distance<closestTrackDistance)
closestTrackDistance=distance;
closestTrack=boundTracks[i];
closestPoint=closestTrackPoint+dir*(1f/dir_M*boundTracks[i].maxItemRadius);
returnclosestTrack;
Items(b,side,time,mask);
floatclosestItemDistance=float.MaxValue;
ItemclosestItem=null;
for(inti=0;i<itemCount;i++)
Vector2itemPos=boundItems[i].GetPos(time);
Vector2dir=pos-itemPos;
floatdistance=Mathf.Max(0,dir.magnitude-boundItems[i].radius);
if(distance<closestItemDistance)
closestItemDistance=distance;
closestItem=boundItems[i];
closestPoint=itemPos+dir.SetLength(boundItems[i].radius);
returnclosestItem;
publicstaticclassLevelDebug
[Switch("Elements/ItemInfo")]privatestaticboolshowItemInfo=false;
[Switch("Elements/FluffInfo")]privatestaticboolshowFluffInfo=false;
[Switch("Elements/CollectableInfo")]privatestaticboolshowCollectableInfo=false;
[Switch("Elements/TrackInfo")]privatestaticboolshowTrackInfo=false;
[Switch("Elements/Tracks")]privatestaticboolshowTracks=false;
[Switch("Elements/Links")]privatestaticboolshowLinks=false;
[Switch("Elements/StartStick")]privatestaticboolmarkStartStick=false;
[Switch("Level/ShowHeightPlanes")]privatestaticboolshowHeightPlanes=false;
[Switch("Bounds/Elements")]privatestaticboolshowBounds=false;
[Switch("Bounds/Cells")]privatestaticboolshowCells=false;
[Switch("Bounds/CellItemIDs")]privatestaticboolshowCellItems=false;
[Switch("Bounds/CellTrackIDs")]privatestaticboolshowCellTracks=false;
[Switch("Bounds/FilledSubCells")]privatestaticboolshowSubCells=false;
[Switch("Bounds/Occluder")]privatestaticboolshowOccluders=false;
[Switch("Bounds/TrackSub")]privatestaticboolsubBounds=false;
[Switch("Dev/OutOfBounds")]privatestaticbooloutOfBoundsItem=false;
publicstaticvoidDebugUpdate()
if(!GameManager.Running)
return;
if(showItemInfo&&Level.items!=null)
ShowItemIDS(Mask.IsItem);
if(showFluffInfo&&Level.items!=null)
ShowItemIDS(Mask.IsFluff);
if(showCollectableInfo&&Level.items!=null)
ShowItemIDS(Mask.IsCollectable);
if(showBounds&&Level.items!=null)
ShowItemBounds();
if(ElementEdit.element!=null&&!Creator.currentFilter.Fits(ElementEdit.elementType))
ElementEdit.element.Draw();
if(showTracks||GameManager.Mode==Mode.Creator&&Creator.currentFilter==Mask.IsTrack)
ShowTracks();
if(GameManager.Mode==Mode.Creator&&(Creator.currentFilter==Mask.IsItem||
Creator.currentFilter==Mask.IsFluff||
Creator.currentFilter==Mask.IsCollectable))
ShowItems();
if(showTrackInfo)
ShowTrackInfo();
if(showBounds&&Level.tracks!=null)
ShowTrackBounds();
if(subBounds&&Level.tracks!=null)
ShowSubBounds();
if(showLinks||GameManager.Mode==Mode.Creator)
ShowLinks();
if(showHeightPlanes)
ShowFloor();
if(showCells)
ShowCells();
if(showSubCells)
ShowSubCells();
if(showCellItems||showCellTracks)
ShowCellElementIDs();
if(showOccluders)
ShowOccluders();
if(markStartStick||GameManager.Mode==Mode.Creator)
ShowStartStick();
if(outOfBoundsItem&&GTime.Paused)
ShowOutOfBounds();
privatestaticvoidShowOccluders()
intcount=OccluderPacking.cellPosBounds.Length;
for(inti=0;i<count;i++)
OccluderPacking.cellPosBounds[i].Draw();
privatestaticvoidShowItemIDS(ElementMaskmask)
floatdepth=mask==Mask.IsFluff?Z.W:Z.P;
for(inti=0;i<Level.itemCount;i++)
Itemitem=Level.items[i];
if(Level.items[i].side.IsVisible&&mask.Fits(item.elementType))
Colorc=ActorAnim.DebugTextColor(item);
DRAW.Text(item.ID.ToString("D3"),item.GetLagPos(GTime.Now),c,1.5f,offset:V2.down*3,z:depth);
DRAW.Text(item.elementType.ToString(),item.GetLagPos(GTime.Now),c,1.5f,offset:V2.down*5,z:depth);
/*DRAW.GUI_Text(item.ID.ToString("D3")+"\n"+item.elementType.ToString(),item.GetLagPos(GTime.Now).V3(depth),c,1.5f);*/
privatestaticvoidShowItemBounds()
for(inti=0;i<Level.itemCount;i++)
if(!Level.items[i].side.IsVisible||Level.items[i].parent!=null)
continue;
Colorc=Level.items[i].elementType.DebugColor();
Level.items[i].bounds.Draw().SetColor(c).SetDepth(Z.W10);
privatestaticvoidShowTrackBounds()
for(inti=0;i<Level.trackCount;i++)
if(!Level.tracks[i].side.IsVisible)
continue;
Tracktrack=Level.tracks[i];
Colorc=track.elementType.DebugColor();
track.bounds.Draw().SetColor(c).SetDepth(Z.W10);
privatestaticvoidShowTrackInfo()
for(inti=0;i<Level.trackCount;i++)
if(Level.tracks[i].side.IsVisible)
Tracktrack=Level.tracks[i];
DRAW.Text(track.ID+"Speed:"+track.speed.ToString("F0"),track.center,Color.white,1.5f,offset:V2.down*3,z:Z.P);
DRAW.Text("Items:"+track.itemCount+(track.side.front?"F":"B"),track.center,Color.white,1.5f,offset:V2.down*5,z:Z.P);
privatestaticvoidShowSubBounds()
Colora=COLOR.green.lime;
Colorb=COLOR.red.tomato;
floatmulti=Mth.SmoothPP(.25f,1,GTime.Now*2f);
for(inti=0;i<Level.trackCount;i++)
if(!Level.tracks[i].side.IsVisible)
continue;
Tracktrack=Level.tracks[i];
inthighlightBound;
if(track.itemCount==0)
highlightBound=(int)Mathf.Repeat(Mathf.Floor(GTime.Now*.25f),track.subBoundCount);
else
highlightBound=track.SubIndex(track.SubStep(track.items[0],GTime.Now));
for(inte=0;e<track.subBoundCount;e++)
Bounds2DdrawBounds=track.GetSubBound(e).bounds;
boolisHighlighted=highlightBound==e;
Colorcolor=isHighlighted?Color.white:track.subOcclusion[e]?b:a;
drawBounds.Draw().SetColor(color).SetDepth(Z.W10).Fill(isHighlighted?.1f:0);
track.FillSubBounds(GTime.Now,Mask.AnyThing);
for(inte=0;e<track.itemCount;e++)
Itemitem=track.items[e];
if(track.ItemIsInSubBound(item,highlightBound))
Vector2pos=item.GetPos(GTime.Now);
floatradius=item.radius;
DRAW.Circle(pos,radius,20).SetColor(Color.white).SetDepth(Z.W30);
DRAW.Circle(pos,radius*(1+multi*2),20).SetColor(Color.white.A(.5f)).SetDepth(Z.W30).Fill(.1f);
DRAW.Circle(pos,radius*(1+multi*4),20).SetColor(Color.white.A(.25f)).SetDepth(Z.W30);
privatestaticvoidShowFloor()
Vector2camP=GameCam.CurrentPos;
constfloatmulti=Height.Factor*100;
floatmin=Mathf.Floor(camP.y/multi)*multi;
floatmax=Mathf.Ceil(camP.y/multi)*multi;
for(inti=0;i<2;i++)
floaty=i==0?min:max;
Vector2a=newVector3(-500,y,0),dir=V3.right*1000;
for(inte=0;e<5;e++)
DRAW.Vector(a,dir).SetColor(Color.Lerp(COLOR.orange.coral,COLOR.yellow.fresh,e*(1f/6))).SetDepth(DRAW.WallZ(e+1));
DRAW.Vector(a,dir).SetColor(Color.Lerp(COLOR.purple.violet,COLOR.blue.cornflower,e*(1f/6))).SetDepth(-DRAW.WallZ(e+1));
privatestaticvoidShowCells()
Vector2IntcamCellPos=Cell.ToCellPos(GameCam.frustum.focusPoint);
Cell.GetBounds(camCellPos).Pad(-.4f).Draw().SetColor(Color.magenta).SetDepth(Z.W20);
CellcamCell=Level.Generator.GetCellAt(camCellPos);
if(camCell!=null)
camCell.DrawBGBounds();
return;
for(inti=0;i<Frustum.cellCount;i++)
if(!Level.ValidCell(Level.frustumCells[i].cellPos)||Level.frustumCells[i].cell==null)
continue;
Cellcell=Level.frustumCells[i].cell;
Cell.Contentcontent=GameCam.CurrentSide.front?cell.front:cell.back;
CellViscellVis=GameCam.CurrentSide.front?Level.frustumCells[i].frontVis:
Level.frustumCells[i].backVis;
Colorcolor;
switch(cellVis)
default:color=COLOR.yellow.fresh;break;
caseCellVis.Some:color=COLOR.green.spring.A(.5f);break;
caseCellVis.All:color=COLOR.purple.orchid.A(.75f);break;
Vector2IntcellPos=Level.frustumCells[i].cellPos;
Bounds2DcellBounds=Cell.GetBounds(cellPos);
if(content.itemCount>0)
cellBounds.Draw(.95f).SetColor(color).SetDepth(Z.W05).Fill(cellVis!=CellVis.None?0:.25f);
else
DRAW.GapRectangle(cellBounds.Center,cellBounds.Size*.78f,1).
SetColor(color).SetDepth(Z.W05);
privatestaticvoidShowSubCells()
for(inti=0;i<Frustum.cellCount;i++)
if(!Level.ValidCell(Level.frustumCells[i].cellPos)||Level.frustumCells[i].cell==null)
continue;
Cellcell=Level.frustumCells[i].cell;
Cell.Contentcontent=GameCam.CurrentSide.front?cell.front:cell.back;
if(content.itemCount==0)
continue;
Vector2cellPos=Level.frustumCells[i].cellPos;
newBounds2D(cellPos*Level.CellSize).
Add((cellPos+V2.one)*Level.CellSize).
DrawSubDiv(7,7,.95f).
SetColor(Color.white.PerlinColor(cellPos.x,cellPos.y,.3f)).
SetDepth(Z.W+Mathf.Sign(Z.W)*1).
Fill(.75f,true);
privatestaticvoidShowCellElementIDs()
InitStrings();
Vector2drawOffset=Vector2.one*Level.CellSize*.5f;
for(inti=0;i<Frustum.cellCount;i++)
if(!Level.ValidCell(Level.frustumCells[i].cellPos)||Level.frustumCells[i].cell==null)
continue;
Cellcell=Level.frustumCells[i].cell;
Cell.Contentcontent=GameCam.CurrentSide.front?cell.front:cell.back;
cellStrings[i].Append("<color=white>").Append(Level.frustumCells[i].cellPos).Append("</color>\n");
introws=1;
if(showCellItems)
cellStrings[i].Append("<color=yellow>");
Item[]items=content.soloItems;
intcount=content.soloItemCount;
for(intj=0;j<count;j++)
if(items[j].side!=GameCam.CurrentSide)
continue;
boolnewRow=(j+1)%5==0&&j!=0;
boolcreateSpace=!newRow&&j!=count-1;
cellStrings[i].Append(items[j].ID.ToString("D3"));
if(createSpace)
cellStrings[i].Append("");
if(newRow)
cellStrings[i].Append(System.Environment.NewLine);
rows++;
cellStrings[i].Append("</color>");
cellStrings[i].Append(System.Environment.NewLine);
if(showCellTracks)
rows++;
if(showCellTracks)
cellStrings[i].Append("<color=orange>");
Track[]tracks=content.tracks;
inttrackCount=content.trackCount;
for(intj=0;j<trackCount;j++)
if(tracks[j].side!=GameCam.CurrentSide)
continue;
boolnewRow=(j+1)%5==0&&j!=0;
boolcreateSpace=!newRow&&j!=trackCount-1;
cellStrings[i].Append(tracks[j].ID.ToString("D3"));
if(createSpace)
cellStrings[i].Append("");
if(newRow)
cellStrings[i].Append(System.Environment.NewLine);
rows++;
cellStrings[i].Append("</color>");
DRAW.Text(cellStrings[i].ToString(),Level.frustumCells[i].cellPos*Level.CellSize+drawOffset,Color.white,1.65f,
offset:V2.up*(-3+rows/1.65f*.55f),z:Z.W10);
privatestaticStringBuilder[]cellStrings;
privatestaticvoidInitStrings()
if(cellStrings==null)
cellStrings=newStringBuilder[Frustum.cellCount];
for(inti=0;i<Frustum.cellCount;i++)
cellStrings[i]=newStringBuilder(200);
for(inti=0;i<cellStrings.Length;i++)
cellStrings[i].Length=0;
privatestaticvoidShowItems()
for(inti=0;i<Level.itemCount;i++)
Itemitem=Level.items[i];
if(item.side.IsVisible&&(Creator.currentFilter.Fits(item.elementType)||LevelCheck.Overlapping(item)))
item.Draw();
privatestaticvoidShowTracks()
for(inti=0;i<Level.trackCount;i++)
Tracktrack=Level.tracks[i];
if(track.side.IsVisible)
track.Draw();
privatestaticvoidShowLinks()
Clipclip=Spinner.CurrentFocusClip;
if(clip==null)
return;
ItemswingItem=clip.Type.IsAnySwing()?((Swing)clip).GetStick(GTime.Now).Item:null;
List<Link>links=GameCam.CurrentSide.front?Link.frontLinks:Link.backLinks;
intcount=links.Count;
for(inti=0;i<count;i++)
links[i].Draw(swingItem);
privatestaticvoidShowStartStick()
if(Level.StartStick!=null&&Level.StartStick.side.IsVisible)
Vector2pos=Level.StartStick.GetPos(GTime.Now);
DRAW.ZappCircle(pos,1f,.8f,10,Time.realtimeSinceStartup*60).SetDepth(Z.W05).Fill(.2f);
privatestaticvoidShowOutOfBounds()
for(inti=0;i<Level.trackCount;i++)
Tracktrack=Level.tracks[i];
if(track.side.IsVisible)
for(intj=0;j<track.itemCount;j++)
Vector2pos=track.items[j].GetLagPos(GTime.Now);
Bounds2Db=newBounds2D(pos).Pad(track.items[j].radius);
if(!track.items[j].bounds.Contains(b))
floatr=track.items[j].radius;
DRAW.MultiCircle(pos,r*10,4,r*2,16).SetColor(Color.red).SetDepth(Z.P);
publicstaticvoidShowHitPoint()
if(UI_Manager.HitUI||Input.GetKey(KeyCode.LeftAlt))
return;
Colorc=LevelCheck.ClosestElement!=null?LevelCheck.GetColor(LevelCheck.ClosestElement):Color.white;
floatdotRadius=Mathf.SmoothStep(.1f,.3f,Mathf.PingPong(Time.realtimeSinceStartup*2,1));
DRAW.Circle(Level.HitPoint,dotRadius,20).SetColor(c).SetDepth(Z.W05).Fill(1);
if(LevelCheck.ClosestElement!=null)
Vector2dir=LevelCheck.ElementPoint-Level.HitPoint;
DRAW.Arrow(Level.HitPoint,dir,.2f).SetColor(c).SetDepth(Z.W05).Fill(1);
if(LevelCheck.ClosestLink!=Link.None)
Vector2dir=LevelCheck.LinkPoint-Level.HitPoint;
DRAW.GapVector(Level.HitPoint,dir,5).SetColor(Color.white).SetDepth(Z.W05).Fill(1);
publicstaticclassLevelDevFilter
[Switch("Level/ShowCollectables")]privatestaticboolLoadCollectables=true;
[Switch("Level/ShowFlowers")]privatestaticboolLoadFlowers=true;
publicstaticboolShowThis(thiselementTypevalue)
if(!LoadCollectables&&Mask.IsCollectable.Fits(value))
returnfalse;
returnLoadFlowers||!Mask.IsFluff.Fits(value);//!Mask.HidingShakeFluff.Fits(value)&&!Mask.ShakeFluff.Fits(value));
publicpartialclassLevel
publicconstintcellXmin=-15,cellXmax=15,cellYmin=0,cellYmax=30;
publicconstintCellSize=15;//15
publicconstfloatCellHalfSize=CellSize*.5f;
publicconstfloatPlacementRadius=2f;
publicconstintMaxActiveElements=400;
publicconstfloatWallDepth=1.55f;//2.8f;//1.6f;//2.5f;//3f;//.05f;//5f;//Lowest:.05fOld:3.5f//
publicconstfloatPlaneOffset=2.5f;
publicconstfloatBorderDepth=WallDepth+PlaneOffset*2;
publicstaticfloatGetWallDist(Sideside,floatoffset=0)
returnside.Sign*(WallDepth+offset);
publicstaticfloatGetPlaneDist(Sideside,floatoffset=0)
returnside.Sign*(WallDepth+PlaneOffset+offset);
publicstaticVector3GamePlane(Sideside)
returnnewVector3(0,0,GetPlaneDist(side));
privatestaticinthitPointFrame;
privatestaticVector2cachedHitpoint;
publicstaticVector2HitPoint
get
if(hitPointFrame!=Time.frameCount)
hitPointFrame=Time.frameCount;
RayfingerRay=GameCam.Cam.ScreenPointToRay(Input.mousePosition);
floatmulti=(Mathf.Abs(fingerRay.origin.z)-WallDepth)/Mathf.Abs(fingerRay.direction.z);
cachedHitpoint=fingerRay.origin+fingerRay.direction*multi;
returncachedHitpoint;
[CreateAssetMenu]
publicclassLevelList:ScriptableObject
publicList<LevelSaveFile>levels;
publicintFirstFreeID
get
intID=0;
while(true)
boolalreadyGiven=false;
for(inti=0;i<levels.Count;i++)
if(levels[i]!=null&&levels[i].levelID==ID)
alreadyGiven=true;
break;
if(!alreadyGiven)
break;
ID++;
returnID;
publicboolIsNewLevelSave(stringlevelName)
for(inti=0;i<levels.Count;i++)
if(levels[i]!=null&&levels[i].name==levelName)
returnfalse;
returntrue;
publicvoidSaveLevel(stringlevelName,byte[]bytes)
stringpath="Assets/Resources/SavedLevels/"+levelName+".asset";
LevelSaveFilesaveFile=AssetDatabase.LoadAssetAtPath<LevelSaveFile>(path);
if(saveFile!=null)
saveFile.bytes=bytes;
saveFile.levelID=FirstFreeID;
EditorUtility.SetDirty(saveFile);
AssetDatabase.SaveAssets();
return;
saveFile=CreateInstance<LevelSaveFile>();
saveFile.bytes=bytes;
saveFile.levelID=FirstFreeID;
AssetDatabase.CreateAsset(saveFile,path);
boolusedEmptySlot=false;
for(inti=0;i<levels.Count;i++)
if(levels[i]==null)
levels[i]=saveFile;
usedEmptySlot=true;
if(!usedEmptySlot)
levels.Add(saveFile);
EditorUtility.SetDirty(this);
AssetDatabase.SaveAssets();
publicLevelSaveFileGetLevel(stringlevelName)
for(inti=0;i<levels.Count;i++)
if(levels[i]!=null&&levels[i].name==levelName)
returnlevels[i];
returnlevels[0];
publicLevelSaveFileGetOtherLevel(stringlevelName)
List<LevelSaveFile>otherList=newList<LevelSaveFile>();
for(inti=0;i<levels.Count;i++)
if(levels[i]!=null&&levels[i].name!=levelName)
otherList.Add(levels[i]);
returnotherList.Count>0?otherList[Random.Range(0,otherList.Count)]
:GetLevel(levelName);
publicLevelSaveFileGetFirstLevel()
for(inti=0;i<levels.Count;i++)
if(levels[i]!=null)
returnlevels[i];
returnnull;
publicclassLevelSaveFile:ScriptableObject
publicintlevelID;
publicbyte[]bytes;
publicclassLevelSaveLoad:MonoBehaviour,LevelGenerator
privateconstfloatcheckTime=20;
staticLevelSaveLoad()
cells=CollectionInit.Array<Cell>(cellCount);
publicclassLevelData
privateLevelData(intlevelID)
this.levelID=levelID;
privatereadonlyintlevelID;
privateVector2startPos=newVector2(0,10);
privateSidestartSide=Side.Front;
privateVector2camPos;
privatefloatcamZoom;
privateSidecamSide;
privatestructItemData
privatereadonlyelementTypeitemType;
privatereadonlySideside;
privatereadonlyVector2pos;
publicItemData(BinaryReaderreader)
itemType=(elementType)reader.ReadInt32();
side=reader.ReadSide();
pos=reader.ReadVector2();
publicItemData(elementTypeitemType,Sideside,Vector2pos)
this.itemType=itemType;
this.side=side;
this.pos=pos;
publicvoidSetupItem()
Item.GetFreeItem.SetType(itemType).SetRootPos(pos).SetSide(side).Refresh();
privatereadonlyList<ItemData>itemData=newList<ItemData>();
privatestructTrackData
privatereadonlyVector2pos;
privatereadonlySideside;
privatereadonlyelementTypetrackType;
privatereadonlyfloatangle,size,offset,speed,completion;
privatereadonlyelementType[]itemTypes;
publicTrackData(BinaryReaderreader)
intitemCount=reader.ReadInt32();
itemTypes=newelementType[itemCount];
for(inte=0;e<itemCount;e++)
itemTypes[e]=(elementType)reader.ReadInt32();
pos=reader.ReadVector2();
side=reader.ReadSide();
trackType=(elementType)reader.ReadInt32();
angle=reader.ReadSingle();
size=reader.ReadSingle();
offset=reader.ReadSingle();
speed=reader.ReadSingle();
completion=reader.ReadSingle();
publicvoidSetupTrack()
if(itemTypes.Length==0)
return;
Tracktrack=Track.GetNewTrack(trackType);
track.SetRootPos(pos);
track.angle=angle;
track.size=size;
track.offset=offset;
track.side=side;
track.speed=speed;
track.growth=completion;
for(inti=0;i<itemTypes.Length;i++)
Itemitem=Item.GetFreeItem;
item.SetType(itemTypes[i]);
track.ParentThis(item);
track.ScanAndRefesh();
track.Refresh();
privatereadonlyList<TrackData>trackData=newList<TrackData>();
privatestructLinkData
privatereadonlylinkTypetype;
privatereadonlyboolaIsItem,bIsItem;
privatereadonlyVector2aPos,bPos;
privatereadonlySideaSide,bSide;
publicLinkData(BinaryReaderreader)
type=(linkType)reader.ReadInt32();
aIsItem=reader.ReadBoolean();
aPos=reader.ReadVector2();
aSide=reader.ReadSide();
bIsItem=reader.ReadBoolean();
bPos=reader.ReadVector2();
bSide=reader.ReadSide();
publicvoidSetupLink()
Elementa=aIsItem?
Search.ClosestItem(aPos,checkTime,aSide,Mask.AnyThing):
(Element)Search.ClosestTrack(aPos,checkTime,aSide);
Elementb=bIsItem?
Search.ClosestItem(bPos,checkTime,bSide,Mask.AnyThing):
(Element)Search.ClosestTrack(bPos,checkTime,bSide);
if(a==null||b==null)
Debug.Log("LinkSetup!!!".B_Red());
Debug.LogFormat("{0}and{1}",a==null?"AisNull":"AisFine",b==null?"BisNull":"BisFine");
Debug.LogFormat("{0}and{1}",aIsItem?"AisItem":"AisTrack",bIsItem?"BisItem":"BisTrack");
Link.Create(type,a,b);
privatereadonlyList<LinkData>linkData=newList<LinkData>();
publicstaticLevelDataNew
get
LevelDatalevelData=newLevelData(UI_LevelList.levelList.FirstFreeID);
levelData.itemData.Add(newItemData(elementType.Stick,levelData.startSide,levelData.startPos));
returnlevelData;
publicstaticLevelDataCreate(intlevelID,byte[]bytes)
LevelDataload=newLevelData(levelID);
intitemCount=reader.ReadInt32();
for(inti=0;i<itemCount;i++)
load.itemData.Add(newItemData(reader));
inttrackCount=reader.ReadInt32();
for(inti=0;i<trackCount;i++)
load.trackData.Add(newTrackData(reader));
intconnectionCount=reader.ReadInt32();
for(inti=0;i<connectionCount;i++)
load.linkData.Add(newLinkData(reader));
load.startPos=reader.ReadVector2();
load.startSide=reader.ReadSide();
load.camPos=reader.ReadVector2();
load.camZoom=reader.ReadSingle();
load.camSide=reader.ReadSide();
returnload;
publicvoidInitLevel(Cell[]cells)
LevelSeed.LevelID=levelID;
for(inti=0;i<itemData.Count;i++)
itemData[i].SetupItem();
for(inti=0;i<trackData.Count;i++)
trackData[i].SetupTrack();
for(inti=0;i<linkData.Count;i++)
linkData[i].SetupLink();
Level.StartStick=Search.ClosestItem(startPos,checkTime,startSide,Mask.AnyThing);
GameCam.SetStartValues(camPos,camZoom,camSide);
/*//RefreshCellOcclusion//
intcellCount=cells.Length;
for(inti=0;i<cellCount;i++)
cells[i].RefreshOcclusion();*/
publicstaticbyte[]Save(ItemstartStick,Item[]items,Track[]tracks,Link[]links,Vector3camPos,floatzoom,Sideside)
writer.Write(items.Length);
for(inti=0;i<items.Length;i++)
writer.Write((int)items[i].elementType);
writer.Write(items[i].side);
writer.Write(items[i].rootPos);
writer.Write(tracks.Length);
for(inti=0;i<tracks.Length;i++)
writer.Write(tracks[i].itemCount);
for(inte=0;e<tracks[i].itemCount;e++)
writer.Write((int)tracks[i].items[e].elementType);
writer.Write(tracks[i].rootPos);
writer.Write(tracks[i].side);
writer.Write((int)tracks[i].elementType);
writer.Write(tracks[i].angle);
writer.Write(tracks[i].size);
writer.Write(tracks[i].offset);
writer.Write(tracks[i].speed);
writer.Write(tracks[i].growth);
writer.Write(links.Length);
for(inti=0;i<links.Length;i++)
writer.Write((int)links[i].linkType);
writer.Write(Mask.AnyThing.Fits(links[i].a.elementType));
writer.Write(links[i].a.GetPos(checkTime));
writer.Write(links[i].a.side);
writer.Write(Mask.AnyThing.Fits(links[i].b.elementType));
writer.Write(links[i].b.GetPos(checkTime));
writer.Write(links[i].b.side);
writer.Write(startStick.GetPos(checkTime));
writer.Write(startStick.side);
writer.Write(camPos);
writer.Write(zoom);
writer.Write(side);
returnm.ToArray();
[Switch("Level/First")]privatestaticboolFirstLevel=false;
[Switch("Level/Random")]privatestaticboolRandomLevel=false;
privateconstintcellXmin=-15,cellXmax=15,cellYmin=0,cellYmax=30;
privateconstintxCells=cellXmax-cellXmin;
privateconstintyCells=cellYmax-cellYmin;
privateconstintcellCount=xCells*yCells;
publicvoidGetDimensions(outVector2Intmin,outVector2Intmax)
min=newVector2Int(cellXmin,cellYmin);
max=newVector2Int(cellXmax,cellYmax);
privatestaticreadonlyCell[]cells;
publicCell[]Cells
get{returncells;}
privatestaticLevelListlevelList;
publicstaticLevelListLevelList{get{returnlevelList?levelList:levelList=Resources.Load("SavedLevels/_LevelList")asLevelList;}}
publicstaticstringCurrentLevel="";
privatestaticstringLastLevel="";
privatestaticLevelDatadata;
publicIEnumeratorLoadGame()
if(GameManager.Mode!=Mode.Creator)
if(RandomLevel)
CurrentLevel=LevelList.GetOtherLevel("").name;
yieldbreak;
if(FirstLevel)
CurrentLevel=LevelList.GetFirstLevel().name;
yieldbreak;
UI_Manager.Show_LevelList(true);
while(CurrentLevel=="")
yieldreturnnull;
UI_Manager.Show_LevelList(false);
publicvoidStartGame()
if(LastLevel==CurrentLevel)
return;
Element.ClearAll();
for(inti=0;i<cellCount;i++)
cells[i].Clear();
if(CurrentLevel==UI_LevelList.NewLevel)
LevelData.New.InitLevel(cells);
return;
if(LastLevel!=CurrentLevel)
LevelSaveFilesaveFile=LevelList.GetLevel(CurrentLevel);
data=LevelData.Create(saveFile.levelID,saveFile.bytes);
data.InitLevel(cells);
LastLevel=CurrentLevel;
publicstaticvoidNewLevel()
for(inti=0;i<cellCount;i++)
cells[i].Clear();
CurrentLevel="";
publicCellGetCellAt(Vector2IntcellPos)
intnum=cellPos.x-cellXmin+(cellPos.y-cellYmin)*xCells;
if(num<0||num>=cellCount)
returnnull;
returncells[num];
publicstaticvoidSaveLevel(stringsaveName)
List<Item>activeItems=Item.active;
intcount=activeItems.Count;
for(inti=0;i<count;i++)
if(activeItems[i].parent!=null)
activeItems.RemoveAt(i);
count--;
i--;
Track[]activeTracks=Track.active.ToArray();
Debug.LogFormat("{0}ItemsTotal".B_Orange(),Item.Count);
Debug.LogFormat("{0}ItemsSaved".B_Orange(),activeItems.Count);
Debug.LogFormat("{0}TracksSaved".B_Yellow(),activeTracks.Length);
Debug.LogFormat("{0}LinksSaved".B_Pink(),Link.allLinks.Count);
Debug.LogFormat("CamPos:{0}".B_Salmon(),GameCam.CurrentPos);
Debug.LogFormat("CamZoom:{0}".B_Salmon(),GameCam.CurrentDolly);
Debug.LogFormat("CamSide:{0}".B_Salmon(),GameCam.CurrentSide);
List<string>bounds=newList<string>();
for(inti=0;i<activeItems.Count;i++)
if(Mask.Debug.Fits(activeItems[i].elementType))
bounds.Add(activeItems[i].bounds.GetString()+activeItems[i].GetIdAndSideInfo());
for(inti=0;i<activeTracks.Length;i++)
Tracktrack=activeTracks[i];
boolanyGood=false;
for(intj=0;j<track.itemCount;j++)
if(Mask.Debug.Fits(track.items[j].elementType))
anyGood=true;
break;
if(!anyGood)
continue;
stringtrackInfo=track.GetIdAndSideInfo();
for(ints=0;s<track.subBoundCount;s++)
bounds.Add(track.GetSubBound(s).bounds.GetString()+trackInfo);
ResourceTxt.Write("AllBounds",bounds.ToArray());
levelList.SaveLevel(saveName,LevelData.Save(Level.StartStick,activeItems.ToArray(),activeTracks,Link.allLinks.ToArray(),GameCam.CurrentPos,GameCam.CurrentDolly,GameCam.CurrentSide));
publicstaticboolNewSaveFile(stringlevelName)
returnlevelList.IsNewLevelSave(levelName);
publicstaticclassLevelSeed
privatestaticVector2levelRange;
privatestaticint[]levelExeptions;
publicstaticintLevelID;
publicenumlinkType
Jump=0,
Path=1,
Action=2,
Warp=3,
Look=5
publicstructLink
publicreadonlylinkTypelinkType;
publicreadonlyElementa,b;
privateLink(linkTypelinkType,Elementa,Elementb)
this.linkType=linkType;
this.a=a;
this.b=b;
publicElementGetOther(Elementelement)
returnelement==a?b:a;
publicvoidOnSwing(Swingswing)
if(swing.spinner.isPlayer)
switch(linkType)
caselinkType.Jump:DrumRoll.Start(a,b);break;
caselinkType.Action:ActorAnimator.ActorAction(b);break;
switch(linkType)
caselinkType.Warp:swing.SetWarp((Item)b);break;
publicstaticvoidCreate(linkTypelinkType,Elementa,Elementb)
Linklink=newLink(linkType,a,b);
a.AddLink(link);
b.AddLink(link);
if(Application.isMobilePlatform)
return;
allLinks.Add(link);
if(a.side==b.side)
(a.side==Side.Front?frontLinks:backLinks).Add(link);
publicstaticvoidDelete(Linklink)
link.a.RemoveLink(link);
link.b.RemoveLink(link);
if(Application.isMobilePlatform)
return;
for(inti=0;i<allLinks.Count;i++)
if(allLinks[i]==link)
allLinks.RemoveAt(i);
i--;
for(inti=0;i<frontLinks.Count;i++)
if(frontLinks[i]==link)
frontLinks.RemoveAt(i);
i--;
for(inti=0;i<backLinks.Count;i++)
if(backLinks[i]==link)
backLinks.RemoveAt(i);
i--;
publicstaticbooloperator==(Linklink,Linkother)
returnlink.a==other.a&&link.b==other.b&&link.linkType==other.linkType;
publicstaticbooloperator!=(Linklink,Linkother)
return!(link==other);
publicvoidDraw(ItemswingItem)
Vector2pA=a.GetPos(GTime.Now);
Vector2pB=b.GetPos(GTime.Now);
if(newBounds2D(pA).Add(pB).Intersects(a.side.front?GameCam.frustum.frontBounds:GameCam.frustum.backBounds))
if(linkType==linkType.Jump&&!DrumRoll.IsActive(a))
return;
boolhighlighted=GameManager.Mode==Mode.Creator&&LevelCheck.ClosestLink==this||
GameManager.Mode!=Mode.Creator&&swingItem==a;
DrawArrow(pA,pB,linkType,highlighted,basItem);
publicstaticvoidDrawArrow(Vector2pA,Vector2pB,linkTypelinkType,boolhighLight,Itemitem=null)
Colorc=linkType.Color().Multi(highLight?1.75f:1);
Vector2dir=pB-pA;
if(item!=null)
floatdir_M=dir.magnitude;
dir*=1f/dir_M*(dir_M-item.radius);
floatarrowTip=highLight?Mth.SmoothPP(.5f,.8f,Time.realtimeSinceStartup*6):.5f;
switch(linkType)
default:
DRAW.ZappArrow(pA,dir,arrowTip,14,.65f,4).SetColor(c).SetDepth(Z.W05).Fill(.5f);
break;
caselinkType.Path:
DRAW.ZappArrow(pA,dir,arrowTip,24,.45f,4).SetColor(c).SetDepth(Z.W05).Fill(.5f);
break;
caselinkType.Look:
DRAW.ZappArrow(pA,dir,arrowTip,6,1,4).SetColor(c).SetDepth(Z.W05).Fill(.5f);
break;
caselinkType.Warp:
DRAW.Arrow(pA,dir,arrowTip).SetColor(c).SetDepth(Z.W05).Fill(.5f);
break;
caselinkType.Action:
DRAW.ZappArrow(pA,dir,arrowTip,10,.3f,4).SetColor(c).SetDepth(Z.W05).Fill(.5f);
break;
publicstaticLinkNone;
publicstaticreadonlyList<Link>allLinks,frontLinks,backLinks;
staticLink()
None=newLink();
allLinks=newList<Link>(10000);
frontLinks=newList<Link>(10000);
backLinks=newList<Link>(10000);
publicstaticclassDrumRoll
privatestaticElementjumpingFrom,jumpingTo;
privatestaticSound.SoundObjectrollSound;
privatestaticreadonlyint[]active=newint[Item.TotalCount+Track.TotalCount];
privatestaticintgameID;
publicstaticvoidGameStart()
gameID++;
publicstaticvoidStart(ElementjumpFrom,ElementjumpTo)
if(active[jumpFrom.ID]!=gameID)
jumpingFrom=jumpFrom;
jumpingTo=jumpTo;
if(rollSound==null)
rollSound=Sound.Get(Audio.Reaction.DrummRoll).Loop().Fade(.9f).Play();
publicstaticvoidJump()
if(rollSound!=null)
rollSound.Stop();
rollSound=null;
Sound.Get(Audio.Reaction.SnareHit).Play();
publicstaticvoidSwing(ElementjumpTo)
if(jumpTo==jumpingTo)
Sound.Get(Audio.Reaction.CymbalHit).Volume(1,.125f).Pitch(1,.01f).Play();
active[jumpingFrom.ID]=gameID;
jumpingFrom=null;
jumpingTo=null;
publicstaticboolIsActive(ElementjumpFrom)
returnactive[jumpFrom.ID]!=gameID;
publicstaticclassWarp
publicconstfloatwarpTime=.5f;
publicstaticclassLinkTypeExt
publicstaticColorColor(thislinkTypelinkType)
switch(linkType)
default:returnCOLOR.blue.cornflower;
caselinkType.Warp:returnCOLOR.orange.coral;
caselinkType.Look:returnCOLOR.green.spring;
caselinkType.Path:returnCOLOR.purple.maroon;
caselinkType.Action:returnCOLOR.red.tomato;
publicstaticclassListUniqueMeshes
privatestaticintmax;
privatestaticreadonlyList<UniqueMesh>meshes=newList<UniqueMesh>();
privatestaticreadonlyList<string>lines=newList<string>();
publicstaticvoidCountEm()
for(inti=0;i<meshes.Count;i++)
meshes[i].Reset();
MeshFilter[]filter=SceneLocator.Level.GetComponentsInChildren<MeshFilter>();
for(inti=0;i<filter.Length;i++)
if(filter[i].gameObject.activeInHierarchy)
stringname=filter[i].mesh.name;
boolnewMesh=true;
intuniqueMeshCount=meshes.Count;
for(inte=0;e<uniqueMeshCount;e++)
if(meshes[e].SameMesh(name))
newMesh=false;
break;
if(newMesh)
meshes.Add(newUniqueMesh(name));
if(filter.Length>max)
max=Mathf.Max(max,filter.Length);
intuniqueMeshCount=meshes.Count;
for(inti=0;i<uniqueMeshCount;i++)
meshes[i].Save();
publicstaticvoidListEm()
lines.Clear();
lines.Add("TotalMeshCount:"+max);
lines.Add("");
intuniqueMeshCount=meshes.Count;
intlongestName=0;
for(inti=0;i<uniqueMeshCount;i++)
longestName=Mathf.Max(longestName,meshes[i].name.Length);
intmeshesToList=uniqueMeshCount;
while(meshesToList>0)
intmost=-1;
UniqueMeshmostInstances=null;
for(inti=0;i<uniqueMeshCount;i++)
if(meshes[i].saved>most)
most=meshes[i].saved;
mostInstances=meshes[i];
lines.Add(mostInstances.GetLine(longestName));
mostInstances.saved=-1;
meshesToList--;
DesktopTxt.Write("UniqueMeshes",lines.ToArray(),".spn");
privateclassUniqueMesh
publicreadonlystringname;
privateintmax;
publicintcount,saved;
publicUniqueMesh(stringname)
this.name=name;
count=1;
max=1;
publicvoidReset()
count=0;
publicboolSameMesh(stringname)
if(this.name==name)
count++;
max=Mathf.Max(max,count);
returntrue;
returnfalse;
publicvoidSave()
saved=count;
publicstringGetLine(intlongestName)
returnname.PadRight(longestName)+"|Count:"+saved.ToString().PadLeft(2)+"|Max:"+max.ToString().PadLeft(2);
publicstructSide
publicstaticreadonlySideFront=newSide(true);
publicstaticreadonlySideBack=newSide(false);
publicSide(boolfront){this.front=front;}
publicSide(sbytesign){front=sign==-1;}
publicreadonlyboolfront;
publicfloatSign{get{returnMap(1f,-1f);}}
publicboolIsVisible{get{returnthis==GameCam.CurrentSide;}}
privatefloatMap(floatnegative,floatpositive)
returnfront?positive:negative;
publicintMap(intnegative,intpositive)
returnfront?positive:negative;
publicfloatFloat(floatvalue)
returnMathf.Abs(value)*Sign;
publicstaticbooloperator==(Sideone,Sidetwo)
returnone.front==two.front;
publicstaticSideoperator!(Sideold)
returnnewSide(!old.front);
publicstaticbooloperator!=(Sideone,Sidetwo)
returnone.front!=two.front;
privateboolEquals(Sideother)
returnother.front==front;
publicoverrideboolEquals(objectobj)
if(ReferenceEquals(null,obj))
returnfalse;
returnobjisSide&&Equals((Side)obj);
publicoverrideintGetHashCode()
return0;
publicoverridestringToString()
returnfront?"Side-Front":"Side_Back";
publicclassStaticBounceLight:MonoBehaviour
publicColorcolor;
publicfloatmulti;
privateSpriteRenderersR;
privatevoidAwake()
sR=GetComponent<SpriteRenderer>();
privatevoidLateUpdate()
if(GameManager.Running)
sR.color=(color*LightingSet.SunColor*multi*(GameCam.CurrentSide.front?1:.5f)).A(0);
publicclassTimedLightSource:MonoBehaviour
publicboolfront;
privatefloatrandomness;
privateSpriteRenderersR;
privatevoidAwake()
constfloatrange=.005f;
randomness=Random.Range(-range,range);
sR=GetComponent<SpriteRenderer>();
privatevoidLateUpdate()
if(GameManager.Running)
sR.enabled=front==GameCam.CurrentSide.front&&
Mathf.PingPong(SunDir.DayTimeLerp*2,1)+randomness<.1f;
publicclassTrackMesh:MonoBehaviour
publicinttrackToSkin;
privateTracktrack;
privatereadonlyShapeshape=newShape();
[Space(10)]
publicOutlineoutline;
publicOutlineshadowOutline;
publicMeshtip;
[Range(0,100)]publicfloattesselation;
publicbytematCap;
privateGameObjectshadow;
privateMeshmesh,shadowMesh;
privatevoidAwake()
mesh=newMesh();
shadowMesh=newMesh();
GetComponent<MeshFilter>().mesh=mesh;
shadow=transform.GetChild(0).gameObject;
shadow.GetComponent<MeshFilter>().mesh=shadowMesh;
constfloatm=1.2f;
shadowOutline.vertices[0]=newVector3(outline.width*.5f+m,shadowOutline.vertices[0].y,shadowOutline.vertices[0].z);
shadowOutline.vertices[1]=newVector3(outline.width*.5f,shadowOutline.vertices[1].y,shadowOutline.vertices[1].z);
shadowOutline.vertices[2]=newVector3(outline.width*-.5f,shadowOutline.vertices[2].y,shadowOutline.vertices[2].z);
shadowOutline.vertices[3]=newVector3(outline.width*-.5f-m,shadowOutline.vertices[3].y,shadowOutline.vertices[3].z);
publicvoidSkin(Tracktrack)
this.track=track;
track.TellShapeWhatToDo(shape);
byteshadowMask=((byte)0).Set(true,false,true);
Color32c=newColor32(GetHeightColor(track),matCap,shadowMask,0);
outline.GenerateShapeMesh(shape,mesh,tesselation,c,Level.WallDepth*(track.side.front?-1:1),tip);
shadowOutline.GenerateShadowMesh(shape,shadowMesh,tesselation/2);
transform.localScale=newVector3(1,1,1);
shadow.gameObject.layer=track.side.front?Layers.ShadowA:Layers.ShadowB;
privatevoidUpdate()
if(GameManager.Running&&track==null&&trackToSkin!=0)
Skin(Track.Get(trackToSkin));
privatestaticbyteGetHeightColor(Tracktrack)
returnLevelColors[(int)Mathf.Repeat(track.ID*.5f,LevelColors.Length)];
privatestaticreadonlybyte[]LevelColors={19,20,21,23,24,25};
[CustomEditor(typeof(TrackMesh))]
publicclassTrackMeshEditor:Editor
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.Space(10);
if(Application.isPlaying&&GUILayout.Button("SkinTrack"))
TrackMeshtM=targetasTrackMesh;
Tracktrack=Track.Get(tM.trackToSkin);
if(track!=null)
tM.Skin(track);
publicclassVectorCompare:MonoBehaviour
voidUpdate()
Vector3dir=Quaternion.AngleAxis(Random.Range(0,360f),Vector3.forward)*Vector3.up*(Time.frameCount%100==0?0:Random.Range(0,200f));
floatdir_M=dir.magnitude;
Vector3dir_N=dir.normalized;
Vector3dir_Div=dir*(1f/dir_M);
if(dir_N!=dir_Div)
Debug.Log(dir_N.ToString("F4")+"!="+dir_Div.ToString("F4"));
publicclassActor:MonoBehaviour
publicTransformpivot;
publicItemitem;
privatebool_front;
privateGameObject_gameObject;
protectedTransform_transform;
[HideInInspector]publicGameObject[]hidden;
[HideInInspector]publicShadow[]shadows;
protectedActorAnimanim;
protectedboolHasToUpdate()
anim=ActorAnim.GetAnim(item);
returnitem.parent!=null||anim!=null||GameManager.Mode==Mode.Creator;
publicvirtualvoidSetup()
_gameObject=gameObject;
_transform=transform;
_transform.rotation=Rot.Y(180);
_gameObject.SetActive(false);
publicvirtualvoidSetItem(Itemitem)
this.item=item;
if(item!=null)
Profiler.BeginSample(item.elementType.Name());
if(!_gameObject.activeInHierarchy)
_gameObject.SetActive(true);
if(_front!=item.side.front)
_front=item.side.front;
_transform.rotation=Rot.Y(item.side.front?0:180);
for(inti=0;i<shadows.Length;i++)
shadows[i].SetSide(_front);
for(inti=0;i<hidden.Length;i++)
hidden[i].layer=_front?Layers.MainA:Layers.MainB;
Profiler.EndSample();
else
if(_gameObject.activeInHierarchy)
_gameObject.SetActive(false);
publicvirtualvoidSetTransform(boolforcedUpdate)
if(!HasToUpdate()&&!forcedUpdate)
ActorAnimator.actorSkips++;
ShadowUpdate(false);
return;
_transform.position=item.GetPos(GTime.Now).V3(Level.WallDepth*item.side.Sign);
ShadowUpdate(true);
protectedvoidShadowUpdate(boolupdateTransform)
for(inti=0;i<shadows.Length;i++)
shadows[i].ShadowUpdate(updateTransform);
publicVector3TipOffset{get;protectedset;}
publicoverrideboolEquals(objectobj)
returnobj!=null&&((Actor)obj).compareID==compareID;
publicoverrideintGetHashCode()
returncompareID;
privatereadonlyintcompareID;
privatestaticintstaticID;
publicActor()
compareID=staticID++;
[CustomEditor(typeof(Actor),true)]
publicclassActorEditor:Editor
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.Space(10);
GUILayout.BeginHorizontal();
GUILayout.FlexibleSpace();
GUI.color=COLOR.red.tomato;
if(GUILayout.Button("Setup",GUILayout.Width(100)))
Editor_PrepareActor((Actor)target);
GUI.color=Color.white;
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
privatestaticvoidEditor_PrepareActor(Actoractor)
Transformtransform=actor.transform;
actor.shadows=transform.GetComponentsInChildren<Shadow>();
for(inti=0;i<actor.shadows.Length;i++)
CastShadowshadow=actor.shadows[i]asCastShadow;
if(shadow!=null)
shadow.actor=actor;
MeshRenderer[]renderers=transform.GetComponentsInChildren<MeshRenderer>(true);
List<GameObject>hidden=newList<GameObject>();
for(inti=0;i<renderers.Length;i++)
renderers[i].gameObject.layer=LayerMask.NameToLayer("Default");
if(renderers[i].gameObject.CompareTag("Hide"))
hidden.Add(renderers[i].gameObject);
actor.hidden=hidden.ToArray();
Debug.Log("Helpingwith"+renderers.Length);
publicclassBouncy:Actor,IElementAction
[Space(10)]
publicMeshColorSwapcolorSwitch;
privatefloat_lerp;
publicoverridevoidSetTransform(boolforcedUpdate)
floatbigLerp=Mathf.PingPong((GTime.Now+(item.ID+1)*.2254f)*GTime.LoopMulti*4,1)*8;
floatsmallLerp=Mathf.Clamp01(bigLerp-6);
floatanimLerp=Mathf.SmoothStep(0,1,1-smallLerp);
if(!HasToUpdate()&&!forcedUpdate&&Mathf.Abs(animLerp-_lerp)<.01f)
ActorAnimator.actorSkips++;
ShadowUpdate(false);
return;
_lerp=animLerp;
Vector2newLean=anim!=null?anim.GetLeanNow():V2.zero;
_transform.position=item.rootPos.V3(Level.WallDepth*item.side.Sign);
QuaternionsideRot=Rot.Y(item.side.front?0:180);
QuaternionleanRot=(newLean*animLerp).LeanRotLocal(item.side);
TipOffset=sideRot*leanRot*newVector3(0,0,6f+3f*animLerp);
pivot.localPosition=leanRot*newVector3(0,0,3f*(1-animLerp));
pivot.localRotation=leanRot;
ShadowUpdate(true);
publicvoidAction()
colorSwitch.onSwitchActorColor();
publicinterfaceIElementAction
voidAction();
publicclassBranch:Stick
publicTransform[]subPivots;
publicoverridevoidSetTransform(boolforcedUpdate)
if(!HasToUpdate()&&!forcedUpdate)
ActorAnimator.actorSkips++;
ShadowUpdate(false);
return;
QuaternionbaseRot=_transform.rotation;
for(inti=0;i<subPivots.Length;i++)
floattime=GTime.Now-.075f*i;
Vector2pos=item.GetPos(time);
Vector2leanPos=item.GetLagPos(time);
Vector2newLean=leanPos-pos+(anim!=null?anim.GetLean(time):V2.zero);
if(i==0)
_transform.position=pos.V3(Level.WallDepth*item.side.Sign);
subPivots[i].rotation=baseRot*newLean.LeanRotLocal(item.side);
continue;
constbooldip=true;
Vector2dipDown=dip?newVector2(0,i*i*-.15f):V2.zero;
QuaternionleanRot=(newLean*(1+i*2)+dipDown).LeanRotLocal(item.side);
subPivots[i].rotation=baseRot*leanRot;
ShadowUpdate(true);
publicclassCoin:Actor
publicconstfloatCollectionLength=.135f;
privateQuaternionitemRot;
publicoverridevoidSetItem(Itemitem)
base.SetItem(item);
if(item!=null)
itemRot=Quaternion.AngleAxis(Mth.SmoothPP(-50,50,item.ID*13.161f),Vector3.forward);
publicoverridevoidSetTransform(boolforcedUpdate)
HasToUpdate();
Vector2animPos=item.GetPos(GTime.Now);
floatoffset=animPos.x*2+animPos.y*2;
pivot.rotation=Rot.Y(GTime.Now*360*GTime.LoopMulti*8+offset*4)*itemRot;
if(Collector.IsCollected(item))
Collector.CollectionStatestate=Collector.collectionStates[item.ID];
floatstart=state.time;
floatend=start+CollectionLength;
floatanimTime=GTime.Now-start;
floatlerp=animTime/(end-start);
if(lerp<1)
Vector2startPos=item.GetPos(start);
if(anim!=null)
startPos+=anim.GetLean(start);
Clipclip=state.spinner.GetClip(end);
Vector2endPos=clip.BasicPlacement(end).pos;
Vector2mV=clip.GetMV(end)*.25f;
floatsmoothLerp=lerp*lerp*.75f;
Vector2pos=Vector2.Lerp(startPos,endPos,smoothLerp);
Vector2mVOffset=mV*animTime*lerp;
_transform.position=(pos+mVOffset).V3(Level.WallDepth*item.side.Sign);
ShadowUpdate(true);
else
_transform.position=V3.away;
return;
if(anim!=null)
animPos+=anim.GetLeanNow();
_transform.position=animPos.V3(Level.WallDepth*item.side.Sign);
ShadowUpdate(true);
publicclassCuby:Actor
publicclassFlower:Stick
privateQuaternionitemRot;
publicoverridevoidSetItem(Itemitem)
base.SetItem(item);
if(item!=null)
itemRot=Quaternion.AngleAxis(Mth.SmoothPP(-50,50,item.ID*13.161f),Vector3.forward);
protectedoverridevoidSetLeanRot(Quaternionrot)
pivot.localRotation=rot*itemRot;
publicclassLeaf:Stick
privateQuaternionitemRot;
publicoverridevoidSetItem(Itemitem)
base.SetItem(item);
/*if(item!=null)
itemRot=Quaternion.Euler(
Mth.SmoothPP(-20,20,item.ID*13.161f),
Mth.SmoothPP(-25,25,item.ID*27.161f),
Mth.SmoothPP(-10,10,item.ID*39.161f));*/
if(item!=null)
itemRot=Quaternion.Euler(
Mth.Repeat(-20,20,item.ID*13.161f),
Mth.Repeat(-35,35,item.ID*27.161f),
Mth.Repeat(-5,5,item.ID*39.161f));
protectedoverridevoidSetLeanRot(Quaternionrot)
pivot.localRotation=rot*itemRot;
publicclassProbe:Stick
publicoverridevoidSetTransform(boolforcedUpdate)
if(!HasToUpdate()&&false&&!forcedUpdate)
ActorAnimator.actorSkips++;
ShadowUpdate(false);
return;
Vector2pos=item.GetPos(GTime.Now);
Vector2leanPos=item.GetLagPos(GTime.Now);
Vector2newLean=leanPos-pos+(anim!=null?anim.GetLeanNow():V2.zero);
_transform.position=(pos+newLean).V3(Level.GetPlaneDist(item.side));
floattiltTime=GTime.Now+.2f;
Vector2tiltLean=(item.GetLagPos(tiltTime)-item.GetPos(tiltTime))*-2
+(anim!=null?anim.GetLean(GTime.Now-.2f):V2.zero);;
QuaternionsideRot=Rot.Y(item.side.front?0:180);
QuaternionleanRot=(tiltLean*3).LeanRotLocal(item.side);
pivot.localRotation=leanRot;
TipOffset=sideRot*leanRot*(Vector3.forward*Level.PlaneOffset);
ShadowUpdate(true);
publicpartialclassScoreStick:Stick
[Space(10)]
publicMeshFilterstick;
publicMesh[]stickLevelMeshes,stickPlayerMeshes;
[Space(10)]
publicMeshFilternob;
publicMesh[]nobLevelMeshes,nobPlayerMeshes;
privatestaticreadonlybyte[]playerColors={18},
levelColors={19,20,21,22,23,24,25};
privatebytecurrentColor;
privateintlevelColor;
publicoverridevoidSetItem(Itemitem)
base.SetItem(item);
if(item!=null)
constfloatmulti=1f/15;
levelColor=(int)Mathf.Repeat(item.rootPos.y*multi+1,stickLevelMeshes.Length);
SetColor();
publicoverridevoidSetTransform(boolforcedUpdate)
base.SetTransform(forcedUpdate);
SetColor();
privatevoidSetColor()
intplayer=states[item.ID].GetPlayer(GTime.Now);
boolusePlayer=player!=-1;
byteuseColor=usePlayer?playerColors[player%playerColors.Length]:levelColors[levelColor];
if(currentColor==useColor)
return;
currentColor=useColor;
stick.mesh=usePlayer?stickPlayerMeshes[player]:stickLevelMeshes[levelColor];
nob.mesh=usePlayer?nobPlayerMeshes[player]:nobLevelMeshes[levelColor];
publicpartialclassScoreStick
staticScoreStick()
states=CollectionInit.Array<State>(Item.TotalCount);
stateChanges=newList<StateChange>(1000);
privatestaticreadonlyState[]states;
privatestaticreadonlyList<StateChange>stateChanges;
publicstaticvoidClearStates()
for(inti=0;i<Item.TotalCount;i++)
states[i].Reset();
publicstaticvoidAddNewState(SwingswingClip)
Itemitem=swingClip.startStick.Item;
StateChangechange=newStateChange(swingClip);
if(states[item.ID].AddChange(change))
stateChanges.Add(change);
publicstaticvoidClearAllAfter(Spinnerspinner,floattime)
intstart=stateChanges.Count-1;
for(inti=start;i>-1;i--)
if(stateChanges[i].time>=time)
if(stateChanges[i].spinnerID==spinner.ID)
states[stateChanges[i].itemID].RemoveChange(stateChanges[i]);
stateChanges.RemoveAt(i);
break;
else
break;
publicstaticvoidTrimm()
floattrimmTime=GTime.Now-GTime.RewindTime;
intcount=stateChanges.Count;
for(inti=0;i<count;i++)
if(stateChanges[i].time<trimmTime)
states[stateChanges[i].itemID].RemoveChange(stateChanges[i]);
stateChanges.RemoveAt(i);
count--;
i--;
else
break;
privateclassState
privateintfirstRecorded,changeCount;
privatereadonlyStateChange[]changes=newStateChange[1000];
publicState()
Reset();
publicvoidReset()
changeCount=0;
firstRecorded=-1;
publicboolAddChange(StateChangechange)
if(changeCount>0)
StateChangelastChange=changes[changeCount-1];
if(lastChange.spinnerID==change.spinnerID||lastChange.time>=change.time)
returnfalse;
changes[changeCount++]=change;
returntrue;
publicvoidRemoveChange(StateChangechange)
for(inti=0;i<changeCount;i++)
if(changes[i]==change)
if(i==0)
firstRecorded=change.spinnerID;
changeCount=changes.ShiftRemoveAt(i,changeCount);
break;
publicintGetPlayer(floattime)
if(changeCount==1&&changes[0].time<=time)
returnchanges[0].spinnerID;
for(inti=0;i<changeCount;i++)
if(changes[i].time>time)
returni==0?firstRecorded:changes[i-1].spinnerID;
returnfirstRecorded;
privatestructStateChange
publicreadonlyintitemID,spinnerID;
publicreadonlyfloattime;
privatereadonlyintpoolID;
publicStateChange(SwingswingClip)
itemID=swingClip.startStick.Item.ID;
spinnerID=swingClip.spinner.ID;
poolID=swingClip.poolID;
time=swingClip.startTime;
publicstaticbooloperator==(StateChangex,StateChangey)
returnx.poolID==y.poolID;
publicstaticbooloperator!=(StateChangex,StateChangey)
returnx.poolID!=y.poolID;
publicclassStick:Actor
publicoverridevoidSetTransform(boolforcedUpdate)
if(!HasToUpdate()&&!forcedUpdate)
ActorAnimator.actorSkips++;
ShadowUpdate(false);
return;
if(anim!=null&&anim.item!=item)
Debug.LogFormat("WrongAnim!{0}isgettingAnimfrom{1}",item.ID,anim.item.ID);
Vector2moveLean;
if(forcedUpdate||item.parent!=null)
Vector2pos=item.GetPos(GTime.Now);
Vector2leanPos=item.GetLagPos(GTime.Now);
_transform.position=pos.V3(Level.WallDepth*item.side.Sign);
moveLean=leanPos-pos;
else
moveLean=Vector2.zero;
Vector2lean=moveLean+(anim!=null?anim.GetLeanNow():V2.zero);
QuaternionsideRot=Rot.Y(item.side.front?0:180);
QuaternionleanRot=lean.LeanRotLocal(item.side);
SetLeanRot(leanRot);
TipOffset=sideRot*leanRot*newVector3(0,0,5);
ShadowUpdate(true);
protectedvirtualvoidSetLeanRot(Quaternionrot)
pivot.localRotation=rot;
publicstaticclassRotHelp
publicstaticQuaternionLeanRotLocal(thisVector2lean,Sideside)
returnQuaternion.FromToRotation(newVector3(0,0,Level.PlaneOffset),
newVector3(lean.x*side.Sign,-lean.y,Level.PlaneOffset));
publicstaticQuaternionLeanRotGlobal(thisVector2lean,Sideside)
returnQuaternion.FromToRotation(newVector3(0,0,Level.PlaneOffset),
newVector3(lean.x*side.Sign,lean.y*side.Sign,Level.PlaneOffset));
publicstaticclassActorAnimator
publicclassActorList
staticActorList()
allActors=newActor[Item.TotalCount];
actorIndex=newint[Item.TotalCount];
setups=newint[Item.TotalCount];
privatereadonlyelementTypeitemType;
privatereadonlyActor[]active;
privatereadonlyStack<Actor>inactive,idle;
publicstaticreadonlyActor[]allActors;
privatestaticreadonlyint[]actorIndex;
privatereadonlyintcapacity;
privateintactiveCount;
privateintmaxActiveActors,requestCount;
privateboolExeededMax{get{returnrequestCount>maxActiveActors;}}
privateintmandatoryShadowUpdate;
privatestaticreadonlyint[]setups;
publicActorList(GameObjectprefab,Transformparent,elementTypeitemType,intamount)
this.itemType=itemType;
capacity=amount;
inactive=newStack<Actor>(amount);
active=newActor[amount];
idle=newStack<Actor>(amount);
for(inti=0;i<amount;i++)
Actoractor=Object.Instantiate(prefab,-V3.up*10000,Rot.Zero,parent).GetComponent<Actor>();
actor.Setup();
inactive.Push(actor);
privatevoidEnableActor(Itemitem)
Actoractor=idle.Count>0?idle.Pop():inactive.Pop();
actorIndex[item.ID]=activeCount;
active[activeCount++]=actor;
actor.SetItem(item);
allActors[item.ID]=actor;
maxActiveActors=Mathf.Max(maxActiveActors,activeCount);
setups[item.ID]=Time.frameCount;
publicvoidDisableIdle()
intcount=idle.Count;
for(inti=0;i<count;i++)
Actoractor=idle.Pop();
inactive.Push(actor);
intitemID=actor.item.ID;
allActors[itemID].SetItem(null);
allActors[itemID]=null;
privatevoidSetIdleActor(Itemitem)
idle.Push(allActors[item.ID]);
intindex=actorIndex[item.ID];
active[index]=active[activeCount-1];
actorIndex[active[index].item.ID]=index;
activeCount--;
publicvoidSetTransform()
if(mandatoryShadowUpdate>activeCount)
mandatoryShadowUpdate=0;
for(inti=0;i<activeCount;i++)
active[i].SetTransform(LightManager.ForceUpdate||mandatoryShadowUpdate==i||setups[active[i].item.ID]==Time.frameCount);
totalAnimActors+=activeCount;
if(!LightManager.ForceUpdate)
mandatoryShadowUpdate++;
publicvoidResetActors()
for(inti=0;i<activeCount;i++)
active[i].SetTransform(true);
publicvoidAdd(Itemitem)
if(activeCount<capacity)
EnableActor(item);
else
Level.CantShowItem(item);
requestCount++;
publicvoidRemove(Itemitem)
SetIdleActor(item);
requestCount--;
publicvoidAddInfo(StringBuilderstringBuilder,boollast)
if(ExeededMax)
stringBuilder.Append(FancyString.B_Start("yellow"));
stringBuilder.Append(itemType.Name().PadRight(Mathf.Max(ElementTypeExt.LongestItemName,ElementTypeExt.LongestFluffName)+1)).
Append(activeCount.PrepString().PadLeft(3)).
Append("/").
Append(capacity.PrepString().PadLeft(3)).
Append(ExeededMax?"<":">").
Append(maxActiveActors.PrepString().PadLeft(3));
if(ExeededMax)
stringBuilder.Append(FancyString.B_End);
if(!last)
stringBuilder.Append("\n");
publicstaticActorList[]actorLists;
privatestaticDictionary<elementType,ActorList>actorListDict;
privatestaticreadonlyItem[]otherSideItems=newItem[Level.MaxActiveElements];
publicstaticintactorSkips,totalAnimActors;
publicstaticvoidGameLoad()
actorListDict=newDictionary<elementType,ActorList>(newelementTypeComparer());
List<ActorList>actorListList=newList<ActorList>();
foreach(elementTypeelementTinEnum.GetValues(typeof(elementType)))
if(elementT.InstanceCount()>0)
GameObjectprefab=Resources.Load("Level/Items/"+elementT)asGameObject;
if(prefab==null)
continue;
Transformparent=Application.isEditor?newGameObject(elementT+"s").transform:null;
if(parent!=null)
if(Mask.IsItem.Fits(elementT))
parent.parent=SceneLocator.Items;
if(Mask.IsFluff.Fits(elementT))
parent.parent=SceneLocator.Fluff;
if(Mask.IsCollectable.Fits(elementT))
parent.parent=SceneLocator.Collectables;
ActorListlist=newActorList(prefab,parent,elementT,elementT.InstanceCount());
actorListList.Add(list);
actorListDict.Add(elementT,list);
actorLists=actorListList.ToArray();
publicstaticvoidGameStart(floatrestartShift)
ActorAnim.GameRestart(restartShift);
ScoreStick.ClearStates();
publicstaticvoidLatePoseSet()
ActorAnim.Trimm();
ScoreStick.Trimm();
Profiler.BeginSample("ActorAnimator.LatePoseSet()");
actorSkips=totalAnimActors=0;
for(inti=0;i<actorLists.Length;i++)
actorLists[i].SetTransform();
Profiler.EndSample();
publicstaticvoidUpdateVisibleActors(Item[]addItems,intaddItemCount,Item[]removeItems,intremoveItemCount)
if(hidden)
return;
Profiler.BeginSample("ActorAnimator.UpdateVisibleActors()");
for(inti=0;i<removeItemCount;i++)
if(removeItems[i].elementType.InstanceCount()>0)
actorListDict[removeItems[i].elementType].Remove(removeItems[i]);
intotherSideCount=0;
for(inti=0;i<addItemCount;i++)
ItemaddItem=addItems[i];
if(addItem.side==GameCam.CurrentSide)
if(addItem.elementType.InstanceCount()>0)
actorListDict[addItem.elementType].Add(addItem);
else
otherSideItems[otherSideCount++]=addItem;
for(inti=0;i<otherSideCount;i++)
ItemaddItem=otherSideItems[i];
if(addItem.elementType.InstanceCount()>0)
actorListDict[addItem.elementType].Add(addItem);
intactorLength=actorLists.Length;
for(inta=0;a<actorLength;a++)
actorLists[a].DisableIdle();
Profiler.EndSample();
publicstaticvoidOnJump(Jumpclip)
if(clip.before==null)
Debug.Log("JumpCliphasnoClipBefore"+clip.spinner.name+""+clip.spinner.ID);
Vector2currentLean=((Swing)clip.before).GetWeightDir(clip.startTime)/clip.stick.Item.mass;
ActorAnim.AddNewShake(Shake.Get(shake.Jump,clip.startTime,clip.stick.Item,currentLean,clip));
FlyByShakes(clip,Mask.MustShake);
Spinner.UpdateOffsets(clip.spinner);
privatestaticvoidFlyByShakes(Jumpclip,ElementMaskfilter)
floatradius=clip.spinner.size.y*.5f;
floatmaxRadius=clip.spinner.size.y*JumpInfo.SearchRange;
JumpInfoinfo=clip.info;
for(inti=0;i<info.proxCount;i++)
ProxItemmiss=info.proxItems[i];
Itemitem=miss.item;
if(!Mask.MustShake.Fits(item.elementType))
continue;
Vector2closestDir=miss.closestDir;
floatclosestDir_M=closestDir.magnitude;
Vector2closestDir_N=closestDir*(1f/closestDir_M);
floatlerp=(1-Mathf.Clamp01(Mathf.InverseLerp(radius,maxRadius,closestDir_M)))*.3f;
if(lerp<.125f)
continue;
Vector2closest=miss.closestMotion;
floatclosest_M=closest.magnitude;
Vector2closest_N=closest*(1f/closest_M);
floatspinSpeed=GPhysics.Get_SpinSpeed_After(clip.startSpin,miss.closestTime-clip.startTime);
floatmagnitude=(closest_M+Mathf.Abs(spinSpeed)*2)*lerp;
Vector2force=magnitude*Vector2.Lerp(closest_N,-closestDir_N,.4f)*3;
floattime=miss.closestTime+closestDir_M*.01f;
ActorAnim.AddNewShake(Shake.Get(shake.FlyBy,time,item,force,clip));
publicstaticvoidOnSwing(Swingclip,boolpriority)
if(priority)
ActorAnim.AddNewShake(Shake.Get(shake.Swing,clip.startTime,clip.startStick.Item,clip.startMotion,clip));
ElementMaskfilter=priority?Mask.ShakeItemasElementMask:Mask.ShakeFluff;
ImpactPulse(clip.startMotion,clip.startTime,clip.startStick.Item,clip,1,filter);
publicstaticvoidOnBump(Bumpclip)
ActorAnim.AddNewShake(Shake.Get(shake.Swing,clip.startTime,clip.bumpItem,-clip.mV,clip));
ImpactPulse(-clip.mV,clip.startTime,clip.bumpItem,clip,8,Mask.MustShake);
privatestaticvoidImpactPulse(Vector2mV,floatimpactTime,Itemitem,Clipclip,floatforceMulti,ElementMaskfilter)
floatmaxRadius=clip.spinner.size.y*JumpInfo.SearchRange*1.5f;
Vector2rootPos=item.GetPos(impactTime);
Bounds2Db=newBounds2D(rootPos).Pad(maxRadius);
Search.Items(b,item.side,impactTime,filter);
floatmV_M=mV.magnitude;
Vector2mV_N=mV*(mV_M>0?1f/mV_M:0);
for(inti=0;i<Search.itemCount;i++)
if(Search.boundItems[i]==item)
continue;
Vector2itemPos=Search.boundItems[i].GetPos(impactTime);
Vector2dir=itemPos-rootPos;
floatdir_M=dir.magnitude;
Vector2dir_N=dir*(1f/dir_M);
floatdot=1+(Vector2.Dot(mV_N,dir_N)*.5f+.5f);
floatlerp=(1-Mathf.Clamp01(dir_M/maxRadius))*.55f*dot*.4f;
if(lerp<.125f)
continue;
Vector2force=dir_N*mV_M*lerp*forceMulti;
floattime=impactTime+dir_M*.035f;
ActorAnim.AddNewShake(Shake.Get(shake.FlyBy,time,Search.boundItems[i],force,clip));
Spinner.UpdateOffsets(clip.spinner);
publicstaticvoidDebugPulse()
constfloatmaxRadius=6*JumpInfo.SearchRange*1.5f;
Rayray=Camera.main.ScreenPointToRay(Input.mousePosition);
Planeplane=newPlane(Vector3.forward*-GameCam.CurrentSide.Sign,newVector3(0,0,Level.WallDepth*GameCam.CurrentSide.Sign));
floatdist;
plane.Raycast(ray,outdist);
Vector3hit=ray.origin+ray.direction*dist;
Vector2rootPos=hit;
Bounds2Db=newBounds2D(rootPos).Pad(maxRadius);
Search.Items(b,GameCam.CurrentSide,GTime.Now,Mask.MustShake);
for(inti=0;i<Search.itemCount;i++)
Itemitem=Search.boundItems[i];
Vector2itemPos=item.GetPos(GTime.Now);
Vector2dir=itemPos-rootPos;
floatlength=dir.magnitude;
floatlerp=(1-Mathf.Clamp01(length/maxRadius))*.55f*.4f;
if(lerp<.125f)
continue;
Vector2force=dir.SetLength(200*lerp*2);
floattime=GTime.Now+length*.035f;
ActorAnim.AddNewShake(Shake.Get(shake.FlyBy,time,item,force,null));
Spinner.UpdateOffsets(null);
publicstaticvoidOnWarp(Swingclip,floattime)
Vector2currentLean=clip.GetWeightDir(time);
ActorAnim.AddNewShake(Shake.Get(shake.WarpAway,time,clip.GetStick(clip.startTime).Item,currentLean,clip));
ActorAnim.AddNewShake(Shake.Get(shake.Swing,time,clip.GetStick(time).Item,V2.zero,clip));
Spinner.UpdateOffsets(clip.spinner);
publicstaticvoidClearAllAfter(Spinnerspinner,floattime)
intcount=ActorAnim.actorAnims.Count;
for(inti=0;i<count;i++)
if(ActorAnim.actorAnims[i].ClearAfter(spinner,time))
ActorAnim.RemoveAnim(i);
i--;
count--;
if(count==0)
break;
publicstaticvoidHideAllBecauseWeMergedMeshes()
hidden=true;
ActorAnim.Clear();
for(inti=0;i<actorLists.Length;i++)
actorLists[i].ResetActors();
privatestaticboolhidden;
publicstaticvoidActorAction(Elementelement)
if(Mask.IsItem.Fits(element.elementType))
Actoractor=ActorList.allActors[element.ID];
if(actor!=null)
((IElementAction)actor).Action();
namespaceActorAnimation
publicpartialclassActorAnim:PoolObject
privatefloatendTime;
publicItemitem;
privateboolnoWeight;
privatereadonlyList<Shake>shakes=newList<Shake>(100);
privateboolCanBeTrimmed{get{returnendTime<=Mathf.Max(0,GTime.Now-GTime.RewindTime)&&GetLeanNow()==V2.zero;}}
privatevoidTrimmShakes()
intcount=shakes.Count;
for(inti=0;i<count;i++)
if(shakes[i].shakeEndTime<GTime.Now-GTime.RewindTime)
shakes.GetRemoveAt(i).Reset();
count--;
i--;
privatevoidReset()
if(item!=null)
itemAnims[item.ID]=null;
item=null;
intcount=shakes.Count;
for(inti=0;i<count;i++)
shakes[i].Reset();
shakes.Clear();
actorAnimPool.Return(this);
privateActorAnimSetup(Shakeshake)
item=shake.item;
itemAnims[item.ID]=this;
noWeight=!Mask.CanBeGrabbed.Fits(shake.item.elementType);
AddShake(shake);
returnthis;
privatevoidAddShake(Shakeshake)
shakes.Add(shake);
if(shake.shakeEndTime>endTime)
endTime=shake.shakeEndTime;
publicboolClearAfter(Spinnerspinner,floattime)
intcount=shakes.Count,countBefore=count;
for(inti=0;i<count;i++)
if(shakes[i].eventTime>=time&&shakes[i].Spinner==spinner)
shakes.GetRemoveAt(i).Reset();
count--;
i--;
if(countBefore!=count)
endTime=0;
for(inti=0;i<count;i++)
if(shakes[i].shakeEndTime>endTime)
endTime=shakes[i].shakeEndTime;
Spinner.UpdateOffsets(spinner);
returncount==0;
publicVector2GetLean(floattime)
Vector2lean=Vector2.zero;
for(inti=0;i<shakes.Count;i++)
shakes[i].GetShake(time,reflean);
if(!noWeight)
intactiveCount=Spinner.active.Count;
for(inti=0;i<activeCount;i++)
Swingswing=Spinner.active[i].GetClip(time)asSwing;
if(swing!=null&&swing.GetStick(time).SameAs(item))
constfloatzFactor=(Level.PlaneOffset/*+spinner.GetZShift(time)*/)/(Level.PlaneOffset*2)*2;
lean+=swing.GetWeightDir(time)*zFactor/item.mass;
floatdampMax=.9f/item.mass;
floatlean_M=lean.magnitude;
returnlean*(lean_M>0?1f/lean_M*Mth.DampedRange(lean_M,0,dampMax):0);
publicVector2GetLeanNow()
Vector2lean=Vector2.zero;
for(inti=0;i<shakes.Count;i++)
shakes[i].GetShake(GTime.Now,reflean);
if(!noWeight)
intactiveCount=Spinner.active.Count;
for(inti=0;i<activeCount;i++)
Swingswing=Spinner.GetSwingClip(i,item);
if(swing!=null)
constfloatzFactor=(Level.PlaneOffset/*+spinner.GetZShift(time)*/)/(Level.PlaneOffset*2)*2;
lean+=swing.GetWeightDir(GTime.Now)*zFactor/item.mass;
floatdampMax=.9f/item.mass;
floatlean_M=lean.magnitude;
returnlean*(lean_M>0?1f/lean_M*Mth.DampedRange(lean_M,0,dampMax):0);
privatevoidRestart(floatrestartShift)
endTime+=restartShift;
intshakeCount=shakes.Count;
for(inti=0;i<shakeCount;i++)
shakes[i].Shift(restartShift);
publicpartialclassActorAnim
staticActorAnim()
actorAnims=newList<ActorAnim>(Level.MaxActiveElements);
actorAnimPool=newPool<ActorAnim>(()=>newActorAnim(),Level.MaxActiveElements*2);
itemAnims=newActorAnim[Item.TotalCount];
publicstaticreadonlyList<ActorAnim>actorAnims;
privatestaticreadonlyPool<ActorAnim>actorAnimPool;
privatestaticreadonlyActorAnim[]itemAnims;
publicstaticvoidTrimm()
intcount=actorAnims.Count;
for(inti=0;i<count;i++)
if(actorAnims[i].CanBeTrimmed)
RemoveAnim(i);
count--;
i--;
else
actorAnims[i].TrimmShakes();
publicstaticvoidRemoveAnim(intindex)
actorAnims.GetRemoveAt(index).Reset();
publicstaticvoidClear()
intcount=actorAnims.Count;
for(inti=0;i<count;i++)
actorAnims[i].Reset();
actorAnims.Clear();
publicstaticvoidGameRestart(floatrestartShift)
intcount=actorAnims.Count;
for(inti=0;i<count;i++)
actorAnims[i].Restart(restartShift);
Trimm();
publicstaticvoidAddNewShake(Shakeshake)
if(itemAnims[shake.item.ID]!=null)
itemAnims[shake.item.ID].AddShake(shake);
else
actorAnims.Add(actorAnimPool.GetFree().Setup(shake));
publicstaticColorDebugTextColor(Itemitem)
if(itemAnims[item.ID]!=null&&itemAnims[item.ID].GetLeanNow()!=V2.zero)
returnitemAnims[item.ID].item==item?Spinner.IsBeingGrabbed(item)?COLOR.orange.sienna:COLOR.yellow.fresh:COLOR.red.tomato;
returnColor.Lerp(Color.white,COLOR.grey.light,.75f);
publicstaticVector2GetLean(Itemitem,floattime)
returnitemAnims[item.ID]==null?V2.zero:itemAnims[item.ID].GetLean(time);
publicstaticActorAnimGetAnim(Itemitem)
returnitemAnims[item.ID]!=null?itemAnims[item.ID]:null;
publicstaticclassCollector
staticCollector()
collectionStates=newCollectionState[Item.TotalCount];
for(inti=0;i<Item.TotalCount;i++)
collectionStates[i]=CollectionState.None;
publicstaticreadonlyCollectionState[]collectionStates;
publicconstfloatStepLength=JumpInfo.StepLength/4;
privatestaticreadonlyList<CollectionState>timelineStates=newList<CollectionState>(100);
privatestaticintvalue;
privatestaticCollectionStatelastState,trimmState;
publicstaticboolIsCollected(Itemitem)
returncollectionStates[item.ID].time<=GTime.Now;
publicstaticvoidGameStart()
for(inti=0;i<Item.TotalCount;i++)
collectionStates[i]=CollectionState.None;
timelineStates.Clear();
value=0;
PillUI.SetPillCount(0);
lastState=CollectionState.None;
trimmState=CollectionState.None;
publicstaticvoidGameUpdate()
intcount=timelineStates.Count;
floatclearBefore=GTime.Now-GTime.RewindTime;
for(inti=0;i<count;i++)
CollectionStatestate=timelineStates[i];
if(state.time<clearBefore)
trimmState=state;
timelineStates.RemoveAt(i);
i--;
count--;
floatbestTime=float.MinValue;
CollectionStatecurrent=trimmState;
for(inti=0;i<count;i++)
CollectionStatestate=timelineStates[i];
if(state.time+Coin.CollectionLength<=GTime.Now&&state.time>bestTime)
bestTime=state.time;
current=state;
if(current!=lastState)
lastState=current;
PillUI.SetPillCount(lastState.index);
publicstaticvoidCollectThings(Jumpjump)
JumpInfoinfo=jump.info;
intproxyCount=info.proxCount;
Spinnerspinner=jump.spinner;
floatspinnerRadius=spinner.size.y*.5f;
intstatesBefore=timelineStates.Count;
for(inti=0;i<proxyCount;i++)
ProxItemproxItem=info.proxItems[i];
Itemitem=proxItem.item;
if(!Mask.IsCollectable.Fits(item.elementType)||proxItem.startTime>=collectionStates[item.ID].time)
continue;
floattriggerDist=Mathf.Pow((spinnerRadius+item.radius)*4f,2);
if(proxItem.closestDist<=triggerDist)
floatcheckDist=Mathf.Pow(spinnerRadius+item.radius,2);
floatend=proxItem.closestTime+JumpInfo.StepLength;
floatcheckTime=Mathf.Max(jump.startTime,proxItem.closestTime-JumpInfo.StepLength*2);
if(ItemCheck.FirstHit(checkTime,end,StepLength,jump,item,checkDist,outcheckTime))
CollectionStatestate=newCollectionState(checkTime,item,spinner);
collectionStates[item.ID]=state;
timelineStates.Add(state);
intcount=timelineStates.Count;
for(inti=statesBefore;i<count;i++)
if(i<count-1)
CollectionStatea=timelineStates[i];
CollectionStateb=timelineStates[i+1];
if(b.time<a.time)
timelineStates[i]=b;
timelineStates[i+1]=a;
i=statesBefore-1;
for(inti=statesBefore;i<count;i++)
value+=timelineStates[i].item.elementType.Value();
timelineStates[i]=timelineStates[i].SetIndex(value);
publicstaticvoidClearAfter(Spinnerspinner,floattime)
intstart=timelineStates.Count-1;
for(inti=start;i>-1;i--)
if(timelineStates[i].CanBeTrimmed(time,spinner))
value-=timelineStates[i].item.elementType.Value();
timelineStates.RemoveAt(i);
else
break;
publicstructCollectionState
publicreadonlyfloattime;
publicreadonlyintindex;
publicreadonlyItemitem;
publicreadonlySpinnerspinner;
publicCollectionState(floattime,Itemitem,Spinnerspinner)
this.time=time;
this.spinner=spinner;
this.item=item;
index=0;
privateCollectionState(floattime,Itemitem,Spinnerspinner,intindex)
this.time=time;
this.spinner=spinner;
this.item=item;
this.index=index;
publicboolCanBeTrimmed(floattime,Spinnerspinner)
booltrimmIt=this.spinner==spinner&&this.time>=time;
if(trimmIt)
collectionStates[item.ID]=None;
returntrimmIt;
publicstaticCollectionStateNone=newCollectionState(float.MaxValue,null,null);
publicstaticbooloperator==(CollectionStatestateA,CollectionStatestateB)
returnstateA.index==stateB.index;
publicstaticbooloperator!=(CollectionStatestateA,CollectionStatestateB)
returnstateA.index!=stateB.index;
publicCollectionStateSetIndex(intindex)
returnnewCollectionState(time,item,spinner,index);
publicstaticclassInteraction
publicstaticvoidSetClip(Clipclip)
if(!clip.hasBeenSet)
Sounds(clip);
EnvironmentResponse(clip);
clip.hasBeenSet=true;
privatestaticvoidEnvironmentResponse(Clipclip)
Boundary.SetNewClip(clip);
switch(clip.Type)
caseClipType.Jump:
ActorAnimator.OnJump(clipasJump);
gotocaseClipType.AirLaunch;
caseClipType.AirLaunch:
Collector.CollectThings(clipasJump);
Swingswing=clip.afterasSwing;
if(swing!=null)
ActorAnimator.OnSwing(swing,true);
Boundary.SetNewClip(clip.after);
Vector3mV=clip.GetMV(swing.startTime);
Vector3charDir=swing.startStick.Item.GetPos(swing.startTime).V3()-clip.BasicPlacement(swing.startTime).pos;
floatspinLerp=swing.spinSpeed*.01f;
floatimpactLerp=mV.magnitude*.0075f;
Vector3mix=Vector3.Slerp(charDir.normalized,mV.normalized,impactLerp);
Poof.Show(swing.spinner,swing.startStick.Item,mix,spinLerp,swing.startTime);
break;
caseClipType.Swing:
if(clip.spinner.isPlayer)
Mood.OnSwing(clip.startTime);
gotocaseClipType.Spawn;
caseClipType.Spawn:
Swingswing=clipasSwing;
swing.startStick.Item.LinkSignal(swing);
ActorAnimator.OnSwing(swing,clip.Type==ClipType.Spawn);
Score.OnSwing(swing);
break;
caseClipType.Bump:
ActorAnimator.OnBump(clipasBump);
break;
caseClipType.Dead:
if(clip.spinner.isPlayer)
Spinner.SetGameOver=true;
else
ByteReplays.LoadRandomReplayFor(clip.spinner);
break;
privatestaticvoidSounds(Clipclip)
switch(clip.Type)
caseClipType.Jump:
Jumpjump=clipasJump;
if(jump.spinner.isPlayer)
DrumRoll.Jump();
floatmulti=jump.jumpV.magnitude*.025f;
floatvolume=multi-Random.Range(.05f,.15f);
floatpitch=.45f+Random.Range(0,.1f)+multi*.4f;
Sound.Get(Audio.Sound.StickJump).Volume(volume).PlayerMulti(clip.spinner).Pitch(pitch).SetItem(jump.stick.Item).Play();
break;
caseClipType.Swing:
Swingswing=clipasSwing;
floatmulti=swing.startMotion.magnitude*.025f;
floatvolume=multi-.02f-Random.Range(.05f,.15f);
floatpitch=1.05f+Random.Range(0,.06f)+multi*.6f;
Sound.Get(Audio.Sound.StickContact).Volume(volume).PlayerMulti(clip.spinner).Pitch(pitch).SetItem(swing.startStick.Item).Play();
gotocaseClipType.Spawn;
caseClipType.Spawn:
Swingswing=clipasSwing;
if(swing.spinner.isPlayer)
DrumRoll.Swing(swing.startStick.Item);
break;
caseClipType.Dead:
Sound.Get(Audio.Sound.DeathHit).Play();
break;
caseClipType.Bump:
Sound.Get(Audio.Sound.DeathHit).PlayerMulti(clip.spinner).SetItem((clipasBump).bumpItem).Play();
break;
namespaceActorAnimation
publicenumshake{Jump=1,Swing=2,WarpAway=3,FlyBy=4}
publicclassShake:PoolObject
staticShake()
shakePool=newPool<Shake>(()=>newShake(),2000);
privatestaticreadonlyPool<Shake>shakePool;
publicstaticShakeGet(shakeshake,floateventTime,Itemitem,Vector2motionV,Clipclip)
returnshakePool.GetFree().Setup(shake,eventTime,item,motionV,clip);
publicfloateventTime,shakeEndTime;
publicItemitem;
privateVector2shakeV;
privatefloatoffset,frequency,duration,itemMass,itemDamp,itemAccel,itemLazyness;
privateClipclip;
publicSpinnerSpinner{get{returnclip!=null?clip.spinner:null;}}
publicvoidReset()
clip=null;
shakePool.Return(this);
privatevoidSetItemParams(elementTypeelementType)
itemMass=elementType.Mass();
itemDamp=elementType.Damp();
itemAccel=elementType.Accel();
itemLazyness=elementType.Lazyness();
privateShakeSetup(shakeshake,floateventTime,Itemitem,Vector2motionV,Clipclip)
this.clip=clip;
this.eventTime=eventTime;
this.item=item;
if(item!=null)
SetItemParams(item.elementType);
else
Debug.Log("ShakeWithoutItem");
floatmaxSpeed=2.5f/itemMass;
constfloattestMulti=1.15f;
constfloatjumpMulti=1.5f;
switch(shake)
caseshake.Jump:
shakeV=motionV*jumpMulti;
floatmagnitude=shakeV.magnitude;
frequency=Mathf.Min(magnitude*15.75f,maxSpeed);
duration=magnitude*25;
offset=Mathf.Asin(1f/jumpMulti)/(2*Mathf.PI);
break;
caseshake.Swing:
shakeV=motionV*.015f/itemMass;
floatmagnitude=shakeV.magnitude*testMulti;
frequency=Mathf.Min(magnitude*7.875f,maxSpeed);
duration=magnitude*25;
offset=0;
break;
caseshake.WarpAway:
shakeV=motionV;
floatmagnitude=shakeV.magnitude*testMulti;
frequency=Mathf.Min(magnitude*15.75f,maxSpeed);
duration=magnitude*25;
offset=.25f;
break;
caseshake.FlyBy:
shakeV=motionV*.005f/itemMass;
floatmagnitude=shakeV.magnitude*testMulti;
frequency=Mathf.Min(magnitude*35.75f,maxSpeed);
duration=magnitude*100;
offset=0;
break;
frequency*=Random.Range(.95f,1.05f);
if(itemAccel<0)
duration=Mathf.Min(duration,1f/Mathf.Abs(itemAccel));
shakeEndTime=eventTime+duration/itemLazyness;
returnthis;
publicvoidGetShake(floattime,refVector2returnVector)
if(time<eventTime||time>shakeEndTime)
return;
floatocci=GPhysics.Oscillate((time-eventTime)*itemLazyness,duration,frequency,itemDamp,itemAccel,offset);
returnVector=newVector2(returnVector.x+occi*shakeV.x,returnVector.y+occi*shakeV.y);
publicvoidShift(floatrestartShift)
eventTime+=restartShift;
shakeEndTime+=restartShift;
namespaceLevelElements
publicclassTrack_Circular:Track
publicTrack_Circular():base(elementType.Circular){}
privatereadonlyMaxima[]maxima=CollectionInit.Array<Maxima>(4);
protectedoverridefloatTrackLength{get{return2*Mathf.PI*radius;}}
privatefloatradius;
protectedoverridevoidCalculateBounds()
center=rootPos;
radius=elementType.DefaultVScale()*size;
bounds=newBounds2D(rootPos).Pad(elementType.DefaultVScale()*size+maxItemRadius);
Vector2dir=shapeVector*(1f/radius);
constfloatlerpRange=1f/360;
for(inti=0;i<4;i++)
Vector2checkDir=V2.up.Rot(i*90);
floatlerp=TurnAngle(dir,checkDir)*lerpRange;
Vector2pos=rootPos+checkDir*radius;
maxima[i].Set(pos,lerp);
CalculateSubBounds(maxima);
protectedoverrideVector2GetTrackPos(floatlerp)
floatrad=lerp*Mth.FullRad;
floatsin=Mathf.Sin(rad);
floatcos=Mathf.Cos(rad);
floattx=shapeVector.x;
floatty=shapeVector.y;
returnnewVector2(cos*tx-sin*ty+rootPos.x,
sin*tx+cos*ty+rootPos.y);
publicoverrideVector2GetClosestPoint(Vector2point)
returnrootPos.AimPos(point,radius);
publicoverridevoidDraw()
ColordrawColor=Mathf.Abs(speed)<1?Color.white:LevelCheck.GetColor(this);
DRAW.Circle(rootPos,radius).SetColor(drawColor).SetDepth(Z.W05);
Vector2offsetDir=(GetChildPos(null,GTime.Now)-rootPos).normalized;
DRAW.Vector(rootPos+offsetDir*shapeVector.magnitude,offsetDir).SetColor(drawColor).SetDepth(Z.W05);
publicoverridevoidTellShapeWhatToDo(Shapeshape)
shape.segmentCount=1;
shape.segments[0].SetPointDir(GetTrackPos(0),Mth.*.5f).SetLengthBend(TrackLength,1);
shape.FinishSetup();
publicclassTrack_PingPong:Track
publicTrack_PingPong():base(elementType.PingPong){}
protectedTrack_PingPong(elementTypeelementType):base(elementType){}
protectedoverridefloatTrackLength{get{returnelementType.DefaultVScale()*size*2;}}
protectedoverridevoidCalculateBounds()
center=rootPos;
bounds=newBounds2D(rootPos-shapeVector*.5f).Add(rootPos+shapeVector*.5f).Pad(maxItemRadius);
CalculateSubBounds();
protectedoverrideVector2GetTrackPos(floatlerp)
lerp-=.5f;
returnnewVector2(shapeVector.x*lerp+rootPos.x,shapeVector.y*lerp+rootPos.y);
protectedoverridefloatGetLerp(floattime,floatitemOffset)
returnMth.SmoothPP(0,1,base.GetLerp(time,itemOffset)*2);
publicoverrideintSubStep(Itemitem,floattime)
floatunclampedLerp=(speed*time*GTime.LoopMulti+item.trackOffset+offset)*2;
intfullSwipeSubs=Mathf.FloorToInt(Mathf.Abs(unclampedLerp))*subBoundCount;
intcurrentSwipeSubs=Mathf.FloorToInt(Mth.SmoothPP(0,subBoundCount,unclampedLerp%1));
returnfullSwipeSubs+currentSwipeSubs;
publicoverrideintSubIndex(intsubStep)
intleftOver=subStep%(subBoundCount*2);
returnleftOver<subBoundCount?leftOver:(subBoundCount-1-(leftOver-subBoundCount))%subBoundCount;
publicoverrideVector2GetClosestPoint(Vector2point)
Vector2half=shapeVector*.5f;
returnnewLine(rootPos-half,rootPos+half).ClosestPoint(point);
publicoverridevoidDraw()
ColordrawColor=LevelCheck.GetColor(this);
DRAW.Vector(rootPos-shapeVector*.5f,shapeVector).SetColor(drawColor).SetDepth(Z.W05);
Vector2offsetPos=GetChildPos(null,GTime.Now);
Vector2offsetDir=shapeVector.Rot(90).normalized;
DRAW.Vector(offsetPos,offsetDir).SetColor(drawColor).SetDepth(Z.W05);
publicoverridevoidTellShapeWhatToDo(Shapeshape)
shape.segmentCount=1;
shape.segments[0].SetPointDir(rootPos-shapeVector*.5f,shapeVector.ToRadian()-Mth.*.5f).SetLengthBend(TrackLength*.5f,0);
shape.FinishSetup();
publicclassTrack_Arc:Track_PingPong
publicTrack_Arc():base(elementType.Arc){}
privatestaticreadonlyMaxima[]maxima=CollectionInit.Array<Maxima>(4);
protectedoverridefloatTrackLength{get{return2*Mathf.PI*radius*growth*2;}}
privatefloatradius;
privateArcarc;
publicoverridevoidReset()
base.Reset();
growth=.5f;
protectedoverridevoidCalculateBounds()
radius=elementType.DefaultVScale()*size;
arc=newArc(rootPos,radius,angle,growth);
center=GetTrackPos(.5f);
bounds=newBounds2D(GetTrackPos(0)).Add(GetTrackPos(1));
Vector2dir=shapeVector.normalized;
floatlerpRange=1f/360/growth;
for(inti=0;i<4;i++)
Vector2checkDir=V2.up.Rot(i*90);
floatlerp=TurnAngle(dir,checkDir)*lerpRange;
Vector2pos=rootPos+checkDir*radius;
maxima[i].Set(pos,lerp);
if(lerp<=1)
bounds=bounds.Add(pos);
bounds=bounds.Pad(maxItemRadius);
CalculateSubBounds(maxima);
protectedoverrideVector2GetTrackPos(floatlerp)
returnarc.LerpPos(lerp);
publicoverrideVector2GetClosestPoint(Vector2point)
returnarc.GetClosestPoint(point);
publicoverridevoidDraw()
ColordrawColor=LevelCheck.GetColor(this);
DRAW.Arc(rootPos,radius,arc.bend,angle).SetColor(drawColor).SetDepth(Z.W05);
Vector2offsetDir=(GetChildPos(null,GTime.Now)-rootPos).normalized;
DRAW.Vector(rootPos+offsetDir*shapeVector.magnitude,offsetDir).SetColor(drawColor).SetDepth(Z.W05);
DRAW.Rectangle(center,V2.one*.2f).SetColor(Color.white).SetDepth(Z.W05).Fill(1);
publicoverridevoidTellShapeWhatToDo(Shapeshape)
shape.segmentCount=1;
shape.segments[0].SetPointDir(arc.LerpPos(0),arc.LerpDir(0).ToRadian()-Mth.*.5f).SetLengthBend(TrackLength*.5f,arc.bend);
shape.FinishSetup();
publicabstractpartialclassTrack
staticTrack()
pingPongPool=newPool<Track>(()=>newTrack_PingPong(),pCount);
circularPool=newPool<Track>(()=>newTrack_Circular(),cCount);
arcPool=newPool<Track>(()=>newTrack_Arc(),aCount);
active=newList<Track>(TotalCount);
privatestaticreadonlyPool<Track>pingPongPool,circularPool,arcPool;
privateconstintpCount=100,cCount=100,aCount=100;
publicconstintTotalCount=pCount+cCount+aCount;
publicstaticreadonlyList<Track>active;
publicstaticvoidPoolReset()
active.Clear();
pingPongPool.Reset();
circularPool.Reset();
arcPool.Reset();
publicstaticTrackGetNewTrack(elementTypetrackType)
Tracktrack=null;
switch(trackType)
caseelementType.PingPong:track=pingPongPool.GetFree();break;
caseelementType.Circular:track=circularPool.GetFree();break;
caseelementType.Arc:track=arcPool.GetFree();break;
active.Add(track);
returntrack;
protectedstaticfloatTurnAngle(Vector2a,Vector2b)
Vector2aDir=a.Rot90();
floatangle=Vector2.Angle(a,b);
floatdirDot=Vector2.Dot(aDir,b);
returndirDot<0?360-angle:angle;
publicstaticTrackGet(inttrackID)
intcount=active.Count;
for(inti=0;i<count;i++)
if(active[i].ID==trackID)
returnactive[i];
returnnull;
namespaceLevelElements
publicpartialclassItem:Element
publicinttrackIndex;
publicfloatradius,mass,trackOffset,trackLag;
publicboolisOccluded;
publicTrackparent;
publicoverridevoidReset()
base.Reset();
Level.RemoveElementFromCells(this);
parent=null;
trackLag=0;
itemPool.Return(this);
active.Remove(this);
publicoverrideVector2GetPos(floattime)
returnelementType.Anim(time,ID,parent==null?rootPos:parent.GetChildPos(this,time));
publicVector2GetLagPos(floattime)
returnGetPos(time+trackLag);
publicVector2GetMV(floattime)
if(parent==null)
returnVector2.zero;
return(parent.GetChildPos(this,time)-
parent.GetChildPos(this,time-GPhysics.TimeStep))
*GPhysics.StepsPerSecond;
publicoverrideElementSetType(elementTypeelementType)
this.elementType=elementType;
radius=elementType.Radius();
mass=elementType.Mass();
trackLag=Mask.MustShake.Fits(elementType)?.0215f/mass*-1:0;
returnthis;
publicoverrideElementSetRootPos(Vector2rootPos)
this.rootPos=parent!=null?parent.rootPos:rootPos;
returnthis;
publicoverrideElementSetSide(Sideside)
this.side=side;
returnthis;
publicoverridevoidRefresh()
if(parent==null)
Level.RemoveElementFromCells(this);
bounds=newBounds2D(rootPos).Pad(radius);
Level.AddElementToCells(this);
privateItemGetShiftedItem(floattimeShift)
returnparent==null?this:parent.GetShiftItem(this,timeShift);
publicoverridefloatSqrDistance(Vector2point,floattime)
Vector2pos=GetPos(time);
floatxDir=pos.x-point.x;
floatyDir=pos.y-point.y;
returnxDir*xDir+yDir*yDir;
publicboolIsAlike(Itemother)
GrouppeerGroup=elementType.Alias();
if(peerGroup!=null)
returnpeerGroup.Contains(other.elementType);
returnelementType==other.elementType;
publicvoidDelete()
if(parent!=null)
parent.UnparentThis(this).ScanAndRefesh();
else
Itembuddy=(Item)GetLink(linkType.Warp).GetOther(this);
if(buddy!=null)
buddy.Reset();
Reset();
publicvoidLinkSignal(Swingswing)
for(inti=0;i<activeLinkCount;i++)
activeLinks[i].OnSwing(swing);
publicpartialclassItem
publicconstintTotalCount=10000;
publicconstfloatDefaultRadius=.075f;
publicstaticreadonlyList<Item>active;
privatestaticreadonlyPool<Item>itemPool;
publicstaticintCount{get{returnitemPool.ActiveElementCount;}}
staticItem()
itemPool=newPool<Item>(()=>newItem(),TotalCount);
active=newList<Item>(TotalCount);
publicstaticvoidPoolReset()
active.Clear();
itemPool.Reset();
publicstaticItemGet(intitemID)
returnitemPool.all[itemID];
publicstaticItemGet(intitemID,floattimeShift)
returnitemPool.all[itemID].GetShiftedItem(timeShift);
publicstaticItemGetFreeItem{get{returnactive.GetAdd(itemPool.GetFree());}}
publicoverridevoidDraw()
ColordrawColor=LevelCheck.GetColor(this);
Vector2pos=GetPos(GTime.Now);
DRAW.Circle(pos,radius,16).SetColor(drawColor).SetDepth(Z.W05);
if(ElementEdit.element==this)
DRAW.MultiCircle(pos,radius+.6f,3,.2f,16).SetColor(drawColor.A(.75f)).SetDepth(Z.W05);
if(parent!=null)
parent.Draw();
return;
if(LevelCheck.Overlapping(this))
boolextra=LevelCheck.ItemCheck&&LevelCheck.Filter.Fits(elementType);
DRAW.Circle(pos,radius+(extra?Level.PlacementRadius:.4f),16).SetColor(drawColor.A(.75f)).SetDepth(Z.W05);
else
if(LevelCheck.HighLighted(this))
DRAW.Circle(pos,radius+.4f,16).SetColor(drawColor.A(.75f)).SetDepth(Z.W05);
if(parent!=null)
parent.Draw();
publicoverridestringGetInfo()
if(parent==null)
infoBuilder.Length=0;
infoBuilder.Append(ID.ToString().PadLeft(4)).Append("").Append("").Append("").
Append(elementType.ToString().PadRight(ElementTypeExt.LongestItemName));
else
stringpString=parent.GetInfo();
infoBuilder.Length=0;
infoBuilder.Append(ID.ToString().PadLeft(4)).Append("").Append("").Append("").
Append(elementType.ToString().PadRight(ElementTypeExt.LongestItemName)).
Append("|TrackPos:").Append(trackIndex).Append("\n").Append(pString);
returninfoBuilder.ToString();
namespaceLevelElements
publicabstractpartialclassElement:PoolObject
protectedElement(){ID=incrementID++;}
publicelementTypeelementType;
publicreadonlyintID;
publicBounds2Dbounds;
publicSideside=Side.Front;
publicVector2rootPos;
publicvirtualElementSetType(elementTypeelementType)
this.elementType=elementType;
returnthis;
publicabstractElementSetRootPos(Vector2rootPos);
publicabstractElementSetSide(Sideside);
publicabstractvoidRefresh();
publicvirtualvoidReset()
for(inti=0;i<activeLinkCount;i++)
Link.Delete(activeLinks[i]);
for(inti=0;i<passiveLinkCount;i++)
Link.Delete(passiveLinks[i]);
activeLinkCount=0;
passiveLinkCount=0;
publicvirtualVector2GetPos(floattime){returnrootPos;}
publicabstractfloatSqrDistance(Vector2point,floattime);
protectedreadonlyLink[]activeLinks=newLink[5],passiveLinks=newLink[5];
protectedintactiveLinkCount,passiveLinkCount;
publicvoidAddLink(Linklink)
if(link.a==this)
activeLinks[activeLinkCount++]=link;
else
passiveLinks[passiveLinkCount]=link;
publicvoidRemoveLink(Linklink)
if(link.a==this)
activeLinkCount=activeLinks.ShiftRemove(link,activeLinkCount);
else
passiveLinkCount=passiveLinks.ShiftRemove(link,passiveLinkCount);
publicLinkGetLink(linkTypelinkType,boolonlyPrimary=false)
for(inti=0;i<activeLinkCount;i++)
if(activeLinks[i].linkType==linkType)
returnactiveLinks[i];
if(!onlyPrimary)
for(inti=0;i<passiveLinkCount;i++)
if(passiveLinks[i].linkType==linkType)
returnpassiveLinks[i];
returnLink.None;
publicabstractvoidDraw();
publicabstractstringGetInfo();
publicstringGetIdAndSideInfo()
return"#"+ID+"#"+(side.front?0:1);
publicabstractpartialclassElement
privatestaticintincrementID;
publicstaticvoidClearAll()
Item.PoolReset();
Track.PoolReset();
protectedstaticreadonlyStringBuilderinfoBuilder=newStringBuilder(1000);
namespaceLevelElements
publicabstractpartialclassTrack:Element
protectedTrack(elementTypeelementType)
this.elementType=elementType;
publicreadonlyItem[]items=newItem[20];
publicintitemCount;
publicfloatoffset,speed=2,angle,size=1,growth=.5f;
protectedVector2shapeVector;
publicVector2center;
privateintslowDownSteps;
publicfloatmaxItemRadius;
publicintsubBoundCount;
privateconstintmaxSubBounds=8;
privatereadonlySubBound[]subBounds=CollectionInit.Array<SubBound>(maxSubBounds);
publicreadonlybool[]subOcclusion=newbool[maxSubBounds];
publicboolallSubsVisible,allSubsOccluded;
protectedabstractfloatTrackLength{get;}
publicoverridevoidReset()
base.Reset();
for(inti=0;i<itemCount;i++)
items[i].Delete();
itemCount=0;
Level.RemoveElementFromCells(this);
angle=0;
speed=2;
offset=0;
size=1;
growth=1;
switch(elementType)
caseelementType.PingPong:pingPongPool.Return(this);break;
caseelementType.Circular:circularPool.Return(this);break;
caseelementType.Arc:arcPool.Return(this);break;
publicoverrideElementSetRootPos(Vector2rootPos)
this.rootPos=rootPos;
returnthis;
publicTrackSetSize(floatsize)
this.size=Mathf.Clamp(size,.1f,3);
returnthis;
publicTrackSetAngle(floatangle)
this.angle=angle;
returnthis;
publicTrackSetOffset(floatoffset)
this.offset=offset;
returnthis;
publicTrackSetCompletion(floatcompletion)
if(Mask.TrackCanGrow.Fits(elementType))
growth=Mathf.Clamp(completion,.05f,.95f);
returnthis;
publicoverridevoidRefresh()
Level.RemoveElementFromCells(this);
shapeVector=V2.up.Rot(angle,elementType.DefaultVScale()*size);
CalculateBounds();
Level.AddElementToCells(this);
for(inti=0;i<itemCount;i++)
items[i].bounds=bounds;
protectedabstractvoidCalculateBounds();
publicTrackParentThis(ItemnewItem)
if(itemCount==elementType.MaxItems())
returnthis;
if(items.Contains(newItem,itemCount))
Debug.Log("Itemalreadyontrack...");
returnthis;
newItem.parent=this;
newItem.SetRootPos(rootPos);
newItem.SetSide(side);
items[itemCount++]=newItem;
returnthis;
publicTrackReplaceAt(ItemremoveThis,ItemnewItem)
removeThis.Reset();
newItem.parent=this;
newItem.SetRootPos(rootPos).SetSide(side);
items.Replace(removeThis,newItem,itemCount);
returnthis;
publicTrackUnparentThis(ItemremoveThis)
removeThis.Reset();
itemCount=items.ShiftRemove(removeThis,itemCount);
returnthis;
publicvoidScanAndRefesh()
maxItemRadius=0;
for(inti=0;i<itemCount;i++)
maxItemRadius=Mathf.Max(maxItemRadius,items[i].radius);
intsegmentLength=itemCount;
for(inti=0;i<itemCount;i++)
intcheckLength=itemCount-i;
for(inte=0;e<itemCount;e++)
inttoThis=(e+checkLength)%itemCount;
if(!items[e].IsAlike(items[toThis]))
break;
if(e==itemCount-1)
segmentLength=checkLength;
intsegments=(int)((float)itemCount/segmentLength);
floatlog=Mathf.Log(segments,2);
boolcanBeSlow=segments>1&&f.Same(log%1,0);
slowDownSteps=canBeSlow?(int)log:0;
floatabsSpeed=Mathf.Abs(speed);
if(absSpeed<1)
boolvalidSpeed=false;
for(inti=0;i<slowDownSteps+1;i++)
if(f.Same(absSpeed,1f.Divide(2,i)))
validSpeed=true;
break;
if(!validSpeed)
speed=Mathf.Sign(speed);
floatmulti=1f/itemCount;
for(inti=0;i<itemCount;i++)
items[i].trackIndex=i;
items[i].trackOffset=i*multi;
Refresh();
publicboolAnyItemMatchesMask(ElementMaskmask)
for(inti=0;i<itemCount;i++)
if(mask.Fits(items[i].elementType))
returntrue;
returnfalse;
publicvoidShiftSpeed(boolforward)
speed=ChangeSpeed(forward?1:-1);
privatefloatChangeSpeed(floatdir)
floatsign=Mathf.Sign(speed);
floatabsSpeed=Mathf.Abs(speed);
dir*=sign;
if(dir>0)
if(absSpeed>=1)
return(absSpeed+1)*sign;
if(slowDownSteps==0)
returnsign;
intdivisions=0;
for(inti=0;i<slowDownSteps+1;i++)
if(f.Same(absSpeed,1f.Divide(2,i)))
divisions=i-1;
break;
return1f.Divide(2,divisions)*sign;
if(absSpeed>1)
return(absSpeed-1)*sign;
if(f.Same(absSpeed,MinSpeed)||f.Same(absSpeed,1)&&slowDownSteps==0)
return-speed;
intdivisions=0;
for(inti=0;i<slowDownSteps+1;i++)
if(f.Same(absSpeed,1f.Divide(2,i)))
divisions=i+1;
break;
if(divisions>slowDownSteps)
return-speed;
return1f.Divide(2,divisions)*sign;
publicItemGetShiftItem(Itemitem,floatshift)
if(Mathf.Abs(speed)<1)
intshiftSteps=item.trackIndex+Mathf.RoundToInt(itemCount*speed*-shift/GTime.LoopTime);
returnitems[(int)Mathf.Repeat(shiftSteps,itemCount)];
returnitem;
publicoverrideElementSetSide(Sideside)
this.side=side;
for(inti=0;i<itemCount;i++)
items[i].SetSide(side);
returnthis;
publicVector2GetChildPos(Itemitem,floattime)
returnGetTrackPos(GetLerp(time,item!=null?item.trackOffset:0));
protectedabstractVector2GetTrackPos(floatlerp);
protectedvirtualfloatGetLerp(floattime,floatitemOffset)
return(speed*time*GTime.LoopMulti+itemOffset+offset)%1;
publicSubBoundGetSubBound(intboundIndex)
returnsubBounds[boundIndex];
protectedvoidCalculateSubBounds(Maxima[]maxima=null)
subBoundCount=(int)Mathf.Max(1,Mathf.Min(maxSubBounds,TrackLength/6));
floattimeStep=1f/subBoundCount;
for(inti=0;i<subBoundCount;i++)
subBounds[i].SetLerps(i*timeStep,(i+1)*timeStep,this,maxima);
publicboolItemIsInSubBound(Itemitem,intsubBound)
SubBoundsB=subBounds[subBound];
for(inti=0;i<sB.itemCount;i++)
if(sB.items[i].Equals(item))
returntrue;
returnfalse;
publicvoidFillSubBounds(floattime,ElementMaskfilter)
for(inti=0;i<subBoundCount;i++)
subBounds[i].itemCount=0;
for(inti=0;i<itemCount;i++)
Itemitem=items[i];
if(!(filter.Fits(item.elementType)))
continue;
SubBoundsubBound=subBounds[SubIndex(SubStep(item,time+item.trackLag))];
subBound.items[subBound.itemCount++]=item;
publicvirtualintSubStep(Itemitem,floattime)
floatunclampedLerp=speed*time*GTime.LoopMulti+item.trackOffset+offset;
returnMathf.FloorToInt(unclampedLerp*subBoundCount);
publicvirtualintSubIndex(intsubStep)
returnsubStep>=0?subStep%subBoundCount:(subBoundCount+(subStep%subBoundCount))%subBoundCount;
publicabstractVector2GetClosestPoint(Vector2point);
publicoverridefloatSqrDistance(Vector2point,floattime)
Vector2pos=GetClosestPoint(point);
floatxDir=pos.x-point.x;
floatyDir=pos.y-point.y;
returnxDir*xDir+yDir*yDir;
publicvirtualboolOverlaps(Trackother)
returnfalse;
publicoverridestringGetInfo()
stringspeedAdd=speed>0?"":"";
infoBuilder.Length=0;
infoBuilder.Append(ID.ToString().PadLeft(4)).Append("").Append(elementType.ToString().PadRight(ElementTypeExt.LongestItemName)).
Append("|Size:").Append(size.ToString("F1")).Append("Angle:").Append(angle.ToString("F1")).
Append("|Speed:").Append(speedAdd).Append(speed).Append("Offset:").Append(offset.ToString("F1")).
Append("|").Append(itemCount.ToString().PadLeft(2)).Append("Item"+(itemCount>1?"s":"")+"Groups:").Append(Mathf.RoundToInt(1f/MinSpeed));
returninfoBuilder.ToString();
privatefloatMinSpeed{get{return1f.Divide(2,slowDownSteps);}}
publicabstractvoidTellShapeWhatToDo(Shapeshape);
publicclassSubBound
publicBounds2Dbounds;
publicintitemCount;
publicreadonlyItem[]items=newItem[20];
publicvoidSetLerps(floatlerpA,floatlerpB,Tracktrack,Maxima[]maximas)
bounds=newBounds2D(track.GetTrackPos(lerpA)).Add(track.GetTrackPos(lerpB));
if(maximas!=null)
for(inti=0;i<maximas.Length;i++)
if(maximas[i].FitsInLerpRange(lerpA,lerpB))
bounds=bounds.Add(maximas[i].pos);
bounds=bounds.Pad(track.maxItemRadius);
publicboolIntersects(Bounds2DotherBound)
returnbounds.Intersects(otherBound);
publicclassMaxima
publicVector2pos;
privatefloatlerp;
publicvoidSet(Vector2pos,floatlerp)
this.pos=pos;
this.lerp=lerp;
publicboolFitsInLerpRange(floatlerpA,floatlerpB)
returnlerpA<=lerp&&lerpB>lerp;
privateintLerpSub(floatlerp)
returnMathf.FloorToInt(Mathf.Repeat(lerp,1)*subBoundCount);
publicintGetOldSubIndex(Itemitem,floattime)
returnLerpSub(GetLerp(time,item.trackOffset));
namespaceGeneration
publicclassBezierCurve
publicfloattotalLength;
publicfloatClampedLength{get{returntotalLength-startClamp-endClamp;}}
publicfloatstartClamp;
publicfloatendClamp;
publicreadonlyList<BezierSegment>segments=newList<BezierSegment>(100);
publicBezierCurve()
for(inti=0;i<segments.Capacity;i++)
segments.Add(newBezierSegment());
publicvoidClear()
publicvoidCreate(List<Vector2>path,Vector2point_A,Vector2point_B)
if(point_A==-V2.up)
point_A=path[0]+(path[0]-path[1]);
if(point_B==-V2.up)
point_B=path[path.Count-1]+(path[path.Count-1]-path[path.Count-2]);
totalLength=0;
for(inti=0;i<path.Count-1;i++)
Vector2pointBefore=i==0?point_A:path[i-1];
Vector2startPoint=path[i];
Vector2endPoint=path[i+1];
Vector2pointAfter=i==path.Count-2?point_B:path[i+2];
segments[i].Create(startPoint,endPoint,pointBefore,pointAfter);
totalLength+=segments[i].length;
startClamp=segments[0].Get_ClampDistance(path[0],true);
endClamp=segments[segments.Count-1].Get_ClampDistance(path[path.Count-1],false);
publicVector2Get_AnimPos(floatt)
returnGet_PointAt(Mathf.Repeat(t,ClampedLength)+startClamp);
publicVector2Get_PointAt(floatdistance)
floatdist=0;
for(inti=0;i<segments.Count;i++)
if(dist+segments[i].length>distance)
returnsegments[i].Get_BezierPoint((distance-dist)/segments[i].length);
else
dist+=segments[i].length;
returnV2.zero;
publicList<Vector2>GetCurve(intdivision)
List<Vector2>theCurve=newList<Vector2>();
division=Mathf.RoundToInt(division*ClampedLength);
floatstep=ClampedLength/division;
for(floati=0;i<division;i++)
theCurve.Add(Get_AnimPos(i*step));
theCurve.Add(Get_AnimPos(ClampedLength-.001f));
returntheCurve;
publicclassBezierSegment
privateconstfloattangent_Weight=.45f;
privateVector2a;
privateVector2b;
privateVector2tan_A;
privateVector2tan_B;
publicfloatlength;
publicvoidCreate(Vector2a,Vector2b,Vector2before,Vector2after)
this.a=a;
this.b=b;
tan_A=a+(b-before).normalized*tangent_Weight;
tan_B=b+(a-after).normalized*tangent_Weight;
Calc_Length();
publicvoidCalc_Length()
constintsegments=50;
constfloatstep=1f/(segments-1);
length=0;
for(inti=0;i<segments;i++)
Vector2p1=Get_BezierPoint(i*step);
Vector2p2=Get_BezierPoint((i+1)*step);
length+=Vector2.Distance(p1,p2);
publicVector2Get_BezierPoint(floatt)
floattt=t*t;
floatttt=tt*t;
floatu=1-t;
floatuu=u*u;
floatuuu=uu*u;
Vector2p=uuu*a;//1stterm
p+=3*uu*t*tan_A;//2ndterm
p+=3*u*tt*tan_B;//3rdterm
p+=ttt*b;//4thterm
returnp;
publicfloatGet_ClampDistance(Vector2knot,boolstart)
constintsegments=200;
constfloatstep=1f/(segments-1);
floatclosestDistance=1000;
intindex=0;
for(inti=0;i<segments;i++)
Vector2point=Get_BezierPoint((float)i/segments);
floatdist=Vector2.Distance(knot,point);
if(dist>=LevelSection.knotRadius&&dist<=closestDistance)
closestDistance=dist;
index=i;
if(!start)
index++;
floatl=0;
for(inti=0;i<index;i++)
Vector2p1=Get_BezierPoint(i*step);
Vector2p2=Get_BezierPoint((i+1)*step);
l+=Vector2.Distance(p1,p2);
returnstart?l:length-l;
namespaceGeneration
publicclassLevelSection
publicconstintwidth=5;
publicconstintheight=16;
publicconstintmaxWidth=10;
privateconstintmaxPathes=15;
publicconstfloatavoidRadius=2.5f;
privateboolNoMorePathes{get{returnPathNr==maxPathes-1&&PathNr!=-1;}}
privateconstintlinkRange=width+3;
privateconstintpointRange=width+3;
privateconstintmaxLinks=5;
publicconstfloatknotRadius=.2f;
publicPathSearchPathSearch;
publicNumGennumGen;
publicintsection_ID;
publicintseed;
publicboolAllLinksAreUsed{get{returnPickUnused_Link(false)==null&&PickUnused_Link(true)==null;}}
privateboolAllPointsConnected{get{returnavoidConnect==avoidThese.Count;}}
publicboolFinished;
publicintPathNr;
publicList<Path>pathes=newList<Path>(maxPathes);
publicList<BezierCurve>bezierCurves=newList<BezierCurve>(100);
publicList<CrossPoint>crossedPoints=newList<CrossPoint>(200);
publicList<Vector2>knots=newList<Vector2>(50);
publicboolCrash;
publicintbez_Num;
publicList<Vector2>sticks=newList<Vector2>(500);
privatestaticreadonlyintxCells=Mathf.CeilToInt(maxWidth*2*Level.CellSize/(float)Level.CellSize);
privatestaticreadonlyintyCells=Mathf.CeilToInt((height+1)*Level.CellSize/(float)Level.CellSize);
publicList<Cell>cells=newList<Cell>(xCells*yCells);
publicinttotalPathLength
get
if(PathNr==-1)
return0;
intl=0;
for(inti=0;i<PathNr+1;i++)
l+=pathes[i].path.Count;
returnl;
publicint_lP;
publicintlongestPath
get
if(PathNr==-1)
return0;
for(inti=0;i<PathNr+1;i++)
if(pathes[i].path.Count>_lP)
_lP=pathes[i].path.Count;
return_lP;
set{_lP=value;}
publicList<GenerationLink>topLinks=newList<GenerationLink>(maxLinks);
publicList<GenerationLink>bottomLinks=newList<GenerationLink>(maxLinks);
publicList<Vector2>avoidThese=newList<Vector2>(10);
privateintavoidConnect;
publicLevelSection()
for(inti=0;i<maxPathes;i++)
pathes.Add(newPath());
for(inti=0;i<bezierCurves.Capacity;i++)
bezierCurves.Add(newBezierCurve());
for(inty=0;y<yCells;y++)
for(intx=0;x<xCells;x++)
cells.Add(newCell());
PathSearch=newPathSearch();
numGen=newNumGen();
privatevoidReset()
Crash=Finished=false;
crossedPoints.Clear();
sticks.Clear();
topLinks.Clear();
bottomLinks.Clear();
knots.Clear();
avoidThese.Clear();
for(inti=0;i<pathes.Count;i++)
pathes[i].Clear();
for(inti=0;i<cells.Count;i++)
cells[i].Clear();
for(inti=0;i<bezierCurves.Count;i++)
bezierCurves[i].Clear();
PathNr=-1;
longestPath=avoidConnect=0;
publicvoidAutoSolve(intsection_ID,intseed)
Setup(section_ID,seed);
while(!Finished)
GenerationStep();
publicvoidSetup(intsection_ID,intseed)
Reset();
this.section_ID=section_ID;
this.seed=seed;
numGen.Set_Seed(seed*477.376f+section_ID*355.594f);
CreateLinks();
intavoidPoints=numGen.Get_Int(1,4);
for(inti=0;i<avoidPoints;i++)
CreateAvoidPoint();
privatevoidCreateAvoidPoint()
Vector2pos;
inttrys=0;
while(true)
intx;
while(true)
x=numGen.Get_Int(-pointRange,pointRange+1);
if(Point_Range_Odds(x,numGen))
break;
pos=newVector2(x,numGen.Get_Int(4,height-4));
boolfree=true;
for(inti=0;i<avoidThese.Count;i++)
if(Vector2.Distance(avoidThese[i],pos)<avoidRadius*2.2f)
free=false;
if(free)
break;
trys++;
if(trys==1000)
break;
if(trys!=1000)
avoidThese.Add(pos);
publicboolInAvoidZone(Vector2position)
for(inti=0;i<avoidThese.Count;i++)
if(Vector2.Distance(avoidThese[i],position)<=avoidRadius)
PathSearch.AvoidThisPoint(i);
returntrue;
returnfalse;
publicvoidGenerationStep()
if(PathSearch.Finished&&PathNr!=-1&&NoMorePathes)
Finished=true;
if(!Finished&&PathSearch.Finished)
if(!AllLinksAreUsed)
PathNr++;
PathSearch.Setup(PickUnused_Link(false),PickUnused_Link(true),this);
else
if(AllPointsConnected)
Vector2randomStart=V2.zero;
inttrys=0;
while(true)
intpathPick=numGen.Get_Int(0,PathNr);
if(pathes[pathPick].path.Count>=7)
intpointPick=numGen.Get_Int(2,pathes[pathPick].path.Count-3);
randomStart=pathes[pathPick].path[pointPick];
if(ValidKnotPoint(randomStart))
break;
trys++;
if(trys==1000)
Finished=true;
Debug.Log("Couldnothavedoneanything"+LevelSectionTest.solve_Nr);
break;
if(Finished)
return;
PathNr++;
booltop=randomStart.y>3&&randomStart.y<height-3?numGen.Odds_In_100(50):(randomStart.y<=3);
PathSearch.Setup(GetDummyLink(randomStart),PickAnyLink(top),this);
AddKnot(randomStart);
else
PathNr++;
PathSearch.Setup(GetDummyLink(avoidThese[avoidConnect]),PickAnyLink(numGen.Odds_In_100(50)),this);
AddKnot(avoidThese[avoidConnect]);
avoidConnect++;
if(Finished)
CreateBezierCurves();
CreateSticks();
PutIntoCells();
return;
PathSearch.SearchStep();
privateboolValidKnotPoint(Vector2point)
constfloatminDistance=1f;
for(inti=0;i<knots.Count;i++)
if(Vector2.Distance(knots[i],point)<minDistance)
returnfalse;
returntrue;
privatevoidAddKnot(Vector2newKnot)
for(inti=0;i<knots.Count;i++)
if(knots[i]==newKnot)
return;
for(inti=0;i<topLinks.Count;i++)
if(topLinks[i].Point==newKnot)
return;
for(inti=0;i<bottomLinks.Count;i++)
if(bottomLinks[i].Point==newKnot)
return;
knots.Add(newKnot);
for(inti=0;i<PathNr+1;i++)
for(inte=0;e<pathes[i].path.Count;e++)
if(pathes[i].path[e]==newKnot&&e!=pathes[i].path.Count-1&&e!=0)
pathes[i].AddSplit(newKnot);
publicboolIsThisFree(Vector2point)
for(inti=0;i<pathes.Count;i++)
for(inte=0;e<pathes[i].path.Count;e++)
if(pathes[i].path[e]==point)
if(i==PathNr)
returnfalse;
PathSearch.ConnectedToPath=true;
PathSearch.connectToThis=i;
returntrue;
for(inti=0;i<avoidThese.Count;i++)
if(avoidThese[i]==point)
returnfalse;
returntrue;
publicvoidAddPointToPath(Vector2point)
if(pathes[PathNr].path.Count>0&&pathes[PathNr].path[pathes[PathNr].path.Count-1]==point)
return;
pathes[PathNr].path.Add(point);
if(pathes[PathNr].path.Count<=1)
return;
Vector2oldPoint=pathes[PathNr].path[pathes[PathNr].path.Count-2];
Vector2dir=point-oldPoint;
intangle=Mathf.RoundToInt(Mathf.Repeat(Mathf.Abs(Vector2.Angle(V2.up,dir)),90));
if(angle==45)
ExtraCrossPoint(oldPoint,point);
if(PathSearch.ConnectedToPath)
AddKnot(point);
publicboolCanICross(Vector2crossPoint)
for(inti=0;i<crossedPoints.Count;i++)
if(crossedPoints[i].crossedPoint==crossPoint)
if(PathNr!=-1&&crossedPoints[i].pathNr!=PathNr)
PathSearch.connectToThis=crossedPoints[i].pathNr;
returnfalse;
returntrue;
privatevoidExtraCrossPoint(Vector2oldPos,Vector2newPos)
Vector2crossPoint=Vector2.Lerp(oldPos,newPos,.5f);
crossedPoints.Add(newCrossPoint(crossPoint,PathNr));
publicVector2Get_Closest_Point_On_Path(Vector2point,intpath)
for(inti=0;i<pathes[path].path.Count;i++)
if(Mathf.RoundToInt(Mathf.Abs((pathes[path].path[i]-point).magnitude))==1)
intlower=i;
inthigher=i;
for(inte=i;e<pathes[path].path.Count;e++)
if(Mathf.RoundToInt(Mathf.Abs((pathes[path].path[e]-point).magnitude))==1)
higher=e;
else
break;
inttrys=0;
while(true)
Vector2connect_Point=pathes[path].path[numGen.Get_Int(lower,higher+1)];
Vector2cross=Vector2.Lerp(point,connect_Point,.5f);
if(CanICross(cross)&&!OwnPath(connect_Point))
returnconnect_Point;
trys++;
if(trys==1000)
return-V2.up;
return-V2.up;
privateboolOwnPath(Vector2point)
for(inti=0;i<pathes[PathNr].path.Count;i++)
if(pathes[PathNr].path[i]==point)
returntrue;
returnfalse;
privatevoidCreateLinks()
NumGenlinkGen=newNumGen();
floattopSeed=(section_ID+1)*354.765f+seed*464.74f;
linkGen.Set_Seed(topSeed);
inttop;
while(true)
top=linkGen.Get_Int(1,maxLinks+1);
if(Link_Num_Odds(top,linkGen))
break;
for(inti=0;i<top;i++)
inttrys=0;
while(true)
Vector2position=V2.right*linkGen.Get_Int(-linkRange,linkRange+1)+V2.up*height;
if(Link_Range_Odds(position,linkGen)&&LinkPosFree(position))
topLinks.Add(newGenerationLink(position,topSeed+i*65.645f,this));
knots.Add(position);
break;
trys++;
if(trys==1000)
top--;
break;
floatbottomSeed=section_ID*354.765f+seed*464.74f;
linkGen.Set_Seed(bottomSeed);
intbottom;
while(true)
bottom=linkGen.Get_Int(1,maxLinks+1);
if(Link_Num_Odds(bottom,linkGen))
break;
if(section_ID==0)
bottom=1;
for(inti=0;i<bottom;i++)
inttrys=0;
while(true)
Vector2position=V2.right*linkGen.Get_Int(-linkRange,linkRange+1);
if(Link_Range_Odds(position,linkGen)&&LinkPosFree(position))
bottomLinks.Add(newGenerationLink(position,bottomSeed+i*65.645f,this));
knots.Add(position);
break;
trys++;
if(trys==1000)
bottom--;
break;
crossedPoints.Clear();
privateGenerationLinkPickUnused_Link(booltop)
if(top)
for(inti=0;i<topLinks.Count;i++)
if(!topLinks[i].Used)
returntopLinks[i];
returnnull;
for(inti=0;i<bottomLinks.Count;i++)
if(!bottomLinks[i].Used)
returnbottomLinks[i];
returnnull;
privateGenerationLinkPickAnyLink(booltop)
returntop?topLinks[numGen.Get_Int(0,topLinks.Count)]:bottomLinks[numGen.Get_Int(0,bottomLinks.Count)];
publicGenerationLinkGetDummyLink(intxPos,booltop)
floatfarthest_X=0;
for(inti=0;i<topLinks.Count;i++)
if(Mathf.Abs(topLinks[i].Point.x-xPos)>Mathf.Abs(farthest_X))
farthest_X=topLinks[i].Point.x;
for(inti=0;i<bottomLinks.Count;i++)
if(Mathf.Abs(bottomLinks[i].Point.x-xPos)>Mathf.Abs(farthest_X))
farthest_X=bottomLinks[i].Point.x;
Vector2dummyPos=V2.right*(farthest_X+numGen.Get_Int(0,3)*Mathf.Sign(farthest_X))+V2.up*(top?height:0);
returnnewGenerationLink(dummyPos);
publicGenerationLinkGetDummyLink(Vector2position)
returnnewGenerationLink(position);
privateboolLinkPosFree(Vector2position)
for(inti=0;i<bottomLinks.Count;i++)
if(bottomLinks[i].Point==position)
returnfalse;
for(inti=0;i<topLinks.Count;i++)
if(topLinks[i].Point==position)
returnfalse;
returntrue;
publicboolLinkAngleFine(Vector2position,Vector2angleDir)
intangle=Mathf.RoundToInt(Mathf.Repeat(Vector2.Angle(V2.up,angleDir),90));
if(angle!=45)
returntrue;
Vector2crossPoint=position+angleDir*.5f;
boolcanCross=CanICross(crossPoint);
if(canCross)
ExtraCrossPoint(position,position+angleDir);
returncanCross;
privatestaticboolLink_Num_Odds(intnr,NumGengen)
switch(nr)
default:returnfalse;
case1:returngen.Odds_In_100(30);
case2:returngen.Odds_In_100(20);
case3:returngen.Odds_In_100(10);
case4:returngen.Odds_In_100(5);
privatestaticboolLink_Range_Odds(Vector2pos,NumGengen)
switch(Mathf.RoundToInt(Mathf.Abs(pos.x)))
default:returngen.Odds_In_100(50);
case1:returngen.Odds_In_100(40);
case2:returngen.Odds_In_100(33);
case3:returngen.Odds_In_100(25);
case4:returngen.Odds_In_100(17);
case5:returngen.Odds_In_100(6);
case6:returngen.Odds_In_100(4);
case7:returngen.Odds_In_100(2);
case8:returngen.Odds_In_100(1);
privatestaticboolPoint_Range_Odds(floatx,NumGengen)
switch(Mathf.RoundToInt(Mathf.Abs(x)))
default:returngen.Odds_In_100(10);
case1:returngen.Odds_In_100(12);
case2:returngen.Odds_In_100(16);
case3:returngen.Odds_In_100(22);
case4:returngen.Odds_In_100(34);
case5:returngen.Odds_In_100(40);
case6:returngen.Odds_In_100(34);
case7:returngen.Odds_In_100(20);
case8:returngen.Odds_In_100(8);
case9:returngen.Odds_In_100(4);
case10:returngen.Odds_In_100(2);
privatevoidCreateBezierCurves()
bez_Num=0;
for(inti=0;i<PathNr+1;i++)
Vector2p1=Get_Bezier_Point(pathes[i].path[0]);
Vector2p2=Get_Bezier_Point(pathes[i].path[pathes[i].path.Count-1]);
if(pathes[i].splits.Count==0)
bezierCurves[bez_Num].Create(pathes[i].path,p1,p2);
bez_Num++;
else
List<int>splits=pathes[i].splits;
for(ints=0;s<splits.Count+1;s++)
intfirstPoint=s==0?0:splits[s-1];
intsecondPoint=s==splits.Count?pathes[i].path.Count-1:splits[s];
List<Vector2>path=pathes[i].path.GetRange(firstPoint,secondPoint-firstPoint+1);
Vector2before=firstPoint==0?p1:-V2.up;
Vector2after=secondPoint==pathes[i].path.Count-1?p2:-V2.up;
bezierCurves[bez_Num].Create(path,before,after);
bez_Num++;
publicVector2Get_Bezier_Point(Vector2endPoint)
for(inti=0;i<topLinks.Count;i++)
if(topLinks[i].Point==endPoint)
returnendPoint+PathSearch.AngleToVector(topLinks[i].Out_Angle,V2.up,V2.right);
for(inti=0;i<bottomLinks.Count;i++)
if(bottomLinks[i].Point==endPoint)
returnendPoint+-PathSearch.AngleToVector(bottomLinks[i].In_Angle,V2.up,V2.right);
return-V2.up;
privatevoidCreateSticks()
intfirstKnot=0;
Vector2knot_Pos=pathes[0].path[0];
for(inti=0;i<knots.Count;i++)
if(knots[i]==knot_Pos)
firstKnot=i;
sticks.Add(knots[firstKnot]);
for(inti=0;i<knots.Count;i++)
if(i!=firstKnot)
sticks.Add(knots[i]);
for(inti=0;i<bez_Num;i++)
for(floate=.4f;e<bezierCurves[i].ClampedLength;e+=.4f)
sticks.Add(bezierCurves[i].Get_AnimPos(e));
privatevoidPutIntoCells()
for(inti=0;i<sticks.Count;i++)
cells[Get_Cell(sticks[i])].Add(Item.Get(i));
publicintGet_Cell(Vector2pos)
intnum=Mathf.FloorToInt(pos.x)+Mathf.FloorToInt(xCells*.5f)+Mathf.FloorToInt(pos.y)*xCells;
returnnum<cells.Count?num:-1;
publicclassPath
publicList<Vector2>path=newList<Vector2>(100);
publicList<int>splits=newList<int>(100);
publicvoidClear()
path.Clear();
splits.Clear();
publicvoidAddSplit(Vector2split)
for(inti=0;i<path.Count;i++)
if(path[i]==split)
SortIntoSplits(i);
break;
privatevoidSortIntoSplits(intpoint)
for(inti=0;i<splits.Count;i++)
if(splits[i]>point)
splits.Insert(i,point);
return;
splits.Add(point);
publicclassCrossPoint
publicVector2crossedPoint;
publicintpathNr;
publicCrossPoint(Vector2crossedPoint,intpathNr)
this.crossedPoint=crossedPoint;
this.pathNr=pathNr;
publicclassGenerationLink
publicintx{get{returnMathf.RoundToInt(Point.x);}}
publicinty{get{returnMathf.RoundToInt(Point.y);}}
publicVector2Point;
publicintIn_Angle;
publicintOut_Angle;
publicboolUsed;
publicbooldummy;
publicGenerationLink(Vector2position)
Point=position;
dummy=true;
publicGenerationLink(Vector2position,floatseed,LevelSectionsection)
NumGennumGen=newNumGen();
numGen.Set_Seed(seed);
Point=position;
while(true)
In_Angle=numGen.Get_Int(-1,2)*45;
Vector3angleVector=-PathSearch.AngleToVector(In_Angle,V2.up,V2.right);
if(PathSearch.AngleOdds(In_Angle,numGen)&&section.LinkAngleFine(position,angleVector))
break;
while(true)
Out_Angle=numGen.Get_Int(-1,2)*45;
Vector3angleVector=PathSearch.AngleToVector(Out_Angle,V2.up,V2.right);
if(PathSearch.AngleOdds(Out_Angle,numGen)&&Mathf.Abs(Out_Angle-In_Angle)<=90&&section.LinkAngleFine(position,angleVector))
break;
publicvoidTurn_InOut(LevelSectionsection,booltop)
while(true)
In_Angle=section.numGen.Get_Int(-1,2)*45;
Out_Angle=section.numGen.Get_Int(-1,2)*45;
intuseAngle=top?In_Angle:Out_Angle;
Vector3angleVector=PathSearch.AngleToVector(useAngle,V2.up,V2.right)*(top?-1:1);
if(PathSearch.AngleOdds(In_Angle,section.numGen)&&section.LinkAngleFine(Point,angleVector))
break;
publicclassLevelSectionDraw:Singleton<LevelSectionDraw>{
[Range(0,1)]
publicfloatjiggle;
[Space(10)]
publicbooldrawAtAll;
[Space(20)]
publicbooldrawGrid;
publicbooldrawLinks;
publicbooldrawKnots;
publicbooldrawPoints;
publicbooldrawClip;
publicbooldrawCrossPoints;
[Space(10)]
publicboolsnakes;
publicboolsticks;
publicbooldrawInfo;
[Space(10)]
[Range(0,50)]
publicinthighlightPath;
publicintmostPartCurves;
privatereadonlyColora=COLOR.blue.deepsky;
privatereadonlyColorb=Color.Lerp(Color.white,COLOR.yellow.fresh,.6f);
publicintcellSize{get{returnLevel.CellSize;}}
publicstaticintWidthOffset{get{returnMathf.CeilToInt(LevelSection.width*-.5f);}}
privateLevelSectionsection;
privateLevelSectionlevelSection{get{returnsection??(section=LevelSectionTest.levelSection);}}
privatevoidOnEnable()
DRAW.Enabled=DRAW.EditorDraw=true;
Camera.main.transform.position=V3.up*(LevelSection.height-1)*cellSize*.5f-V3.forward*10;
privatevoidUpdate()
if(!drawAtAll)
return;
if(drawGrid)
DrawGrid();
if(LevelSectionTest.solve_Nr==0)
return;
DrawLinks();
DrawPath();
if(drawKnots)
DrawKnots();
if(drawPoints)
DrawAvoids();
if(drawCrossPoints)
DrawCrosses();
if(sticks)
DrawSticks();
privatevoidDrawGrid()
Vector3offset=cellSize*.5f*Vector3.ProjectOnPlane(Vector3.one,V3.forward);
for(intx=0;x<LevelSection.width-1;x++)
for(inty=0;y<LevelSection.height;y++)
DRAW.Rectangle(newVector3(x*cellSize,y*cellSize,0)+offset+V3.right*WidthOffset*cellSize,Vector2.one*cellSize).SetColor(COLOR.grey.dark).SetDepth(100);
ColormidDark=Color.Lerp(COLOR.grey.mid,COLOR.grey.dark,.5f);
for(inti=0;i<LevelSection.width;i++)
Vector3pos=V3.right*i*cellSize-V3.up*cellSize*.5f+V3.right*WidthOffset*cellSize;
DRAW.Text((i+WidthOffset).ToString(),pos,size:2,color:midDark);
for(inti=0;i<LevelSection.height+1;i++)
Vector3pos=V3.right*WidthOffset*cellSize+V3.up*i*cellSize+V3.right*cellSize*-.5f;
DRAW.Text((i).ToString(),pos,size:2,color:midDark);
privatevoidDrawLinks()
PathSearchsearch=levelSection.PathSearch;
if(drawLinks)
if(!levelSection.Finished)
DRAW.Circle(JigglePos(search.GenerationLinkStart.Point*cellSize,jiggle),cellSize*.4f).SetColor(a);
DRAW.Circle(JigglePos(search.GenerationLinkGoal.Point*cellSize,jiggle),cellSize*.4f).SetColor(b);
for(inti=0;i<section.topLinks.Count;i++)
DRAW.Circle(JigglePos(section.topLinks[i].Point*cellSize,jiggle),cellSize*.2f).SetColor(Color.white);
DRAW.Vector(JigglePos(section.topLinks[i].Point*cellSize,jiggle),PathSearch.AngleToVector(section.topLinks[i].Out_Angle,V2.up,V2.right)*cellSize*.5f).SetColor(COLOR.green.spring).SetDepth(-1);
DRAW.Vector(JigglePos(section.topLinks[i].Point*cellSize,jiggle),-PathSearch.AngleToVector(section.topLinks[i].In_Angle,V2.up,V2.right)*cellSize*.5f).SetColor(COLOR.red.tomato).SetDepth(-1);
for(inti=0;i<section.bottomLinks.Count;i++)
DRAW.Circle(JigglePos(section.bottomLinks[i].Point*cellSize,jiggle),cellSize*.2f).SetColor(Color.white);
DRAW.Vector(JigglePos(section.bottomLinks[i].Point*cellSize,jiggle),PathSearch.AngleToVector(section.bottomLinks[i].Out_Angle,V2.up,V2.right)*cellSize*.5f).SetColor(COLOR.green.spring).SetDepth(-1);
DRAW.Vector(JigglePos(section.bottomLinks[i].Point*cellSize,jiggle),-PathSearch.AngleToVector(section.bottomLinks[i].In_Angle,V2.up,V2.right)*cellSize*.5f).SetColor(COLOR.red.tomato).SetDepth(-1);
if(drawClip)
ColorgreyDark=Color.Lerp(COLOR.grey.mid,Color.black,.75f);
DRAW.Vector(search.AimPoint*cellSize,search.GetClip(1)*1000).SetColor(greyDark).SetDepth(150);
DRAW.Vector(search.AimPoint*cellSize,search.GetClip(-1)*1000).SetColor(greyDark).SetDepth(150);
Vector2up=search.UpisUp?V2.up:-V2.up;
DRAW.Vector(search.AimPoint*cellSize+-up*cellSize*PathSearch.ClipSize,search.GetClip(1)*1000).SetColor(greyDark).SetDepth(150);
DRAW.Vector(search.AimPoint*cellSize+-up*cellSize*PathSearch.ClipSize,search.GetClip(-1)*1000).SetColor(greyDark).SetDepth(150);
privatevoidDrawPath()
if(levelSection.bez_Num==0)
for(inti=0;i<levelSection.pathes.Count;i++)
if(levelSection.pathes[i].path.Count==0)
break;
List<int>splits=levelSection.pathes[i].splits;
if(splits.Count==0||levelSection.pathes[i].path.Count==2)
DrawThisPath(levelSection.pathes[i].path,false);
else
for(ints=0;s<splits.Count+1;s++)
intfirstPoint=s==0?0:splits[s-1];
intsecondPoint=s==splits.Count?levelSection.pathes[i].path.Count-1:splits[s];
DrawThisPath(levelSection.pathes[i].path.GetRange(firstPoint,secondPoint-firstPoint+1),false);
else
for(inti=0;i<levelSection.bez_Num;i++)
List<Vector2>bez=levelSection.bezierCurves[i].GetCurve(4);
DRAW.Line(bez.Count,e=>JigglePos(V3.right*bez[e].x*cellSize+V3.up*bez[e].y*cellSize,jiggle)).
SetColor(highlightPath==i?COLOR.yellow.fresh:COLOR.purple.orchid).SetDepth(-1);
if(snakes)
floatt=Time.realtimeSinceStartup;
for(inte=0;e<3;e++)
DRAW.Circle(JigglePos(levelSection.bezierCurves[i].Get_AnimPos(t+e*.25f)*cellSize,jiggle),cellSize*.1f).SetColor(Color.white);
privatevoidDrawSticks()
for(inti=0;i<levelSection.sticks.Count;i++)
DRAW.Rectangle(JigglePos(levelSection.sticks[i]*cellSize,jiggle),Vector2.one*cellSize*.125f,45).SetColor(COLOR.yellow.fresh).SetDepth(-3);
privatevoidDrawThisPath(List<Vector2>pathPoints,booljustWhite)
Vector3[]path=newVector3[pathPoints.Count];
for(inte=0;e<path.Length;e++)
path[e]=JigglePos(V3.right*pathPoints[e].x*cellSize+V3.up*pathPoints[e].y*cellSize,jiggle);
if(!levelSection.Crash)
for(inte=0;e<path.Length-1;e++)
ColorpieceColor=justWhite?Color.white:Color.Lerp(a,b,(float)e/Mathf.Clamp(path.Length-2,1,1000000));
DRAW.Vector(path[e],path[e+1]-path[e]).SetColor(pieceColor);
else
DRAW.Line(path).SetColor(COLOR.red.hot);
privatevoidDrawKnots()
for(inti=0;i<section.knots.Count;i++)
DRAW.Circle(JigglePos(section.knots[i]*cellSize,jiggle),radius:cellSize*LevelSection.knotRadius).SetColor(COLOR.red.tomato).SetDepth(1);
if(!drawInfo)
return;
DRAW.Text((section.PathNr+1).ToString(),V2.up*cellSize*(LevelSection.height+3)+-V2.right*2*cellSize,size:3,color:COLOR.yellow.fresh,z:1);
intsegments=0;
for(inti=0;i<section.PathNr+1;i++)
segments+=section.pathes[i].splits.Count+1;
DRAW.Text((segments).ToString(),V2.up*cellSize*(LevelSection.height+3),size:3,color:COLOR.purple.orchid,z:1);
DRAW.Text((section.knots.Count).ToString(),V2.up*cellSize*(LevelSection.height+3)+V2.right*2*cellSize,size:3,color:COLOR.red.tomato,z:1);
privatevoidDrawAvoids()
for(inti=0;i<section.avoidThese.Count;i++)
boolavoiding=section.PathSearch.AvoidingPoint&&section.PathSearch.avoidPoint==i&&!section.Finished;
DRAW.Circle(JigglePos(section.avoidThese[i]*cellSize,jiggle),cellSize*(avoiding?LevelSection.avoidRadius:.5f)).SetColor(avoiding?COLOR.red.tomato:COLOR.green.spring);
DRAW.Rectangle(JigglePos(section.avoidThese[i]*cellSize,jiggle),V2.one*LevelSection.avoidRadius*cellSize*(avoiding?.25f:.2f),Time.timeSinceLevelLoad*100).
SetColor(avoiding?COLOR.red.tomato:COLOR.green.spring).Fill();
publicstaticVector3JigglePos(Vector3pos,floatjiggle)
if(f.Same(jiggle,0))
returnpos;
floattime=Time.timeSinceLevelLoad*2.5f;
returnpos+newVector3(Mathf.PerlinNoise(pos.x*.03f+time,pos.y*.03f+time)-.5f,
Mathf.PerlinNoise(pos.y*.03f+time,pos.x*.03f+time)-.5f,
0)*Level.CellSize*jiggle;
privatevoidDrawCrosses()
for(inti=0;i<section.crossedPoints.Count;i++)
DRAW.Rectangle(JigglePos(section.crossedPoints[i].crossedPoint*cellSize,jiggle),V2.one*cellSize*.1f);
publicclassLevelSectionTest:MonoBehaviour{
publicintseed;
publicintsection_ID;
publicstaticLevelSectionlevelSection;
[Space(10)]
[Range(0,5)]
publicintspeed;
[Range(.001f,1)]
publicfloatstepTime;
publicboolauto;
publicstaticintsolve_Nr;
[Space(10)]
publicintlongestPath;
publicintlongestSectionPathLength;
publicboolCrash{get{returnlevelSection!=null&&levelSection.Crash;}}
privatevoidOnEnable()
levelSection=newLevelSection();
if(auto)
StartCoroutine(AutoSolve());
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space)&&!auto)
StartCoroutine(LevelGen());
if(Input.GetKeyDown(KeyCode.P))
levelSection.AutoSolve(section_ID,seed);
section_ID++;
solve_Nr++;
privateIEnumeratorAutoSolve()
intcount=0;
while(!Crash)
if(speed>0)
yieldreturnStartCoroutine(LevelGen());
yieldreturnnull;
else
StartCoroutine(LevelGen());
count++;
if(count==1000)
count=0;
yieldreturnnull;
Debug.Log("Crashedafter"+solve_Nr+"Generations");
privateIEnumeratorLevelGen()
solve_Nr++;
intsolveNr=solve_Nr;
intstep=0;
levelSection.Setup(section_ID,seed);
WaitForSecondswfs=newWaitForSeconds(stepTime);
while(true&&solveNr==solve_Nr)
if(levelSection.Crash||levelSection.Finished)
break;
levelSection.GenerationStep();
step++;
if(speed>0&&step==speed)
step=0;
yieldreturnwfs;
if(!levelSection.Crash)
if(levelSection.longestPath>longestPath)
longestPath=levelSection.longestPath;
if(levelSection.totalPathLength>longestSectionPathLength)
longestSectionPathLength=levelSection.totalPathLength;
if(speed>0)
yieldreturnnewWaitForSeconds(Mathf.Clamp01(stepTime*20));
section_ID++;
publicclassMoveCamTest:MonoBehaviour
publicfloatspeed;
privatevoidUpdate()
transform.position+=(V3.right*Input.GetAxis("Horizontal")+V3.up*Input.GetAxis("Vertical"))*speed*Time.deltaTime;
publicclassNew_LevelBrain:Singleton<New_LevelBrain>,LevelGenerator
publicintsection_ID,seed;
privatestaticLevelSectionsection;
publicIEnumeratorLoadGame()
yieldbreak;
publicvoidStartGame()
section=newLevelSection();
section.AutoSolve(Inst.section_ID,Inst.seed);
Level.StartStick=Item.Get(1);
for(inti=0;i<section.sticks.Count;i++)
Item.Get(i+1).SetRootPos(section.sticks[i]*Level.CellSize);
publicCellGetCellAt(Vector2IntcellPos)
intcellNum=section.Get_Cell(cellPos);
returncellNum<0?null:section.cells[cellNum];
publicvoidGetDimensions(outVector2Intmin,outVector2Intmax)
min=newVector2Int(0,0);
max=newVector2Int(0,0);
publicCell[]Cells{get;privateset;}
publicboolValidCell(Vector2cellPos)
returntrue;
namespaceGeneration
publicclassNumGen
privateSystem.Randomrandom;
publicvoidSet_Seed(floatseed)
random=newSystem.Random((int)seed);
privatefloatFromSequence()
return(float)random.NextDouble()%1;
publicfloatGet_Float(floata,floatb)
returnMathf.Lerp(a,b,FromSequence());
publicintGet_Int(inta,intb)
returnMathf.FloorToInt(Mathf.Lerp(a,b,FromSequence()));
publicboolOdds_In_100(intnr)
returnnr>=Get_Int(0,101);
publicboolOdds_In_1000(intnr)
returnnr>=Get_Int(0,1001);
namespaceGeneration
publicclassPathSearch
privateconstintmaxLoops=1000;
publicconstintClipSize=2;
publicGenerationLinkGenerationLinkStart;
publicGenerationLinkGenerationLinkGoal;
publicList<Vector2>path
get{returnsection.pathes[section.PathNr].path;}
set{section.pathes[section.PathNr].path=value;}
publicintLength{get{returnpath.Count;}}
privateLevelSectionsection;
privateNumGennumGen;
privateVector2current_Point;
privateintcurrent_Angle;
privateVector2Up;
privateVector2Right;
publicboolUpisUp{get{returnUp==V2.up;}}
publicboolAvoidingPoint{get{returnavoidPoint!=-1;}}
privateboolpassedConnectPoint;
publicboolFinished=true;
publicboolConnectedToPath;
publicintconnectToThis;
publicintavoidPoint;
publicVector2avoid_Dir;
publicVector2GetClip(intside)
if(side==-1)
return-Up*.5f+-V2.right;
else
return-Up*.5f+V2.right;
publicVector2ConnectPoint
get
intconnectAngle=UpisUp?GenerationLinkGoal.In_Angle:GenerationLinkGoal.Out_Angle;
Vector2connectVector=AngleToVector(connectAngle,Up,Right);
returnGenerationLinkGoal.Point-connectVector;
publicVector2AimPoint
get
intconnectAngle=UpisUp?GenerationLinkGoal.In_Angle:GenerationLinkGoal.Out_Angle;
Vector2connectVector=AngleToVector(connectAngle,Up,Right);
if(Mathf.Abs(connectAngle)==45&&f.Same(Mathf.Sign(connectVector.x),-Mathf.Sign(ConnectPoint.x-current_Point.x)))
returnConnectPoint-Up;
else
returnConnectPoint;
publicfloatClipValue(Vector2pos)
Vector2clip=GetClip((int)Mathf.Sign(pos.x));
floathigherClip=(clip*Mathf.Abs(current_Point.x-AimPoint.x)+AimPoint).y;
floatlowerClip=(clip*Mathf.Abs(current_Point.x-AimPoint.x)+AimPoint-Up*ClipSize).y;
returnMathf.InverseLerp(lowerClip,higherClip,current_Point.y)*1.45f;
privateboolCloseToGoal{get{return(Mathf.Round(Mathf.Abs(current_Point.x-GenerationLinkGoal.x))<=1&&Mathf.Round(Mathf.Abs(current_Point.y-GenerationLinkGoal.y))<=1);}}
privateboolCloseToConnect{get{return(Mathf.Round(Mathf.Abs(current_Point.x-ConnectPoint.x))<=1&&Mathf.Round(Mathf.Abs(current_Point.y-ConnectPoint.y))<=1);}}
privateboolAtConnectLevel{get{returnf.Same(Mathf.Round(current_Point.y),Mathf.Round(AimPoint.y));}}
publicvoidReset()
ConnectedToPath=passedConnectPoint=Finished=false;
GenerationLinkStart=GenerationLinkGoal=null;
connectToThis=avoidPoint=-1;
avoid_Dir=V2.zero;
publicvoidSetup(GenerationLinka,GenerationLinkb,LevelSectionsection)
Reset();
this.section=section;
numGen=section.numGen;
boolupSearch=!section.AllLinksAreUsed?section.numGen.Get_Int(0,2)==0:b.y-a.y>0;
if(section.AllLinksAreUsed)
a.Turn_InOut(section,!upSearch);
if(a==null)
upSearch=false;
a=section.GetDummyLink((int)b.Point.x,false);
if(b==null)
upSearch=true;
b=section.GetDummyLink((int)a.Point.x,true);
GenerationLinkStart=!section.AllLinksAreUsed?(upSearch?a:b):a;
GenerationLinkGoal=!section.AllLinksAreUsed?(upSearch?b:a):b;
current_Point=GenerationLinkStart.Point;
section.AddPointToPath(current_Point);
Up=upSearch?V2.up:-V2.up;
Right=Up.Rot(-90);
publicvoidSearchStep()
if(!section.InAvoidZone(current_Point))
avoidPoint=-1;
if(ConnectedToPath)
Finished=true;
else
if(CloseToGoal||AtConnectLevel)
if(CloseToConnect&&!passedConnectPoint||CloseToGoal&&passedConnectPoint)
if(!passedConnectPoint)
current_Point=ConnectPoint;
passedConnectPoint=true;
else
current_Point=GenerationLinkGoal.Point;
Finished=true;
else
current_Point=current_Point+(AimPoint-current_Point).normalized;
if(current_Point==ConnectPoint)
passedConnectPoint=true;
section.IsThisFree(current_Point);
else
NextPathPoint();
if(section.Crash)
return;
section.AddPointToPath(current_Point);
if(!Finished)
return;
GenerationLinkStart.Used=true;
if(!ConnectedToPath)
GenerationLinkGoal.Used=true;
if(!UpisUp)
path.Reverse();
privatevoidNextPathPoint()
inttrys=0;
while(true)
boolHaveToForceSteer=HaveToSteer;
intsteer_Angle=AvoidingPoint?AvoidSteer(trys):Get_SteerAngle(HaveToForceSteer);
inttest_Angle;
if(HaveToForceSteer&&!AvoidingPoint)
floatclipValue=ClipValue(current_Point);
Vector2aimVector=AimPoint-current_Point;
floatangleToGoal=Vector2.Angle(aimVector,Up);
intclosestAngle=f.Same(Mathf.Round(current_Point.x),Mathf.Round(AimPoint.x))?0:(int)(Mathf.Round(angleToGoal/45)*45*Mathf.Sign(AimPoint.x-current_Point.x)*(UpisUp?1:-1));
closestAngle=Mathf.Clamp(closestAngle,current_Angle-90,current_Angle+90);
floatrandomAngle=Mathf.Clamp(current_Angle+steer_Angle,-135,135);
test_Angle=(int)(Mathf.Round(Mathf.Lerp(randomAngle,closestAngle,clipValue))/45)*45;
else
test_Angle=current_Angle+steer_Angle;
if(path.Count==1)
test_Angle=UpisUp?GenerationLinkStart.Out_Angle:GenerationLinkStart.In_Angle;
test_Angle=Mathf.Clamp(test_Angle,-135,135);
Vector2test_Point=current_Point+AngleToVector(test_Angle,Up,Right);
if(AngleOdds(test_Angle,numGen))
if(PointIsFree(test_Point)||path.Count==1)
current_Angle=test_Angle;
current_Point=test_Point;
if(path.Count==1)
section.IsThisFree(test_Point);
break;
else
if(connectToThis!=-1)//&&ClipValue(current_Point)>0
Vector2connectPoint=section.Get_Closest_Point_On_Path(current_Point,connectToThis);
if(connectPoint!=-V2.up)
current_Point=connectPoint;
ConnectedToPath=true;
break;
trys++;
if(trys==maxLoops)
section.Crash=true;
Debug.Log("PathIShouldConnectto:"+connectToThis);
Debug.Log("PathNr:"+section.PathNr);
Debug.Log("HaveToSteer:"+HaveToSteer);
Debug.Log("Clip"+ClipValue(current_Point));
Debug.Log("PathSearchPointIsFree:"+PointIsFree(test_Point));
Debug.Log("SectionFree:"+section.IsThisFree(test_Point));
Debug.Log("heightRange"+InHeightRange(test_Point));
Debug.Log(test_Angle+"****"+(Mathf.Sign(AimPoint.x-current_Point.x))+"old:"+current_Point+"new:"+test_Point);
Vector2crossPoint=current_Point+(test_Point-current_Point)*.5f;
Debug.Log("CanCross:"+section.CanICross(crossPoint));
Debug.Log("UPISUP"+UpisUp);
Debug.Log(Mathf.Round(Vector2.Angle(AimPoint-current_Point,Up)/45)*45);
if(avoidPoint!=-1)
Vector3aimDir=AngleToVector(current_Angle,Up,Right);
Vector3toPoint=section.avoidThese[avoidPoint]-current_Point;
floatlR=Mathf.Clamp(Mathf.RoundToInt(vector3Ext.LeftOrRight(aimDir,toPoint)),-1,1);
Debug.Log("LEFTORRIGHT:"+lR);
break;
publicvoidAvoidThisPoint(intnr)
avoidPoint=nr;
publicboolAvoid_To_Top(Vector2pos)
if(UpisUp)
returnMathf.Round(section.avoidThese[avoidPoint].y)<=Mathf.Round(pos.y);
else
returnMathf.Round(section.avoidThese[avoidPoint].y)>=Mathf.Round(pos.y);
publicenumSteerCommand
None,
HorizontalStraight,
Steer_Up,
Emergency
privateintAvoidSteer(inttrys)
Vector3aimDir=AngleToVector(current_Angle,Up,Right);
Vector3toPoint=section.avoidThese[avoidPoint]-current_Point;
floatlR=Mathf.Clamp(Mathf.RoundToInt(vector3Ext.LeftOrRight(aimDir,toPoint)),-1,1);
SteerCommandsteerCommand=SteerCommand.None;
if(f.Same(lR,0))
if(f.Same(Vector2.Dot(aimDir,Up),1))
lR=section.numGen.Get_Int(0,2)==0?-1:1;
if(f.Same(Mathf.Abs(Vector2.Dot(aimDir,Right)),1))
lR=-Mathf.RoundToInt(vector3Ext.LeftOrRight(aimDir,Up));
steerCommand=SteerCommand.HorizontalStraight;
if((trys>maxLoops*.75f&&numGen.Odds_In_100(50))||Vector2.Dot(aimDir,Up)<0&&!Avoid_To_Top(current_Point))
lR*=-1;
steerCommand=SteerCommand.Emergency;
if(Avoid_To_Top(current_Point)&&!f.Same(aimDir.x,0))
if(f.Same(Mathf.Sign(aimDir.x),1)&&UpisUp||f.Same(Mathf.Sign(aimDir.x),-1)&&!UpisUp)
lR=1;
else
lR=-1;
steerCommand=SteerCommand.Steer_Up;
intlR_Angle=current_Angle+((int)(section.numGen.Get_Int(1,3)*-lR*45));
floatangleToGoal=Vector2.Angle(aimDir,Up);
intclosestAngle=f.Same(Mathf.Round(current_Point.x),Mathf.Round(AimPoint.x))?0:(int)(Mathf.Round(angleToGoal/45)*45);
floatlerp=numGen.Get_Float(0,1);
closestAngle=Mathf.RoundToInt(Mathf.Lerp(closestAngle,lR_Angle,lerp)/45)*45;
closestAngle=Mathf.Clamp(closestAngle,current_Angle-90,current_Angle+90);
if(trys==maxLoops-1)
Debug.Log("shit"+(closestAngle));
Debug.Log("POINTBEFORE:"+path[path.Count-2]+"was"+section.InAvoidZone(path[path.Count-2]));
Debug.Log("AvoidtoTop:"+Avoid_To_Top(path[path.Count-2]));
Debug.Log("LR:"+Mathf.Clamp(Mathf.RoundToInt(vector3Ext.LeftOrRight(aimDir,toPoint)),-1,1));
Debug.Log("SteerCommand:"+steerCommand);
DRAW.Vector(current_Point*Level.CellSize,AngleToVector(current_Angle,Up,Right)*Level.CellSize).SetColor(Color.white).SetDepth(10);
returnclosestAngle-current_Angle;
privateintGet_SteerAngle(boolsteerToGoal)
intangleDifference;
while(true)
if(steerToGoal&&f.Same(current_Point.x,AimPoint.x))
angleDifference=(int)(section.numGen.Get_Int(1,3)*Mathf.Sign(AimPoint.x-current_Point.x)*(UpisUp?1:-1));
else
angleDifference=section.numGen.Get_Int(-2,3);
if(SteerOdds(angleDifference))
break;
returnangleDifference*45;
privateboolPointIsFree(Vector2position)
if(!InHeightRange(position))
returnfalse;
Vector2crossPoint=Vector2.Lerp(current_Point,position,.5f);
if(!section.CanICross(crossPoint))
returnfalse;
if(!section.IsThisFree(position))
returnfalse;
returnConnectedToPath||true;
publicboolInHeightRange(Vector2position)
intY=(int)Mathf.Round(position.y);
returnUpisUp?(Y>=1&&Y<=AimPoint.y):(Y>=AimPoint.y&&Y<=LevelSection.height-1);
privateboolHaveToSteer
get
boolisFine=RangeOdds(current_Point.x);
if(isFine)
if(ClipValue(current_Point)>0)
isFine=false;
if(!isFine)
Vector2clipMiddle=AimPoint+V2.up*(UpisUp?-ClipSize:ClipSize);
if(f.Same(Mathf.Round(current_Point.x),Mathf.Round(AimPoint.x))&&f.Same(Mathf.Round(current_Point.y),Mathf.Round(clipMiddle.y)))
isFine=true;
if(!isFine)
Vector2currentAim=Up.Rot(current_Angle);
Vector2toMiddle=-V2.right*(AimPoint.x-current_Point.x);
if(Vector2.Dot(currentAim,toMiddle)>0)
intY=(int)Mathf.Round(current_Point.y);
if(UpisUp&&Y<AimPoint.y-ClipSize||!UpisUp&&Y>AimPoint.y+ClipSize)
isFine=true;
if(section.InAvoidZone(current_Point))
isFine=false;
return!isFine;
publicstaticVector2AngleToVector(intangle,Vector2Up,Vector2Right)
switch(angle)
default:returnUp;
case-45:returnUp+-Right;
case-90:return-Right;
case-135:return-Up+-Right;
case-180:return-Up;
case45:returnUp+Right;
case90:returnRight;
case135:return-Up+Right;
case180:return-Up;
privateboolSteerOdds(intangle_Step)
switch(Mathf.Abs(angle_Step))
default:returnfalse;
case0:returnnumGen.Odds_In_100(30);
case1:returnnumGen.Odds_In_100(95);
case2:returnnumGen.Odds_In_100(10);
publicstaticboolAngleOdds(intangle,NumGenrandom_Nr)
switch(Mathf.Abs(angle))
default:returnfalse;
case0:returnrandom_Nr.Odds_In_100(15);
case45:returnrandom_Nr.Odds_In_100(80);
case90:returnrandom_Nr.Odds_In_100(70);
case135:returnrandom_Nr.Odds_In_100(25);
privateboolRangeOdds(floatx)
intxInt=(int)Mathf.Abs(x);
intstandardRange=Mathf.FloorToInt(LevelSection.width*.5f);
intclampedX=Mathf.Clamp(xInt-(standardRange+1),0,100);
switch(clampedX)
default:returnfalse;
case0:returntrue;
case1:returnnumGen.Odds_In_100(6);
case2:returnnumGen.Odds_In_100(3);
publicstaticclassDatabase
[Switch("Dev/SkipServerStuff")]privatestaticboolSkipServerStuff=false;
publicstaticboolIsConnected;
publicstaticintServerVersion,
PlayerScore,
PlayerRank;
privateconstintGameVersion=3;
publicstaticIEnumeratorInitServerConnection()
IsConnected=false;
if(SkipServerStuff)
Debug.Log("SkippingServerStuff".B_Purple());
GameManager.ChangeState(GameManager.GameState.GameLoad);
yieldbreak;
yieldreturnGetServerVersion();
if(!IsConnected)
GameManager.ChangeState(GameManager.GameState.GameLoad);
yieldbreak;
if(ServerVersion!=GameVersion)
Debug.Log("WrongVersion");
yieldbreak;
stringcheckName=BotPlayers.RandomName;
yieldreturnGetPlayerScore(checkName);
yieldreturnGetPlayerRank(checkName);
yieldreturnGetDay();
yieldreturnGetServerTime();
yieldreturnGetCombineReplays();
GameManager.ChangeState(GameManager.GameState.GameLoad);
publicstaticIEnumeratorGetServerVersion()
UnityWebRequestwww=UnityWebRequest.Get(GetServerVersionPHP);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
IsConnected=false;
Debug.Log("ConnectiontoServerfailed".B_Red());
Debug.LogFormat("{0}".B_Red(),www.error);
else
ServerVersion=int.Parse(www.downloadHandler.text);
Debug.Log("ServerVersion:"+ServerVersion);
IsConnected=true;
www.Dispose();
publicstaticIEnumeratorGetPlayerScore(stringname)
WWWFormform=newWWWForm();
form.AddField("i",BotPlayers.GetNameID(name));
UnityWebRequestwww=UnityWebRequest.Post(GetPlayerScorePHP,form);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.LogFormat("Couldn'tget{0}Score".B_Red(),name);
else
Debug.Log(name+"->Score->"+www.downloadHandler.text);
www.Dispose();
publicstaticIEnumeratorGetPlayerRank(stringname)
WWWFormform=newWWWForm();
form.AddField("i",BotPlayers.GetNameID(name));
UnityWebRequestwww=UnityWebRequest.Post(GetPlayerRankPHP,form);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.LogFormat("Couldn'tget{0}Rank".B_Red(),name);
else
Debug.Log(name+"->Rank->"+www.downloadHandler.text);
www.Dispose();
publicstaticIEnumeratorGetScoreCount()
UnityWebRequestwww=UnityWebRequest.Get(GetScoreCountPHP);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.Log("Couldn'tdownloadScoreCount".B_Red());
else
Debug.Log("DatabaseScoreCount:"+www.downloadHandler.text);
www.Dispose();
publicstaticIEnumeratorGetCombineReplays()
UnityWebRequestwww=UnityWebRequest.Get(CombinedReplaysPHP);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.LogFormat("Couldn'tgetcombineReplays".B_Red());
else
byte[]returnBytes=www.downloadHandler.data;
intlength=returnBytes.Length;
ByteReplays.ResetCount();
ByteStream.Set(returnBytes);
while(ByteStream.stream.Position<length)
if(!ByteReplays.AddReplay())
break;
if(ByteReplays.Count>0)
Debug.LogFormat("Got{0}Replays-Size:{1:F1}kb",ByteReplays.Count,length/1024f);
www.Dispose();
publicstaticIEnumeratorGetDay()
UnityWebRequestwww=UnityWebRequest.Get(GetDayPHP);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.Log("Couldn'tgetDay".B_Red());
else
Debug.Log("Day:"+www.downloadHandler.text);
www.Dispose();
publicstaticIEnumeratorGetServerTime()
UnityWebRequestwww=UnityWebRequest.Get(ServerTimePHP);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.Log("Couldn'tgetServertime".B_Red());
else
Debug.Log("Servertime:"+www.downloadHandler.text);
www.Dispose();
privateconststring
Server="http://checkandiout.com/spinnerdb/",
Info=Server+"info/",
Player=Server+"player/";
publicconststring
GetServerVersionPHP=Info+"getServerVersion.php",
GetDayPHP=Info+"getDay.php",
ServerTimePHP=Info+"servertime.php",
GetBoardPHP=Info+"getTablejSON.php",
GetPlayerScorePHP=Player+"getPlayerScore.php",
GetPlayerRankPHP=Player+"getPlayerRank.php",
LoginPHP=Server+"login.php",
CombinedReplaysPHP=Server+"combineReplays.php",
GetScoreCountPHP=Server+"getScoreCount.php",
GetRandomReplayPHP=Server+"getRandomReplay.php",
UploadScorePHP=Server+"uploadScore.php";
publicclassLeaderboard:Singleton<Leaderboard>
[Switch("UI/LeaderBoard")]publicstaticboolshowLeaderBoard=false;
publicGameObjectpanel,tableLine;
publicTransformlineHolder;
publicAnimationCurvetableLerp;
privateRectTransformmyRect;
privateVector3endPos,startPos,gonePos;
privateGameObject[]lines;
publicstaticboolvisible;
privatevoidAwake()
myRect=GetComponent<RectTransform>();
endPos=myRect.anchoredPosition3D;
Vector3upVector=Quaternion.AngleAxis(myRect.localEulerAngles.z,transform.forward)*V3.right;
startPos=endPos+upVector*1400;
gonePos=endPos+upVector*-1400;
lines=newGameObject[10];
for(inti=0;i<10;i++)
GameObjectnewLine=Instantiate(tableLine,lineHolder,false);
RectTransformlineRect=newLine.GetComponent<RectTransform>();
lineRect.anchoredPosition3D=newVector3(0,i*-60,0);
lineRect.localEulerAngles=Vector3.zero;
lines[i]=newLine;
lines[i].GetComponent<TableLine>().SetLine((i+1).ToString(),"",0);
myRect.anchoredPosition3D=startPos;
privatevoidOnEnable()
panel.SetActive(false);
privatestaticvoidSetLine(intnr,stringname,intscore)
Inst.lines[nr].GetComponent<TableLine>().SetLine((nr+1).ToString(),name,score);
privatevoidShowHideTable(boolshow)
if(visible!=show)
visible=show;
StartCoroutine(SlideInOut(show));
privateIEnumeratorSlideInOut(boolcomeIn)
panel.SetActive(true);
floatlerp=0;
Vector3startP=(comeIn)?startPos:endPos;
Vector3endP=(comeIn)?endPos:gonePos;
while(lerp<1)
lerp+=Time.deltaTime*3;
myRect.anchoredPosition3D=Vector3.Lerp(startP,endP,tableLerp.Evaluate(lerp));
yieldreturnnull;
panel.SetActive(visible);
/*privatevoidUpdate()
if(visible&&KeyMap.AnyInput)
ShowHideTable(false);
publicstaticvoidGetBoard()
if(showLeaderBoard)
Inst.StartCoroutine(Inst.GetOnlineLeaderboard());
publicIEnumeratorGetOnlineLeaderboard(intstart=0)
WWWFormform=newWWWForm();
form.AddField("o",start);
form.AddField("l",10);
UnityWebRequestwww=UnityWebRequest.Post(Database.GetBoardPHP,form);
yieldreturnwww.SendWebRequest();
if(www.isNetworkError||www.isHttpError)
Debug.Log("Couldn'tdownloadLeaderboard".B_Red());
else
JSONNodejsonNode=JSON.Parse(www.downloadHandler.text);
for(inti=0;i<jsonNode.Count;i++)
SetLine(i,jsonNode[i][0].ToString().Replace("\"",""),int.Parse(jsonNode[i][1].ToString().Replace("\"","")));
Inst.ShowHideTable(true);
www.Dispose();
publicclassTableLine:MonoBehaviour{
publicTextMeshProUGUIpos,playerName,score;
[Space(5)]
publicColor[]blinkColors;
publicvoidSetLine(stringrank,stringname,intscore)
pos.text=rank;
conststringempty="...";
boolisEmpty=score==0||name=="";
playerName.text=isEmpty?empty:name;
this.score.text=isEmpty?empty:score.ToString();
ColorsetColor=name==UserSave.Name?blinkColors[0]:newColor(1,1,1,1);
pos.color=playerName.color=this.score.color=setColor;
if(name==UserSave.Name&&score==UserSave.Highscore)
StartCoroutine(Blink());
privatereadonlyWaitForSecondswait=newWaitForSeconds(.15f);
privateIEnumeratorBlink()
intcolorPick=0;
while(Leaderboard.visible)
colorPick=(colorPick+1)%blinkColors.Length;
pos.color=blinkColors[colorPick];
playerName.color=blinkColors[colorPick];
score.color=blinkColors[colorPick];
yieldreturnwait;
publicclassActorDebug:MonoBehaviour
privateTextMeshProUGUItext;
publicRectTransformimage;
privatereadonlyStringBuilderstringBuilder=newStringBuilder(10000,10000);
privateintmax;
privatevoidAwake()
text=GetComponent<TextMeshProUGUI>();
privatevoidUpdate()
if(!GameManager.Running)
return;
stringBuilder.Length=0;
max=Mathf.Max(max,Level.itemCount);
stringBuilder.Append(Level.itemCount.PrepString().PadLeft(3)+"<"+max.PrepString().PadLeft(3));
stringBuilder.Append("\n");
intlength=ActorAnimator.actorLists.Length;
for(inti=0;i<length;i++)
ActorAnimator.actorLists[i].AddInfo(stringBuilder,i==length-1);
text.text=stringBuilder.ToString();
text.rectTransform.sizeDelta=newVector2(text.preferredWidth,text.preferredHeight);
image.sizeDelta=newVector2(text.preferredWidth+20,text.preferredHeight+20);
publicabstractclassPoolObject:IEquatable<PoolObject>
privatestaticintpoolIndex;
protectedPoolObject()
poolID=poolIndex++;
publicreadonlyintpoolID;
publicboolEquals(PoolObjectother)
returnother!=null&&poolID==other.poolID;
publicoverrideboolEquals(objectobj)
returnobj!=null&&((PoolObject)obj).poolID==poolID;
publicoverrideintGetHashCode()
returnpoolID;
publicclassPool<T>:IPoolInfowhereT:PoolObject
privatereadonlystringname;
privateintsize;
publicT[]all;
privatereadonlyStack<T>inactive;
privatereadonlyFunc<T>_creator;
publicintActiveElementCount{get{returnsize-inactive.Count;}}
publicPool(Func<T>instanceCreator,intsize)
_creator=instanceCreator;
this.size=size;
inactive=newStack<T>(size);
all=newT[size];
for(inti=0;i<size;i++)
Tthing=_creator.Invoke();
inactive.Push(thing);
all[i]=thing;
name=""+all[0].ToString().Split('.').Last();
PoolInfo.infos.Add(this);
publicTGetFree()
Tthing;
if(inactive.Count>0)
thing=inactive.Pop();
else
Debug.LogFormat("\"{0}\"-Poolneedstoberesized!CurrentSize:{1}",name,size);
thing=_creator.Invoke();
Array.Resize(refall,1);
size++;
all[size-1]=thing;
returnthing;
publicvoidReset()
inactive.Clear();
intcount=all.Length;
for(inti=0;i<count;i++)
inactive.Push(all[i]);
publicvoidReturn(Tthing)
inactive.Push(thing);
publicvoidAddDebugInfo(StringBuilderstringBuilder,boollast)
if(AlmostAtCapacity)
stringBuilder.Append(FancyString.B_Start("yellow"));
stringBuilder.
Append(name.PadRight(18)).
Append(ActiveElementCount.PrepString().PadLeft(6)).
Append("/").
Append(size.PrepString().PadRight(6)).
Append("kb");
if(!last)
stringBuilder.Append("\n");
if(AlmostAtCapacity)
stringBuilder.Append(FancyString.B_End);
publicboolAlmostAtCapacity{get{return(float)ActiveElementCount/size>.9f;}}
publicinterfaceIPoolInfo
voidAddDebugInfo(StringBuilderstringbuilder,boollast);
boolAlmostAtCapacity{get;}
publicstaticclassPoolInfo
publicstaticreadonlyList<IPoolInfo>infos=newList<IPoolInfo>();
publicclassPoolDebug:MonoBehaviour
privateTextMeshProUGUItext;
publicRectTransformimage;
privatereadonlyStringBuilderstringBuilder=newStringBuilder(10000,10000);
privatevoidAwake()
text=GetComponent<TextMeshProUGUI>();
privatevoidUpdate()
stringBuilder.Length=0;
intlength=PoolInfo.infos.Count;
for(inti=0;i<length;i++)
PoolInfo.infos[i].AddDebugInfo(stringBuilder,i==length-1);
text.text=stringBuilder.ToString();
text.rectTransform.sizeDelta=newVector2(text.preferredWidth,text.preferredHeight);
image.sizeDelta=newVector2(text.preferredWidth+20,text.preferredHeight+20);
publicstaticclassAntiAliasingToggle
[Switch("Visuals/AA")]publicstaticboolIsEnabled=true;
publicclassSetRenderPipeline:MonoBehaviour
[Switch("Visuals/UseLWRPonPC")]privatestaticboolpcUsesLWRP=true;
publicRenderPipelineAssetpipeLine;
privatevoidLateUpdate()
boolshouldUse=!(DRAW.SomethingToDRAW||Wireframe.Active)&&(Application.isMobilePlatform||pcUsesLWRP);
if(GraphicsSettings.renderPipelineAsset!=null!=shouldUse)
GraphicsSettings.renderPipelineAsset=shouldUse?pipeLine:null;
QualitySettings.antiAliasing=AntiAliasingToggle.IsEnabled?8:0;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
publicstaticvoidRegister()
SceneManager.sceneLoaded+=PutInScene;
privatestaticvoidPutInScene(Scenescene,LoadSceneModemode)
newGameObject("SetRenderPipeline").AddComponent<SetRenderPipeline>().pipeLine=Resources.Load<RenderPipelineAsset>("Rendering/LWRP");
publicpartialclassSpinner
publicconstintCount=4;
privatestaticreadonlySpinner[]spinner=newSpinner[Count];
privatestaticreadonlyList<Spinner>inactive=newList<Spinner>(Count);
publicstaticreadonlyList<Spinner>active=newList<Spinner>(Count);
publicstaticreadonlySpinnerDummy=newSpinner();
privatestaticSpinnerplayer,focus;
publicstaticClipCurrentPlayerClip,CurrentFocusClip;
privatestaticreadonlyItem[]CurrentGrabItems=newItem[Count];
privatestaticreadonlySwing[]CurrentSwingClips=newSwing[Count];
publicstaticboolSetGameOver;
publicstaticvoidGameLoad()
ObjectmRig=Resources.Load("Rig");
for(inti=0;i<Count;i++)
Rigrig=(Object.Instantiate(mRig)asGameObject).GetComponent<Rig>();
rig.name="Rig"+i;
rig.transform.SetParent(SceneLocator.Characters);
spinner[i]=newSpinner(i,rig);
publicstaticSpinnerGet(intspinnerID)
if(spinnerID>=Count)
Debug.Log("SpinnerIDtoobigforgetting:"+spinnerID);
spinnerID=0;
returnspinner[spinnerID];
publicstaticvoidAllStateUpdate()
intactiveCount=active.Count;
for(inti=0;i<activeCount;i++)
active[i].StateUpdate(active[i].isPlayer&&KeyMap.CheckInput());
if(SetGameOver)
GameManager.ChangeState(GameManager.GameState.GameOver);
SetGameOver=false;
activeCount=active.Count;
for(inti=0;i<Count;i++)
CurrentGrabItems[i]=null;
CurrentSwingClips[i]=null;
for(inti=0;i<activeCount;i++)
Swingswing=active[i].currentClipasSwing;
if(swing!=null)
intid=active[i].ID;
CurrentGrabItems[id]=swing.GetStick(GTime.Now).Item;
CurrentSwingClips[id]=swing;
if(activeCount>0&&focus==null)
focus=active[0];
if(activeCount>1&&Input.GetKeyDown(KeyCode.Tab))
for(inti=0;i<activeCount;i++)
if(active[i]==focus)
focus=active[(i+1)%activeCount];
break;
CurrentFocusClip=focus!=null?focus.currentClip:null;
if(KeyMap.Down(Key.Dev_CostumeColor))
for(inti=0;i<activeCount;i++)
active[i].rig.ColorizeMesh();
publicstaticvoidAllPoseUpdate()
intactiveCount=active.Count;
Profiler.BeginSample("Spinner.AllPoseUpdate()");
for(inti=0;i<activeCount;i++)
active[i].PoseRig();
Profiler.EndSample();
Profiler.BeginSample("TapeTrimming");
floatrewindTime=ShakeRewind.CheckTime-GTime.RewindTime;
for(inti=0;i<activeCount;i++)
active[i].tape.ClearBefore(rewindTime);
Profiler.EndSample();
publicstaticvoidUpdateOffsets(Spinnerspinner)
intactiveCount=active.Count;
for(inti=0;i<activeCount;i++)
if(active[i]!=spinner)
Jumpjump=active[i].currentClipasJump;
if(jump!=null)
jump.UpdateOffset();
publicstaticSpinnerGetPlayer
get
intactiveCount=active.Count;
for(inti=0;i<activeCount;i++)
if(active[i].isPlayer)
returnactive[i];
returnnull;
publicstaticSwingGetSwingClip(intspinnerID,Itemitem)
returnCurrentGrabItems[spinnerID]==item?CurrentSwingClips[spinnerID]:null;
publicstaticboolIsBeingGrabbed(Itemitem)
for(inti=0;i<Count;i++)
if(CurrentGrabItems[i]==item)
returntrue;
returnfalse;
publicstaticvoidToggleSkins(boolshow)
for(inti=0;i<Count;i++)
spinner[i].rig.ToggleSkin(show);
publicstaticvoidSetColorScheme(CostumeColorscostume)
active[0].rig.SetCostume(costume);
namespaceAnim
publicstructPlacement
publicreadonlyVector3pos;
publicreadonlyQuaternionrot;
publicPlacement(Vector3pos,Quaternionrot)
this.pos=pos;
this.rot=rot;
publicPlacement(Vector3pos,floatangle)
this.pos=pos;
rot=Rot.Z(angle);
publicstaticPlacementLerp(PlacementplacementA,PlacementplacementB,floatlerp)
returnnewPlacement(Vector3.Lerp(placementA.pos,placementB.pos,lerp),
Quaternion.Slerp(placementA.rot,placementB.rot,lerp));
publicstaticVector3PosLerp(PlacementplacementA,PlacementplacementB,floatlerp)
returnVector3.Lerp(placementA.pos,placementB.pos,lerp);
publicstaticPlacementOutOfSight=newPlacement(V3.away,Rot.Zero);
publicstaticPlacementZero=newPlacement(V3.zero,Quaternion.identity);
publicstaticbooloperator==(Placementa,Placementb)
returna.pos==b.pos&&a.rot==b.rot;
publicstaticbooloperator!=(Placementa,Placementb)
returna.pos!=b.pos||a.rot!=b.rot;
publicstaticPlacementoperator-(Placementa,Placementb)
returnnewPlacement(a.pos-b.pos,a.rot*Quaternion.Inverse(b.rot));
publicstaticPlacementoperator+(Placementa,Placementb)
returnnewPlacement(a.pos+b.pos,a.rot*b.rot);
publicvoidDebugIfNaN(stringname)
if(float.IsNaN(pos.x))
Debug.LogFormat("{0}_Xisfucked",name);
if(float.IsNaN(pos.y))
Debug.LogFormat("{0}_Yisfucked",name);
publicstructStickID
publicreadonlyItemItem;
publicreadonlyboolhands;
publicintSign{get{returnhands?1:-1;}}
publicintSerializeValue{get{return(Item.ID+1)*Sign;}}
publicStickID(ItemItem,boolhands)
this.Item=Item;
this.hands=hands;
publicboolSameAs(ItemotherItem)
if(otherItem==null)
Debug.Log("Can'tcompareStickIDtoOtherItemsinceit's"+"null!".B_Red());
returnfalse;
returnItem==otherItem;
publicclassCostume
privatereadonlysbytehead,torso,arms,legs;
publicCostume(){}
privateCostume(sbytehead,sbytetorso,sbytearms,sbytelegs)
this.head=head;
this.torso=torso;
this.arms=arms;
this.legs=legs;
publicstaticvoidSerialize(Costumecostume,BinaryWriterwriter)
writer.Write(costume.head);
writer.Write(costume.torso);
writer.Write(costume.arms);
writer.Write(costume.legs);
publicstaticCostumeDeserialize(BinaryReaderreader)
returnnewCostume(reader.ReadSByte(),reader.ReadSByte(),reader.ReadSByte(),reader.ReadSByte());
publicclassPose
publicconstintLean=0,
TumbleT=1,
TumbleB=2,
BendT=3,
BendB=4,
TurnT=5,
TurnB=6,
Length=7;
privatereadonlyfloat[]values=newfloat[Length];
publicstaticreadonlyPoseReader=newPose();
publicPoseZero()
values[Lean]=0;
values[TumbleT]=0;
values[TumbleB]=0;
values[BendT]=0;
values[BendB]=0;
values[TurnT]=.25f;
values[TurnB]=.25f;
returnthis;
publicPoseSet(intpart,floatvalue)
values[part]=value;
returnthis;
publicPoseCopy(Poseother)
for(inti=0;i<Length;i++)
values[i]=other[i];
returnthis;
publicfloatthis[intindex]{get{returnvalues[index];}}
publicStringBuilderGetInfo(StringBuilderwriter,string[]names,boolreset=true)
if(reset)
writer.Length=0;
for(inti=0;i<Length;i++)
writer.Append(names[i]).Append(GetValueString(i)).Append(i<Length-1?"\n":"");
returnwriter;
privatestringGetValueString(intindex)
floatvalue=values[index];
returnvalue>0?"+"+value.ToString("F4"):value<0?value.ToString("F4"):"0.0000";
publicclassBoundary:Singleton<Boundary>
/*staticBoundary()
pool=newClipBoundPool(1000);
publicboolshowBounds;
publicstaticfloatmeetStart,meetEnd;
/*privatestaticreadonlyClipBoundPoolpool;*/
publicstaticvoidGameStart()
return;
for(inti=0;i<Spinner.Count;i++)
Inst.boundarys[i].Reset(i);
publicstaticvoidClear(intID)
return;
Inst.boundarys[ID].Reset(ID);
publicstaticvoidGameUpdate()
return;
Profiler.BeginSample("BoundaryUpdate");
for(inti=0;i<Spinner.Count;i++)
Inst.boundarys[i].Update(GTime.Now-GTime.RewindTime);
Profiler.EndSample();
publicstaticvoidSetNewClip(Clipclip)
return;
Profiler.BeginSample("BoundarySet");
if(clip.Type!=0)
Inst.boundarys[clip.spinner.ID].SetClip(clip);
Profiler.EndSample();
publicSpinnerBoundary[]boundarys=CollectionInit.Array<SpinnerBoundary>(Spinner.Count);
[System.Serializable]
publicclassSpinnerBoundary
publicList<ClipBounds>cBounds=newList<ClipBounds>(100);
privateClipcurrentClip;
privatefloatclipStartTime,boundsEnd;
publicintID;
privateboolgotAllBounds;
publicvoidReset(intID)
return;
this.ID=ID;
while(cBounds.Count>0)
cBounds.RemoveAt(0);
clipStartTime=0;
currentClip=null;
publicvoidSetClip(Clipclip)
return;
if(currentClip==clip||clipStartTime>clip.startTime)
return;
clipStartTime=clip.startTime;
if(currentClip!=null)
intcount=cBounds.Count;
while(true)
if(count==0||cBounds[count-1].startTime<clipStartTime)
break;
count--;
cBounds.RemoveAt(count);
if(count!=0)
cBounds[cBounds.Count-1].endTime=clipStartTime;
currentClip=clip;
boundsEnd=cBounds[cBounds.Count-1].endTime;
publicvoidUpdate(floatrewindTime)
return;
if(currentClip!=null&&!gotAllBounds)
floatforwardLook=Mathf.Max(clipStartTime,GTime.Now)+ClipBounds.ForwardLook;
boundsEnd=cBounds[cBounds.Count-1].endTime;
intcount=cBounds.Count;
for(inti=0;i<count;i++)
if(cBounds[i].endTime<rewindTime)
count--;
i--;
/*usingSystem.Collections;
publicstaticclassClubMaster
[Switch("Tape/ActiveClub")]privatestaticboolActiveClub=false;
[Switch("Tape/SpawnRadius")]privatestaticboolDebugSpawn=false;
privateconstintmemberCount=2;
publicconstfloatSpawnRadius=60;
publicconstfloatSpawnRadiusSqrt=SpawnRadius*SpawnRadius;
privatestaticreadonlyClubMember[]clubMembers=newClubMember[memberCount];
publicstaticvoidGameLoad()
if(!ActiveClub)
return;
for(inti=0;i<clubMembers.Length;i++)
clubMembers[i]=newClubMember(i+1);
publicstaticvoidGameStart()
if(!ActiveClub)
return;
for(inti=0;i<memberCount;i++)
clubMembers[i].Disable(false);
publicstaticvoidGameOver()
if(!ActiveClub)
return;
for(inti=0;i<memberCount;i++)
clubMembers[i].Disable(false);
publicstaticvoidClubUpdate()
if(!ActiveClub||!GameManager.Running)
return;
Profiler.BeginSample("ClubMaster.ClubUpdate()");
for(inti=0;i<clubMembers.Length;i++)
clubMembers[i].Update();
if(DebugSpawn)
DRAW.Circle(GameCam.frustum.focusPoint,SpawnRadius).SetColor(COLOR.orange.coral).SetDepth(Z.P);
Profiler.EndSample();
publicclassClubMember
[Switch("Log/Club")]privatestaticboolDebugClub=false;
privateenumState{Idle,GettingTape,GotTape,TryingToSpawn,Playing,Sleeping}
publicreadonlyintID;
privateStatestate;
privatestringname;
privateCostumecostume;
privatefloatlastSeen;
privatefloatsleepTime;
privatereadonlyfloat[]shifts=newfloat[100];
publicClubMember(intID)
this.ID=ID;
publicvoidDisable(boolsleep)
if(DebugClub)Debug.LogFormat("DisablingClubMember{0}".B(ID),ID);
if(sleep)
state=State.Sleeping;
sleepTime=Time.realtimeSinceStartup;
switch(state)
caseState.Playing:
Spinner.Get(ID).Disable();
gotocaseState.TryingToSpawn;
caseState.TryingToSpawn:
Tape.Get(ID).Clear();
break;
publicvoidUpdate()
switch(state)
caseState.Idle:
GetReplay();
break;
caseState.GotTape:
Run.Inst.StartCoroutine(Spawn(false));
break;
caseState.Playing:
if(Spinner.Get(ID).IsVisible)
lastSeen=GTime.Now;
if(GTime.Now-lastSeen>GTime.RewindTime*2||Tape.Get(ID).clipCount==0)
if(DebugClub)
Debug.LogFormat("ClubMember{0}hasn'tbeenseenforawhile".B(ID),ID);
Disable(true);
break;
caseState.Sleeping:
if(Time.realtimeSinceStartup-sleepTime>5)
state=State.Idle;
break;
privatevoidGetReplay()
state=State.GettingTape;
if(DebugClub)
Debug.LogFormat("TryingtoGetReplayForClubMember{0}".B(ID),ID);
Run.Inst.StartCoroutine(ReplaySaveLoad.GetWebReplay(this));
publicvoidFoundReplay(stringname,Costumecostume)
state=State.GotTape;
this.name=name;
this.costume=costume;
if(DebugClub)Debug.LogFormat("FoundReplayforClubMember{0}".B(ID),ID);
publicvoidNotFoundReplay()
Disable(true);
privateIEnumeratorSpawn(boolcouldBeInFrustum)
state=State.TryingToSpawn;
constfloatmaxCompPerFrame=1f/60/3;
floatcompStartTime=Time.realtimeSinceStartup;
Tapetape=Tape.Get(ID);
floatstartOffset=Mathf.Ceil((GTime.Now-tape.Length)/GTime.LoopTime)*GTime.LoopTime;
floatendOffset=Mathf.Ceil(GTime.LoopCount)*GTime.LoopTime;
floatcheckLength=endOffset-startOffset;
Vector2size=Spinner.Get(ID).size;
intshiftCount=0;
for(floati=0;i<checkLength;i+=GTime.LoopTime)
if(shiftCount>=shifts.Length)
break;
floatshift=endOffset-i;
tape.SetTimeShift(shift);
Clipclip=Tape.Get(ID).GetClip(GTime.Now);
if(clip==null||clip.Type.IsNotPlaying())
continue;
Vector2pos=clip.BasicPlacement(GTime.Now).pos;
if(((Vector2)GameCam.frustum.focusPoint-pos).sqrMagnitude>ClubMaster.SpawnRadiusSqrt)
continue;
boolrewindIsClear=true;
for(intj=0;j<GTime.RewindTime;j++)
Vector2rewindPos=clip.BasicPlacement(GTime.Now-j).pos;
if(GameCam.IsThisVisible(rewindPos,size.y)&&(!couldBeInFrustum||!SpawnAnyway(rewindPos)))
rewindIsClear=false;
break;
if(Time.realtimeSinceStartup-compStartTime>=maxCompPerFrame)
compStartTime=Time.realtimeSinceStartup;
yieldreturnnull;
if(rewindIsClear)
shifts[shiftCount]=shift;
shiftCount++;
if(Time.realtimeSinceStartup-compStartTime>=maxCompPerFrame)
compStartTime=Time.realtimeSinceStartup;
yieldreturnnull;
if(shiftCount==0)
if(DebugClub)Debug.LogFormat("ClubMember{0}can'tbespawned:".B(ID),ID,shiftCount);
Disable(true);
yieldbreak;
if(DebugClub)Debug.LogFormat("SpawningClubMember{0}".B(ID),+ID);
state=State.Playing;
tape.SetTimeShift(shifts[Random.Range(0,shiftCount)]);
Spinner.Get(ID).Enable(name,costume,Brain.Player);
lastSeen=GTime.Now;
privatestaticboolSpawnAnyway(Vector2pos)
constfloatminSqrDistance=10*10;
boolspawnAnyway=Random.Range(0,4)==0&&(pos-GameCam.StartPos).sqrMagnitude>minSqrDistance;
if(spawnAnyway)
Debug.Log("SpawningClubmemberinView...Derp".B_Hex("#C091B1"));
returnspawnAnyway;
publicclassCurves:Singleton<Curves>
publicAnimationCurveswingLeanAnim,cameraBounce;
[Header("Notinuse..........")]
publicAnimationCurvesquashNStretch;
publicAnimationCurvestickFriction,stickPump;
publicstaticAnimationCurveSwingLeanAnim{get{returnInst.swingLeanAnim;}}
publicstaticAnimationCurveCameraBounce{get{returnInst.cameraBounce;}}
publicstaticAnimationCurveSquashNStretch{get{returnInst.squashNStretch;}}
publicstaticAnimationCurveStickFriction{get{returnInst.stickFriction;}}
publicstaticAnimationCurveStickPump{get{returnInst.stickPump;}}
publicclassJumpInfo
privateconstintMaxProxItems=200;
privateconstintSliceSteps=4;
publicconstfloatStepLength=1f/SliceSteps;
publicconstfloatSearchRange=4;
publicintproxCount;
publicreadonlyProxItem[]proxItems=CollectionInit.Array<ProxItem>(MaxProxItems);
privatereadonlyPathSlicepathSlice=newPathSlice();
staticJumpInfo()
itemProxList=newProxItem[Item.TotalCount];
checkItems=newItem[MaxProxItems];
trackCallCheck=newint[Item.TotalCount+Track.TotalCount];
proxCheck=newint[Item.TotalCount];
privatestaticreadonlyProxItem[]itemProxList;
privatestaticreadonlyItem[]checkItems;
privatestaticintcheckCount;
privatestaticintcallID;
privatestaticreadonlyint[]trackCallCheck;
privatestaticintproxID;
privatestaticreadonlyint[]proxCheck;
publicvoidAnalyze(Jumpjump)
Profiler.BeginSample("JumpInfo_Analize");
floatsearchTime=jump.WillHit?jump.duration:6;
floatradius=jump.spinner.size.y*SearchRange;
floatradiusSqr=radius*radius;
floateventTime=jump.startTime;
Vector2startPos=jump.startPos;
Vector2lastMidPoint=startPos;
proxID++;
proxCount=0;
pathSlice.Setup(SliceSteps,startPos,jump.jumpV,radius,jump.startSide,Mask.AnyThing);
ItemjumpStick=jump.stick.Item;
ItemgrabStick=jump.WillConnect?jump.nextStick.Item:null;
booljumpUp=jump.jumpV.y>0;
boolgrabUp=jump.WillConnect&&pathSlice.flyPath.GetMV(searchTime).y>0;
floatapexTime=pathSlice.flyPath.apexTime;
intslice=-1;
while(true)
slice++;
pathSlice.CheckSlice(pathSlice.GetBounds(slice,StepLength));
if(pathSlice.ContainsNoItem)
floattime=StepLength*SliceSteps*(slice+1);
if(time>=searchTime)
break;
lastMidPoint=pathSlice.flyPath.GetPos(time);
continue;
for(intstep=0;step<SliceSteps;step++)
intstepNumber=slice*SliceSteps+step;
floatflightTime=StepLength*stepNumber;
floattime=eventTime+flightTime;
if(flightTime>=searchTime||proxCount==MaxProxItems)
if(proxCount==MaxProxItems)
Debug.Log("Nooo");
gotoSearchOver;
Vector2midPoint=pathSlice.flyPath.GetPos(flightTime);
Vector2motion=pathSlice.flyPath.GetMV(flightTime);
boolmotionUp=motion.y>0;
Bounds2Db=newBounds2D(midPoint).Add(lastMidPoint).Pad(radius);
/*if(flightTime-StepLength<=apexTime&&flightTime>=apexTime)
Bounds2D.Helper.Add(pathSlice.flyPath.GetPos(apexTime));*/
checkCount=0;
for(inti=0;i<pathSlice.itemCount;i++)
Itemitem=pathSlice.items[i];
if((!item.Equals(jumpStick)||jumpUp!=motionUp)&&
(!item.Equals(grabStick)||grabUp!=motionUp)&&
item.bounds.Intersects(b))
checkItems[checkCount++]=item;
callID++;
for(inti=0;i<pathSlice.trackCount;i++)
Tracktrack=pathSlice.trackSubBounds[i].track;
floatminDist=radius+track.maxItemRadius;
floattrackDist=(track.GetClosestPoint(midPoint)-midPoint).sqrMagnitude;
if(trackDist>minDist*minDist)
continue;
intgotItems=0;
for(intsubBound=0;subBound<track.subBoundCount;subBound++)
if(pathSlice.trackSubBounds[i].validSubBounds[subBound])
Track.SubBoundsB=track.GetSubBound(subBound);
if(sB.Intersects(b))
if(trackCallCheck[track.ID]!=callID)
track.FillSubBounds(time,Mask.AnyThing);
trackCallCheck[track.ID]=callID;
for(intsubI=0;subI<sB.itemCount;subI++)
Itemitem=sB.items[subI];
if(trackCallCheck[item.ID]!=callID&&
(!item.Equals(jumpStick)||jumpUp!=motionUp)&&
(!item.Equals(grabStick)||grabUp!=motionUp))
checkItems[checkCount]=item;
checkCount++;
gotItems++;
trackCallCheck[item.ID]=callID;
if(gotItems>=track.itemCount)
break;
for(inti=0;i<checkCount;i++)
Itemitem=checkItems[i];
Vector2itemPos=item.GetPos(time);
Vector2charDir=newVector2(midPoint.x-itemPos.x,midPoint.y-itemPos.y);
if(charDir.sqrMagnitude<=radiusSqr)
if(proxCheck[item.ID]!=proxID||!itemProxList[item.ID].IsTheSame(time,motionUp))
/*if(proxCheck[item.ID]==proxID)
Debug.Log("NewMissFor"+item.ID+""+itemProxList[item.ID].endTime+"|"+time);*/
proxCheck[item.ID]=proxID;
itemProxList[item.ID]=proxItems[proxCount];
proxItems[proxCount++].New(item,time,charDir,motion);
else
itemProxList[item.ID].Update(time,charDir,motion);
if(proxCount==MaxProxItems)
Debug.Log("Toomanymisses");
break;
lastMidPoint=midPoint;
SearchOver:;
Profiler.EndSample();
publicstaticclassMood
[Switch("Char/Mood")]privatestaticboolshowMood;
privatestaticfloatupdateMood,updateTime;
publicstaticvoidReset()
updateMood=.5f;
updateTime=GTime.Now;
publicstaticvoidOnSwing(floattime)
if(showMood&&time>updateTime)
updateMood=Mathf.Clamp01(GetMood(time)+.03f);
updateTime=time;
publicstaticvoidOnJump(floattime)
/*if(time>updateTime)
updateTime=time;
mood+=.1f;
publicstaticvoidUpdate()
if(!showMood)
return;
floatmood=GetMood(GTime.Now);
floatwidth=Screen.width-40;
floatmoodWidth=width*mood;
floatnonMoodWidth=width-moodWidth;
constfloatbarY=54,barHeight=12;
DRAW.Rectangle(newVector2(20+width-nonMoodWidth*.5f,barY),newVector2(nonMoodWidth,barHeight)).ToScreen().SetColor(Color.black).Fill(.2f,true);
Colorcolor=Color.Lerp(mood<.5f?Color.Lerp(Color.red,Color.yellow,mood*2):Color.Lerp(Color.yellow,Color.cyan,mood*2-1),Color.white,.1f);
DRAW.Rectangle(newVector2(20+moodWidth*.5f,barY),newVector2(moodWidth,barHeight)).ToScreen().SetColor(color).Fill(.65f,true);
privatestaticfloatGetMood(floattime)
returnMathf.Min(updateMood,Mathf.Clamp01(updateMood-(time-updateTime)*.01f));
namespaceFuture
publicstaticpartialclassPrediction
staticPrediction()
pathSlices=newPathSlice[3];
for(inti=0;i<3;i++)
pathSlices[i]=newPathSlice();
MovedItems.Init();
checkItems=newItem[200];
callCheck=newint[Item.TotalCount+Track.TotalCount];
publicconstfloatCheckAngle=6;//16;
privateconstintSliceSteps=10;
privatestaticreadonlyPathSlice[]pathSlices;
privatestaticreadonlyPathSlicemainSlice=newPathSlice();
privatestaticSpinnerspinner;
privatestaticVector2startPos,jumpV;
privatestaticfloatstartAngle,eventTime,spin,hitTime,weightLerp,spinAccel;
privatestaticSideside;
privatestaticStickIDoldStick;
privatestaticClipTypenextClip;
privatestaticItemhitItem;
privatestaticFlyPathflyPath;
privatestaticreadonlyItem[]checkItems;
privatestaticintcheckCount;
privatestaticintitemCallID,trackCallID;
privatestaticreadonlyint[]callCheck;
privatestaticboolDone{get{returnnextClip!=0;}}
publicstaticClipJumpCheck(floateventTime,Spinnerspinner,Vector2startPos,floatweightLerp,QuaternionstartRot,Vector2jumpV,floatspin,StickIDoldStick)
Prediction.spinner=spinner;
Prediction.weightLerp=weightLerp;
startAngle=startRot.eulerAngles.z.Wrap(-180,180).DigitRound(2);
Prediction.startPos=startPos+Swing.GetWeightForce(startRot,spin,weightLerp,oldStick.hands);
Prediction.eventTime=eventTime;
side=oldStick.Item.side;
Prediction.oldStick=oldStick;
Prediction.jumpV=jumpV;
Prediction.spin=spin;
hitTime=0;
nextClip=0;
hitItem=null;
returnGetPredictionClip();
privatestaticClipGetPredictionClip()
if(DebugPrediction)
ResetShow();
Profiler.BeginSample("Prediction.GetPredictionClip");
floatradius=spinner.size.y*.5f;
Vector2stickMV=oldStick.Item!=null?oldStick.Item.GetMV(eventTime)*.25f:V2.zero;
for(intdir=0;dir<3;dir++)
pathSlices[dir].Setup(SliceSteps,startPos,(jumpV.Rot(CheckAngle*-.5f+CheckAngle*.5f*dir)+stickMV).DigitClamp(2),radius,side,Mask.IsItem);
jumpV=pathSlices[1].flyPath.startMV;
mainSlice.Setup(SliceSteps,startPos,jumpV,radius,side,Mask.IsItem);
floatsearchTime=Mathf.Min(6,GPhysics.Get_SpinStopTime(spin));
intsearchSteps=Mathf.CeilToInt(GPhysics.StepsPerSecond*searchTime);
intnumberOfSlices=Mathf.CeilToInt((float)searchSteps/SliceSteps);
Vector2halfBody=newVector2(0,(spinner.size.y-spinner.size.x)*.5f);
for(intslice=0;slice<numberOfSlices;slice++)
if(Done)break;
Bounds2Db=pathSlices[0].GetBounds(slice,GPhysics.TimeStep).
Add(pathSlices[1].GetBounds(slice,GPhysics.TimeStep)).
Add(pathSlices[2].GetBounds(slice,GPhysics.TimeStep));
mainSlice.CheckSlice(b);
if(mainSlice.ContainsNoItem)
continue;
for(intstep=0;step<SliceSteps;step++)
intstepCount=slice*SliceSteps+step;
if(Done||stepCount==searchSteps)
break;
MovedItems.Reset();
floatflightTime=stepCount*GPhysics.TimeStep;
floattime=eventTime+flightTime;
trackCallID++;
for(intdir=0;dir<3;dir++)
if(Done)break;
Vector2lastMid=pathSlices[dir].lastMidpoint;
Vector2midPoint=pathSlices[dir].flyPath.GetPos(flightTime);
Linemove=newLine(lastMid,midPoint);
if(DebugPrediction)
checkLines[dir].Add(move);
pathSlices[dir].lastMidpoint=midPoint;
Bounds2DmidBound=newBounds2D(midPoint).Add(lastMid).Pad(radius);
checkCount=0;
for(inti=0;i<mainSlice.itemCount;i++)
if((!oldStick.Item.Equals(mainSlice.items[i])||stepCount>2)&&mainSlice.items[i].bounds.Intersects(midBound))
checkItems[checkCount++]=mainSlice.items[i];
itemCallID++;
for(inti=0;i<mainSlice.trackCount;i++)
Tracktrack=mainSlice.trackSubBounds[i].track;
floatminDist=radius+track.maxItemRadius;
floattrackDist=(track.GetClosestPoint(midPoint)-midPoint).sqrMagnitude;
if(trackDist>minDist*minDist)
continue;
intgotItems=0;
for(intsubBound=0;subBound<track.subBoundCount;subBound++)
if(mainSlice.trackSubBounds[i].validSubBounds[subBound])
Track.SubBoundsB=track.GetSubBound(subBound);
if(sB.Intersects(midBound))
if(callCheck[track.ID]!=trackCallID)
track.FillSubBounds(time,Mask.IsItem);
callCheck[track.ID]=trackCallID;
for(intsubI=0;subI<sB.itemCount;subI++)
Itemitem=sB.items[subI];
if((!oldStick.Item.Equals(item)||stepCount>2)&&
callCheck[item.ID]!=itemCallID)
checkItems[checkCount++]=item;
gotItems++;
callCheck[item.ID]=itemCallID;
if(gotItems>=track.itemCount)
break;
for(inti=0;i<checkCount;i++)
if(!MovedItems.AlreadyMoved(checkItems[i],dir))
MovedItems.Add(checkItems[i],time);
for(inti=0;i<MovedItems.Count;i++)
MovedItemsmovedItem=MovedItems.Get(i);
if(MovedItems.moved[movedItem.item.ID][dir]!=MovedItems.checkID)
continue;
Itemitem=movedItem.item;
floatminDistSqr=Mth.IntPow(radius+item.radius,2);
if(move.LineIsCloserSqr(movedItem.move,minDistSqr))
if(Mask.CanBeGrabbed.Fits(item.elementType))
nextClip=ClipType.Swing;
else
floatcheckAngle=startAngle+GPhysics.Get_SpinAngle_Deg(spin,flightTime);
Vector2bodyLine=halfBody.Rot(checkAngle);
Vector2feetPos=midPoint-bodyLine;
Vector2handPos=midPoint+bodyLine;
floatitemRadiusSqr=Mth.IntPow(spinner.size.x*.5f+item.radius,2);
if(newLine(feetPos,handPos).SqrDistance(movedItem.move.l1)<=itemRadiusSqr)
nextClip=ClipType.Bump;
if(DebugPrediction)
showBump=true;
if(Done)
hitItem=item;
hitTime=flightTime;
jumpV=pathSlices[dir].flyPath.startMV;
flyPath=pathSlices[dir].flyPath;
if(DebugPrediction)
bestDir=dir;
break;
Profiler.EndSample();
switch(nextClip)
caseClipType.Swing:returnGetSwingClip();
caseClipType.Bump:returnGetBumpClip();
default:returnGetFailClip();
privatestaticClipGetSwingClip()
floatsqrtRadius=Mth.IntPow(spinner.ConnectRadius(hitItem),2);
constfloatsteps=10;
constfloattinyStep=GPhysics.TimeStep/steps;
for(inti=0;i<steps;i++)
floatcheckTime=hitTime-GPhysics.TimeStep+i*tinyStep;
Vector2midPoint=flyPath.GetPos(checkTime);
Vector2stickPos=hitItem.GetLagPos(eventTime+checkTime);
Vector2midToStick=newVector2(stickPos.x-midPoint.x,stickPos.y-midPoint.y);
if(midToStick.sqrMagnitude<=sqrtRadius)
hitTime=checkTime;
break;
hitTime=hitTime.DigitCeil(2);
returnoldStick.Item!=null?
Clip.Get_Jump(spinner,eventTime,startAngle,jumpV,spin.DigitRound(3),hitTime,oldStick,weightLerp,nextClip,side):
Clip.Get_AirLaunch(spinner,eventTime,startAngle,jumpV,spin.DigitRound(3),hitTime,startPos,nextClip,side);
privatestaticClipGetBumpClip()
Vector2collisionLine=newVector2(0,spinner.size.y-spinner.size.x);
floattinyStep=GPhysics.TimeStep*.5f;
floatflightTime=hitTime;
floatitemRadiusSqr=Mth.IntPow(spinner.size.x*.5f+hitItem.radius,2);
flightTime-=tinyStep;
for(intu=0;u<5;u++)
tinyStep*=.5f;
Vector2midPoint=flyPath.GetPos(flightTime);
floatcheckAngle=startAngle+GPhysics.Get_SpinAngle_Deg(spin,flightTime);
Vector2bodyLine=collisionLine.Rot(checkAngle);
Vector2handPos=midPoint+bodyLine*.5f;
Vector2feetPos=midPoint-bodyLine*.5f;
Vector2itemPos=hitItem.GetLagPos(eventTime+flightTime);
if(newLine(feetPos,handPos).SqrDistance(itemPos)<=itemRadiusSqr)
hitTime=flightTime;
flightTime-=tinyStep;
if(DebugPrediction)
b1=feetPos;
b2=handPos;
else
flightTime+=tinyStep;
returnoldStick.Item!=null?
Clip.Get_Jump(spinner,eventTime,startAngle,jumpV,spin.DigitRound(3),hitTime.DigitRound(2),oldStick,weightLerp,nextClip,side):
Clip.Get_AirLaunch(spinner,eventTime,startAngle,jumpV,spin.DigitRound(3),hitTime.DigitRound(2),startPos,nextClip,side);
privatestaticClipGetFailClip()
returnoldStick.Item!=null?
Clip.Get_Jump(spinner,eventTime,startAngle,jumpV,spin,hitTime,oldStick,weightLerp,nextClip,side):
Clip.Get_AirLaunch(spinner,eventTime,startAngle,jumpV,spin,hitTime,startPos,nextClip,side);
publicclassMovedItems
staticMovedItems()
items=newMovedItems[100];
publicstaticintCount;
privatestaticreadonlyMovedItems[]items;
publicstaticint[][]moved;
publicstaticintcheckID;
publicstaticvoidInit()
for(inti=0;i<items.Length;i++)
items[i]=newMovedItems();
moved=newint[Item.TotalCount][];
for(inti=0;i<Item.TotalCount;i++)
moved[i]=newint[3];
publicstaticvoidReset()
checkID++;
Count=0;
publicstaticMovedItemsGet(intindex){returnitems[index];}
publicstaticvoidAdd(Itemitem,floattime)
items[Count++].Set(item,time);
publicstaticboolAlreadyMoved(Itemitem,intdir)
boolmovedAlready=moved[item.ID][0]==checkID||moved[item.ID][1]==checkID||moved[item.ID][2]==checkID;
moved[item.ID][dir]=checkID;
returnmovedAlready;
publicItemitem;
publicLinemove;
privatevoidSet(Itemitem,floattime)
this.item=item;
move=newLine(item.GetLagPos(time),item.GetLagPos(time-GPhysics.TimeStep));
publicclassPathSlice
privateintsteps;
publicVector2lastMidpoint;
privatefloatradius;
privateSideside;
publicFlyPathflyPath;
publicreadonlyItem[]items=newItem[400];
publicreadonlyTrackSubBounds[]trackSubBounds=CollectionInit.Array<TrackSubBounds>(50);
publicintitemCount,trackCount;
publicboolContainsNoItem{get{returnitemCount==0&&trackCount==0;}}
privateElementMaskfilter;
privateBounds2Dbounds;
publicvoidSetup(intsteps,Vector2startPos,Vector2jumpV,floatradius,Sideside,ElementMaskfilter)
this.steps=steps;
flyPath=newFlyPath(startPos,jumpV);
this.radius=radius;
this.side=side;
this.filter=filter;
publicvoidCheckSlice(Bounds2DcheckBounds)
Search.ItemsAndTracks(checkBounds,side,filter);
itemCount=Search.itemCount;
for(inti=0;i<itemCount;i++)
items[i]=Search.boundItems[i];
trackCount=0;
for(inti=0;i<Search.trackCount;i++)
Tracktrack=Search.boundTracks[i];
trackSubBounds[trackCount].GetValidSubBounds(track,checkBounds);
if(trackSubBounds[trackCount].allAreIntersecting)
for(inte=0;e<track.itemCount;e++)
if(filter.Fits(track.items[e].elementType))
items[itemCount++]=track.items[e];
else
trackCount++;
publicBounds2DGetBounds(intsliceNumber,floatstepLength)
floattimeA=Mathf.Max(0,sliceNumber*steps*stepLength-stepLength);
floattimeB=(sliceNumber+1)*steps*stepLength;
lastMidpoint=flyPath.GetPos(timeA);
Vector2posB=flyPath.GetPos(timeB);
bounds=newBounds2D(lastMidpoint).Add(posB);
if(timeA<=flyPath.apexTime&&timeB>=flyPath.apexTime)
bounds=bounds.Add(flyPath.GetPos(flyPath.apexTime));
bounds=bounds.Pad(radius);
returnbounds;
publicclassTrackSubBounds
publicTracktrack;
publicreadonlybool[]validSubBounds=newbool[20];
publicboolallAreIntersecting;
publicvoidGetValidSubBounds(Tracktrack,Bounds2DcheckBounds)
this.track=track;
allAreIntersecting=true;
if(track.subBoundCount==1)
return;
for(inti=0;i<track.subBoundCount;i++)
validSubBounds[i]=track.GetSubBound(i).Intersects(checkBounds);
if(!validSubBounds[i])
allAreIntersecting=false;
publicstaticpartialclassPrediction
[Switch("Dev/ShowPrediction")]privatestaticboolDebugPrediction;
privatestaticreadonlyList<Line>[]checkLines={newList<Line>(100),newList<Line>(100),newList<Line>(100)};
privatestaticfloatcheckRadius,checkThickness;
privatestaticboolshowBump;
privatestaticVector2b1,b2;
privatestaticintbestDir;
privatestaticvoidResetShow()
for(inti=0;i<3;i++)
checkLines[i].Clear();
checkRadius=spinner.size.y*.5f;
checkThickness=spinner.size.x*.5f;
showBump=false;
bestDir=1;
publicstaticvoidShowPrediction()
if(!DebugPrediction)
return;
for(inti=0;i<3;i++)
intlength=checkLines[i].Count;
if(length==0)
continue;
Colorc;
switch(i)
default:c=Color.red;break;
case1:c=Color.white;break;
case2:c=Color.green;break;
for(inte=0;e<length;e++)
checkLines[i][e].DrawShell(checkRadius).SetColor(c.A(.15f)).SetDepth(Z.W05);
if(i==bestDir)
DRAW.Circle(checkLines[i][length-1].GetL2(),checkRadius*.5f,24).SetColor(c.A(.3f)).SetDepth(Z.W05).Fill(.15f);
if(showBump)
newLine(b1,b2).DrawShell(checkThickness,true).SetColor(Color.yellow).SetDepth(Z.W05);
namespaceFuture
publicclassProxItem
publicItemitem;
publicfloatstartTime,endTime,closestTime,closestDist;
publicVector2closestDir,closestMotion;
publicboolupMotion;
publicintImportance{get{return(int)Mathf.Clamp((endTime-startTime)*4,0,3);}}
privateconstfloatStep=JumpInfo.StepLength;
publicboolIsTheSame(floattime,boolmotionUp)
returnMathf.Approximately(time,endTime)&&upMotion==motionUp;
publicvoidNew(Itemitem,floattime,Vector2dir,Vector2motion)
this.item=item;
startTime=closestTime=time;
endTime=time+Step;
closestDir=dir;
closestMotion=motion;
closestDist=dir.sqrMagnitude;
upMotion=motion.y>0;
publicvoidUpdate(floattime,Vector2dir,Vector2motion)
endTime=time+Step;
floatdist=dir.sqrMagnitude;
if(closestDist>dist)
closestDist=dist;
closestTime=time;
closestDir=dir;
closestMotion=motion;
publicboolDebugIsGoingOn(floattime)
returnstartTime<=time&&endTime>time;
publicclassRigHelp:MonoBehaviour
[System.Serializable]
publicclassPart
publicTransformtip;
publicTransformroot;
publicfloatlength;
publicVector3localPos;
publicvoidSetup()
localPos=root.localPosition;
length=Vector3.Distance(root.position,tip.position);
publicPart[]parts;
[Space(10)]
publicVector2size;
publicCircleAllignallign;
[Space(10)]
[Range(-180f,180f)]
publicfloatstartAngle;
[Range(-180f,180f)]
publicfloatzRot;
privatevoidAwake()
for(inti=0;i<parts.Length;i++)
parts[i].Setup();
parts[i].root.GetChild(0).GetComponent<MeshFilter>().mesh.Colorize();
privatevoidLateUpdate()
floatdistance=Mathf.SmoothStep(size.x,size.y,Mathf.PingPong(zRot,90)/90f)*.5f;
QuaternionzRotation=Rot.Y(zRot);
for(inti=0;i<parts.Length;i++)
Vector3rotatedPartPos=zRotation*parts[i].localPos;
floatradiusOffset=distance+rotatedPartPos.x;
Vector3[]points=GetPointsOnCircle(parts[i].length,radiusOffset,rotatedPartPos.y,startAngle);
parts[i].root.localPosition=points[0]+Vector3.forward*rotatedPartPos.z;
parts[i].root.rotation=Quaternion.FromToRotation(Vector3.up,points[1]-points[0])*zRotation;
privateVector3[]GetPointsOnCircle(floatsegmentLength,floatradiusOffset,floatstartoffset,floatstartAngle)
Vector3[]returnPoints=newVector3[2];
floatradius=allign.animRadius+radiusOffset;
floatangleA=GetAngleOnCircle(startoffset,radius);
floatangleB=GetAngleOnCircle(startoffset+segmentLength,radius);
returnPoints[0]=V3.up.RotZ(startAngle+angleA,radius);
returnPoints[1]=V3.up.RotZ(startAngle+angleB,radius);
returnreturnPoints;
privatestaticfloatGetAngleOnCircle(floatlength,floatradius)
return2*Mathf.Asin(length/2/radius)*Mathf.Rad2Deg;
publicpartialclassSpinner
privateSpinner(){}
privateSpinner(intID,Rigrig)
this.ID=ID;
this.rig=rig;
rig.Setup(this);
size=rig.poser.size.RotY(90);
tape=newTape(ID==0);
Disable();
publicreadonlyintID;
publicreadonlyRigrig;
publicstringname;
publicCostumecostume;
publicVector3size;
publicreadonlyTapetape;
publicboolvisible{get;privateset;}
publicClipcurrentClip{get;privateset;}
publicPlacementcurrentPlacement{get;privateset;}
publicfloatstartTime;
publicboolisPlayer;
publicboolisFocus
get{returnthis==focus;}
publicfloatConnectRadius(Itemitem=null)
returnsize.y*.5f+(item!=null?item.radius:Item.DefaultRadius);
publicfloatGetZShift(floattime)
constfloatrange=1.3f;
/*floatcloseLerp=Boundary.CloseLerp(ID);
returnID==0?-.6f*closeLerp:.6f*closeLerp;*/
return0;
/*returnMathf.Sin(time*2)*1.5f;
switch(ID)
default:return0;
case1:returnrange;
case2:return-range;
publicvoidEnable(ByteReplayreplayData)
name=replayData.charName;
costume=replayData.costume;
replayData.DeserializeClips(this,true);
isPlayer=false;
SetActive();
publicvoidEnable(stringname,Costumecostume)
this.name=name;
this.costume=costume;
startTime=GTime.LastLoopPoint;//GTime.Now-GTime.LoopTime;
tape.SetClip(Clip.Get_Clip_Spawn(this,startTime,Level.StartStick.side));
isPlayer=true;
SetActive();
privatevoidSetActive()
active.AddUnique(this);
inactive.Remove(this);
rig.poser.SetActive(true);
rig.ColorizeMesh();
publicvoidDisable()
inactive.AddUnique(this);
active.Remove(this);
currentClip=null;
if(isPlayer)
isPlayer=false;
CurrentPlayerClip=null;
if(focus==this)
focus=null;
tape.Clear();
visible=false;
Squash.ResetAllFor(this);
rig.poser.SetActive(false);
privatevoidStateUpdate(boolgotInput)
if(gotInput&&
currentClip!=null&&
currentClip.Type.IsAnySwing())
Swingswing=(Swing)currentClip;
ClipjumpClip=swing.GetJumpData(GTime.LastFrame,this);
tape.SetClip(jumpClip);
ClipnewClip=tape.GetClip(GTime.Now);
if(currentClip!=newClip)
currentClip=newClip;
currentClip.Enable();
if(isPlayer)
CurrentPlayerClip=currentClip;
if(isPlayer&&
currentClip!=null&&
!currentClip.Type.IsAnySwing()&&
currentClip.Type!=ClipType.Dead&&
currentClip.BasicPlacement(GTime.Now).pos.y<0)
tape.SetClip(Clip.PoolClip(ClipType.Dead,this,GTime.Now,currentClip.startSide));
privatevoidPoseRig()
if(currentClip==null||currentClip.Type==0)
return;
currentPlacement=currentClip.FinalPlacement(GTime.Now);
boolisInFrustum=GameCam.frustum.InFrustum(newBounds2D(currentPlacement.pos).Pad(size.y*.5f),currentClip.GetSide(GTime.Now).front);
if(visible!=isInFrustum)
visible=!visible;
rig.poser.SetActive(visible);
if(visible)
rig.poser.SetPose(currentPlacement,currentClip.ReadPose(GTime.Now),GetSquash(GTime.Now));
rig.debug.Update();
publicfloatGetSquash(floattime)
returnSquash.GetSquash(this,time);
publicClipGetClip(floattime)
returntape.GetClip(time);
publicvoidClearClipsAfter(floattime)
tape.ClearAfter(time);
publicbyte[]GetReplayBytes()
returntape.GetReplayBytes();
publicstaticclassSpinnerDebug
[Switch("Jump/JumpLines")]privatestaticboolpredictionLines=false;
[Switch("Jump/ConnectionShapes")]privatestaticboolpredictionShapes=false;
[Switch("Jump/SearchStepInfo")]privatestaticboolstepInfo=false;
[Switch("Jump/NearGrabs")]privatestaticboolnearGrabs=false;
[Switch("Jump/NearGets")]privatestaticboolnearGets=false;
[Switch("Jump/Zappy")]privatestaticboolshowZappy=false;
[Switch("Char/RigPlane")]privatestaticboolshowRigPlane=false;
[Switch("Info/Jump")]privatestaticboolshowJumpInfo=false;
[Switch("Dev/SearchBounds")]privatestaticboolsearchBounds=false;
[Switch("Dev/CloseEnough")]privatestaticboolcloseEnough=false;
[Switch("Bounds/Player")]privatestaticboolshowPlayerBounds=false;
[Switch("Char/ShadowPlacement")]privatestaticboolshowShadowPlacement=false;
[Switch("Char/MV")]privatestaticboolshowMV=false;
[Switch("Char/SquashVis")]privatestaticboolsquashVis=false;
staticSpinnerDebug()
anchorPath=newList<Vector2>(50);
midPath=newList<Vector2>(20);
privatestaticList<Vector2>anchorPath,midPath;
privatestaticColormidPointColor;
privatestaticVector3detectionPoint;
privatestaticClipclip;
privatestaticJumpjump;
privatestaticFlyPathflyPath;
privatestaticSwing_swing;
privatestaticvoidCreateJumpInfo()
jump=(Jump)clip;
flyPath=jump.flyPath;
Vector2startPos=jump.startPos;
floatcharHeight=clip.spinner.size.y;
Vector2startgrabPoint=startPos+V2.up.Rot(jump.startAngle)*charHeight*(jump.nextStick.hands?.5f:-.5f);
if(predictionShapes)
detectionPoint=jump.nextStick.Item!=null?jump.nextStick.Item.GetLagPos(GTime.Now+jump.duration):V2.down*1000;
if(predictionLines)
floatduration=jump.WillHit?jump.duration:3;
if(jump.WillConnect)
anchorPath=GetPath(startPos,startgrabPoint-startPos,jump.jumpV,jump.startSpin,duration,anchorPath);
else
anchorPath.Clear();
midPointColor=jump.WillConnect?COLOR.grey.light:COLOR.purple.maroon;
midPath=GetPath(startPos,V3.zero,jump.jumpV,jump.startSpin,duration,midPath);
privatestaticList<Vector2>GetPath(Vector2startPos,Vector2anchorV,Vector2jumpV,floatspin,floattime,List<Vector2>points)
constfloatrange=.05f;
intmax=Mathf.CeilToInt(time/range)+1;
FlyPathflyPath=newFlyPath(startPos,jumpV);
points.Clear();
for(inti=0;i<max;i++)
floatcheckTime=i<max-1?i*range:time;
Vector2newPos=flyPath.GetPos(checkTime);
Vector2anchorPos=anchorV==V2.zero?V2.zero:anchorV.Rot(GPhysics.Get_SpinAngle_Deg(spin,checkTime));
points.Add(newPos+anchorPos);
returnpoints;
publicstaticvoidDebugUpdate()
if(!GameManager.Running||GameManager.Mode!=Mode.SpinUp)
return;
ClipnewClip=Spinner.CurrentFocusClip;
if(newClip==null)
return;
if(clip!=newClip)
clip=newClip;
switch(clip.Type)
caseClipType.Jump:CreateJumpInfo();break;
caseClipType.Swing:_swing=(Swing)clip;break;
Placementplacement=clip.spinner.currentPlacement;
Vector3midPoint=placement.pos;
Quaternionrotation=placement.rot;
floatheight=clip.spinner.size.y;
switch(clip.Type)
caseClipType.Jump:DebugJump(midPoint,rotation,height);break;
caseClipType.Swing:DebugSwing(midPoint);break;
if(showRigPlane)
Vector3hands=midPoint+V3.forward*Level.PlaneOffset+rotation*V3.up*(height*.5f+Item.DefaultRadius);
Vector3center=midPoint+V3.forward*Level.PlaneOffset;
Vector3feet=midPoint+V3.forward*Level.PlaneOffset+rotation*V3.up*(height*-.5f-Item.DefaultRadius);
Vector3dir=-V3.forward*Level.PlaneOffset*2;
DRAW.Vector(center,dir).SetColor(COLOR.blue.deepsky);
DRAW.Vector(hands,dir).SetColor(COLOR.green.spring);
DRAW.Vector(feet,dir).SetColor(COLOR.green.spring);
for(inti=0;i<20;i++)
DRAW.Vector(hands+dir*((float)i/19),feet-hands).SetColor(Color.white.A(.2f));
if(showShadowPlacement)
PlacementshadowP=clip.BasicPlacement(GTime.Now,true);
Vector2heightV=shadowP.rot*V2.up*clip.spinner.size.y*.5f*clip.spinner.GetSquash(GTime.Now);
DRAW.Arrow(shadowP.pos,heightV,.2f).SetColor(COLOR.red.tomato).SetDepth(Level.GetWallDist(clip.GetSide(GTime.Now),.1f)).Fill(1);
DRAW.Arrow(shadowP.pos,-heightV,.2f).SetColor(COLOR.blue.cornflower).SetDepth(Level.GetWallDist(clip.GetSide(GTime.Now),.1f)).Fill(1);
if(showPlayerBounds)
intactiveCount=Spinner.active.Count;
for(inti=0;i<activeCount;i++)
Spinnerspinner=Spinner.active[i];
ClipcurrentClip=spinner.currentClip;
Sideside=currentClip.GetSide(GTime.Now);
Colorcolor=spinner.visible?side.front?COLOR.yellow.fresh:COLOR.blue.cornflower
:side.front?COLOR.red.tomato:COLOR.purple.orchid;
DRAW.ZappRectangle(currentClip.FinalPlacement(GTime.Now).pos,V2.one*spinner.size.y,16,.1f,.1f).SetColor(color).SetDepth(Level.GetPlaneDist(side));
if(showMV)
ClipspinnerClip=Spinner.CurrentFocusClip;
if(spinnerClip!=null)
Vector3pos=spinnerClip.FinalPlacement(GTime.Now).pos;
Vector3mV=spinnerClip.GetMV(GTime.Now);
DRAW.Arrow(pos,mV,.3f).SetColor(Color.yellow).Fill(1);
if(squashVis)
floatsquash=clip.spinner.GetSquash(GTime.Now);
Vector3size=clip.spinner.size;
size=newVector3(Mathf.Abs(size.x),Mathf.Abs(size.y),Mathf.Abs(size.z)).VolumeScaleY(squash);
floatvisHeight=Screen.height*.1f;
Colorc=squash<=1f?Color.Lerp(COLOR.purple.maroon,COLOR.red.tomato,squash):Color.Lerp(COLOR.red.tomato,COLOR.yellow.fresh,squash-1);
Vector2pos=newVector2(Screen.width-visHeight,Screen.height*.5f);
Vector2drawSize=newVector2(size.z,size.y)*visHeight;
DRAW.Rectangle(pos+newVector2(visHeight*.1f,visHeight*-.1f),drawSize).ToScreen().SetColor(Color.black).Fill(.18f,true);
DRAW.Rectangle(pos,drawSize).ToScreen().SetColor(c).Fill(.85f,true);
DRAW.Vector(pos+newVector2(visHeight*-1,visHeight*clip.spinner.size.y*.5f),newVector3(visHeight*2,0,0)).ToScreen().SetColor(Color.white.A(.5f));
DRAW.Vector(pos+newVector2(visHeight*-1,visHeight*clip.spinner.size.y*-.5f),newVector3(visHeight*2,0,0)).ToScreen().SetColor(Color.white.A(.5f));
privatestaticvoidDebugJump(Vector3midPoint,Quaternionrotation,floatheight)
Sideside=jump.GetSide(GTime.Now);
boolhands=jump.nextStick.hands;
if(showJumpInfo)
stringtxt=
(GTime.Now-jump.startTime).ToString("F1")+"|"
+jump.duration.ToString("F1");
DRAW.Text(txt,midPoint,COLOR.green.spring,2f,offset:V2.up*6);
floatspin=GPhysics.Get_SpinSpeed_After(jump.startSpin,GTime.Now-jump.startTime);
intsign=(int)Mathf.Sign(spin);
stringrL=sign==0?"":(sign==1?"+":"-");
stringspinSpeed=rL+Mathf.Abs(spin).ToString("F1");
DRAW.Text(spinSpeed,midPoint,COLOR.green.spring,2.4f,offset:V2.up*6.5f);
Vector2mV=jump.GetMV(GTime.Now-jump.startTime);
Colorc=mV.magnitude>=FlyPath.CrashSpeed?COLOR.red.tomato:COLOR.grey.light;
DRAW.Text(mV.magnitude.ToString("F1"),midPoint,c,2.4f,offset:V2.up*8f);
if(predictionLines)
Colorcool=Color.red.ToHLS().ShiftHue(Time.realtimeSinceStartup);
jump.flyPath.Draw(0,jump.duration).SetColor(cool).SetDepth(Level.GetPlaneDist(jump.startSide));
if(anchorPath.Count>0)
DRAW.Line(anchorPath.ToArray()).SetColor(hands?COLOR.yellow.fresh:Color.Lerp(COLOR.red.tomato,COLOR.red.hot,.3f)).SetDepth(Z.P75);
if(midPath.Count>0)
DRAW.Line(midPath.ToArray()).SetColor(midPointColor).SetDepth(Z.P75);
Vector3pivot2D=jump.BasicPlacement(GTime.Now).pos;
Vector3pivot3D=clip.spinner.currentPlacement.pos;
DRAW.Circle(pivot2D,.15f).SetColor(COLOR.red.tomato).SetDepth(Z.P75).Fill(1);
DRAW.Circle(pivot3D,.15f).SetColor(COLOR.blue.cornflower).SetDepth(Z.P75+.01f*side.Sign).Fill(1);
DRAW.Vector(pivot2D,pivot3D-pivot2D).SetColor(COLOR.blue.cornflower).SetDepth(Z.P75+.05f*side.Sign);
Vector3stickPos=jump.stick.Item.GetPos(GTime.Now).V3(Level.WallDepth*side.Sign);
DRAW.GapVector(stickPos,V3.forward*6*side.Sign,16).SetColor(COLOR.red.tomato);
if(jump.WillConnect&&jump.nextStick.Item!=jump.stick.Item)
Vector3stickPosB=jump.nextStick.Item.GetPos(GTime.Now).V3(Level.WallDepth*side.Sign);
DRAW.GapVector(stickPosB,V3.forward*6*side.Sign,16).SetColor(COLOR.blue.cornflower);
if(predictionShapes&&jump.WillConnect)
DRAW.Rectangle(detectionPoint,Vector2.one*.3f).SetColor(COLOR.blue.cadet).SetDepth(Level.GetPlaneDist(side)).Fill();
DRAW.Rectangle(jump.nextStick.Item.GetLagPos(GTime.Now),Vector2.one*(.8f+(Mathf.Sin(Time.realtimeSinceStartup*16)+1)*.1f),45).
SetDepth(Level.GetPlaneDist(side,-2.25f));
Vector3pos=midPoint+rotation*V3.up*(hands?1:-1)*height*.5f;
DRAW.Rectangle(pos,Vector2.one*.3f).SetColor(hands?COLOR.yellow.fresh:COLOR.orange.sienna).SetDepth(Level.GetPlaneDist(side)).Fill();
if(stepInfo)
if(flyPath.apexTime>0&&(!jump.WillHit||flyPath.apexTime<jump.duration))
boolcloseToIt=Mathf.Abs(GTime.Now-(jump.startTime+flyPath.apexTime))<.05f;
DRAW.Circle(flyPath.GetPos(flyPath.apexTime),closeToIt?.3f:.1f,16).SetDepth(Z.P75).Fill(1);
if((!jump.WillConnect||flyPath.maxSpeedTime<jump.duration)&&GTime.Now>clip.startTime+flyPath.maxSpeedTime-.25f)
Vector3crashSpeedPos=flyPath.GetPos(flyPath.maxSpeedTime);
DRAW.ZappCircle(crashSpeedPos,.3f,.25f,10).SetColor(COLOR.orange.redish).SetDepth(Z.P75).Fill(.8f);
if((!jump.WillConnect||flyPath.linearStart<jump.duration)&&GTime.Now>clip.startTime+flyPath.linearStart-.25f)
Vector3expEndPos=flyPath.GetPos(flyPath.linearStart);
DRAW.ZappCircle(expEndPos,.3f,.25f,10).SetColor(COLOR.purple.orchid).SetDepth(Z.P75).Fill(.8f);
floatclosestStepPoint=Mathf.Floor(jump.duration*GPhysics.StepsPerSecond)*GPhysics.TimeStep;
for(inti=0;i<10;i++)
floattime=closestStepPoint-i*GPhysics.TimeStep;
floatalpha=(1f-i*.1f)*.25f;
floatradius=.1f-i*.006f;
if(time>flyPath.apexTime||flyPath.apexTime>=jump.duration)
Vector3stepPos=flyPath.GetPos(closestStepPoint-i*GPhysics.TimeStep);
DRAW.Circle(stepPos,radius).SetColor(newColor(1,1,1,alpha)).SetDepth(Z.P75).Fill(alpha);
Vector3itemPos=jump.nextStick.Item.GetLagPos(jump.startTime+time);
DRAW.Circle(itemPos,radius).SetColor(COLOR.yellow.fresh.A(alpha)).SetDepth(Z.P75).Fill(alpha);
if(nearGrabs)
floatdepth=Level.GetPlaneDist(side);
JumpInfoinfo=jump.info;
for(inte=0;e<info.proxCount;e++)
ProxItemproxItem=info.proxItems[e];
Itemitem=proxItem.item;
if(!Mask.CanBeGrabbed.Fits(item.elementType)||
!proxItem.DebugIsGoingOn(GTime.Now))
continue;
Colorusecolor;
switch(proxItem.Importance)
default:usecolor=Color.Lerp(Color.white,COLOR.grey.light,.5f);break;
case1:usecolor=COLOR.yellow.fresh;break;
case2:usecolor=COLOR.red.tomato;break;
case3:usecolor=COLOR.purple.maroon;break;
Vector2stickPos=item.GetLagPos(GTime.Now);
Vector2lineStart=stickPos+proxItem.closestDir.SetLength(item.radius);
Vector2anchor=lineStart+proxItem.closestDir*.5f;
DRAW.DotVector(lineStart,proxItem.closestDir,.1f,.1f).SetColor(usecolor).SetDepth(depth).Fill(1);
Vector2motion=proxItem.closestMotion.normalized;
DRAW.Arrow(anchor-motion,motion*2,.3f).SetColor(usecolor).SetDepth(depth).Fill(1);
if(nearGets)
floatdepth=Level.GetPlaneDist(side);
JumpInfoinfo=jump.info;
Vector2charPos=jump.BasicPlacement(GTime.Now).pos.V2();
floatcharRadius=jump.spinner.size.y*.5f;
boolgetNearBy=false;
for(inte=0;e<info.proxCount;e++)
ProxItemproxItem=info.proxItems[e];
Itemitem=proxItem.item;
if(!Mask.IsCollectable.Fits(item.elementType)||
Collector.IsCollected(item)||
!proxItem.DebugIsGoingOn(GTime.Now))
continue;
Vector2itemPos=item.GetPos(GTime.Now);
floatdist=(itemPos-charPos).sqrMagnitude;
floatcheckDist=Mathf.Pow(item.radius+charRadius,2);
if(dist>checkDist)
continue;
getNearBy=true;
Colorcolor=proxItem.upMotion?Color.white:Color.green;
DRAW.Circle(itemPos,item.radius,20).SetColor(color).SetDepth(depth);
Vector2closestPos=jump.BasicPlacement(proxItem.closestTime).pos.V2();
DRAW.DotVector(itemPos,closestPos-itemPos,.1f,.1f).SetColor(color).SetDepth(depth);
/*floatend=proxItem.closestTime+JumpInfo.StepLength;
floatcheckTime=proxItem.closestTime-JumpInfo.StepLength;
while(checkTime<end)
Vector2player=jump.BasicPlacement(checkTime).pos;
Vector2getPos=item.GetPos(checkTime);
floatsqrDist=(player-getPos).sqrMagnitude;
Colorc=sqrDist<=checkDist?Color.green:Color.red;
DRAW.Circle(player,.2f,10).SetColor(c).SetDepth(depth).Fill(1,true);
checkTime+=Collector.StepLength;
if(getNearBy)
DRAW.Circle(charPos,charRadius,20).SetColor(Color.magenta).SetDepth(depth);
if(showZappy&&GTime.Now-clip.startTime<1)
Vector2stickPos=jump.stick.Item.GetLagPos(GTime.Now);
constintnrOfLines=5;
constfloatlineSpacing=15;
constfloatspread=nrOfLines*lineSpacing;
for(inti=0;i<7;i++)
Vector2aimVector=jump.jumpV.normalized.Rot(spread*-.5f+i*lineSpacing,4);
Vector2pointA=Vector3.Lerp(stickPos,stickPos+aimVector,.2f);
Vector2pointB=Vector3.Lerp(stickPos,stickPos+aimVector,.45f);
DRAW.Zapp(pointA,pointB-pointA,8,.2f,.3f).SetColor(Color.white).SetDepth(Level.GetPlaneDist(side));
if(GTime.Paused&&closeEnough&&jump.WillConnect)
Vector2stickPos=jump.nextStick.Item.GetLagPos(GTime.Now).V3();
Vector2playerPos=jump.BasicPlacement(GTime.Now).pos;
floatradius=jump.spinner.ConnectRadius(jump.nextStick.Item);
if(Vector2.Distance(stickPos,playerPos)<radius)
DRAW.Circle(stickPos,radius).SetColor(Color.magenta).SetDepth(Z.P).Fill(1);
if(GTime.Paused&&searchBounds)
ShowSearchBounds();
privatestaticvoidShowSearchBounds()
Sideside=jump.startSide;
floatnow=Mathf.Floor((GTime.Now-jump.startTime)*GPhysics.StepsPerSecond)/GPhysics.StepsPerSecond;
floatbefore=Mathf.Clamp(now-GPhysics.TimeStep,0,float.MaxValue);
floatradius=clip.spinner.size.y*.5f;
Vector2posNow=jump.flyPath.GetPos(now);
Vector2posThen=jump.flyPath.GetPos(before);
Bounds2DstepSearch=newBounds2D(posNow).Add(posThen).Pad(radius);
DRAW.Rectangle(stepSearch.Center,stepSearch.Size).SetColor(COLOR.purple.maroon).SetDepth(Level.GetPlaneDist(side)).Fill(.1f);
DRAW.Vector(posNow,posThen-posNow).SetColor(COLOR.purple.maroon).SetDepth(Level.GetPlaneDist(side));
privatestaticvoidDebugSwing(Vector2midPoint)
Sideside=_swing.GetSide(GTime.Now);
floatlerp=1-Mth.IntPow(1-Mathf.Min(1,(GTime.Now-_swing.startTime)*3),3);
if(predictionLines)
DRAW.Arrow(midPoint,
_swing.GetForceV(GTime.Now).SetLength(2.05f*lerp),.4f*lerp).
SetColor(COLOR.grey.light).SetDepth(Level.GetPlaneDist(side,-.55f)).Fill(1);
Vector2swingForce=_swing.GetForceV(GTime.Now).normalized;
DRAW.Shape.Get(4).Set(0,midPoint).
Set(1,midPoint+swingForce.Rot(Prediction.CheckAngle*-.5f,1.5f*lerp)).
Set(2,midPoint+swingForce.Rot(Prediction.CheckAngle*.5f,1.5f*lerp)).
Set(4,midPoint).
SetColor(COLOR.green.lime.A(.5f)).SetDepth(Level.GetPlaneDist(side,-.55f)).Fill();
if(predictionShapes&&_swing.DebugCrash)
Vector3stickPos=_swing.GetStick(GTime.Now).Item.GetLagPos(GTime.Now);
Colorc=Random.Range(0,4)==0?COLOR.red.hot:COLOR.red.firebrick;
DRAW.ZappCircle(stickPos.V2()+V2.Random(.1f),.8f,.5f,11,Time.realtimeSinceStartup*-180).
SetColor(c).SetDepth(Level.GetPlaneDist(side,1)).Fill();
privatestaticintppDebug,arcDebug,circDebug;
publicpartialclassSpinner
publicstaticclassSquash
privateclassSpinnerSquash
privateconstintarrayLength=40;
privatereadonlySquashAnim[]squashes=newSquashAnim[arrayLength];
privateintmin,max;
privateintfirst{get{returnmin%arrayLength;}}
privateintlast{get{return(max-1)%arrayLength;}}
privateintlength{get{returnmax-min;}}
publicvoidAddSquash(floattime,floatamount,floatfrequency,floatduration)
if(length==arrayLength)
Debug.Log("Damnsquashestooshort");
return;
max++;
squashes[last]=SquashAnim.GetNew(time,amount,frequency,duration);
publicfloatGetSquash(floattime)
floatsquash=1;
for(inti=min;i<max;i++)
squash+=squashes[i%arrayLength].GetSquash(time);
returnsquash;
publicvoidResetAll()
while(length>0)
squashes[last].Reset();
max--;
publicvoidClearAfter(floattime)
while(length>0&&squashes[last].startTime>=time)
squashes[last].Reset();
max--;
publicvoidClearBefore(floattime)
while(length>0&&squashes[first].startTime+squashes[first].duration<time)
squashes[first].Reset();
min++;
staticSquash()
spinnerSquashes=newSpinnerSquash[Count];
for(inti=0;i<Count;i++)
spinnerSquashes[i]=newSpinnerSquash();
privatestaticreadonlySpinnerSquash[]spinnerSquashes;
publicstaticvoidAddNewSquash(Spinnerspinner,floattime,floatamount,floatfrequency,floatduration)
spinnerSquashes[spinner.ID].AddSquash(time,amount,frequency,duration);
publicstaticfloatGetSquash(Spinnerspinner,floattime)
returnspinnerSquashes[spinner.ID].GetSquash(time);
publicstaticvoidResetAllFor(Spinnerspinner)
spinnerSquashes[spinner.ID].ResetAll();
publicstaticvoidClearAfterFor(Spinnerspinner,floattime)
spinnerSquashes[spinner.ID].ClearAfter(time);
publicstaticvoidGameUpdate()
floatclearBefore=GTime.Now-GTime.RewindTime;
for(inti=0;i<Count;i++)
spinnerSquashes[i].ClearBefore(clearBefore);
publicstaticvoidReset()
for(inti=0;i<Count;i++)
spinnerSquashes[i].ResetAll();
publicclassSquashAnim:PoolObject
staticSquashAnim()
squashPool=newPool<SquashAnim>(()=>newSquashAnim(),500);
privatestaticreadonlyPool<SquashAnim>squashPool;
publicstaticSquashAnimGetNew(floatstartTime,floatamount,floatfrequency,floatduration)
returnsquashPool.GetFree().Setup(startTime,amount,frequency,duration);
publicfloatstartTime,duration;
privatefloatamount,frequency;
privateSquashAnimSetup(floatstartTime,floatamount,floatfrequency,floatduration)
this.startTime=startTime;
this.frequency=frequency;
this.duration=duration;
this.amount=amount;
returnthis;
publicvoidReset()
squashPool.Return(this);
publicfloatGetSquash(floattime)
if(time<startTime||time-startTime>duration)
return0;
returnGPhysics.NewOscillate(time-startTime,frequency,duration)*amount;
publicstaticclassThreadClub
[Switch("Tape/ActiveClub")]privatestaticboolActiveClub=false;
[Switch("Tape/SpawnRadius")]privatestaticboolDebugSpawn=false;
privateconstintmemberCount=5;
privateconstfloatSpawnRadius=60;
privateconstfloatSpawnRadiusSqrt=SpawnRadius*SpawnRadius;
privatestaticreadonlyThreadMember[]clubMembers=newThreadMember[memberCount];
privatestaticThreadthread;
publicstaticvoidGameLoad()
for(inti=0;i<clubMembers.Length;i++)
clubMembers[i]=newThreadMember();
thread=newThread(ThreadUpdate);
thread.Start();
publicstaticvoidGameStart()
return;
if(!ActiveClub)
return;
publicstaticvoidGameOver()
return;
privatestaticvoidClubUpdate()
if(!ActiveClub||!GameManager.Running)
return;
if(DebugSpawn)
DRAW.Circle(GameCam.frustum.focusPoint,SpawnRadius).SetColor(COLOR.orange.coral).SetDepth(Z.P);
privatestaticvoidThreadUpdate()
while(true)
ClubUpdate();
Thread.Sleep(100);
publicclassThreadMember
namespaceClips
publicclassAirLaunch:Jump
publicAirLaunch():base(ClipType.AirLaunch){}
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
base.Setup(spinner,startTime,startSide);
next=Prep.nextClip;
startAngle=Prep.startAngle;
jumpV=Prep.jumpV;
startSpin=Prep.startSpin;
duration=Prep.duration;
startPos=Prep.startPos;
if(WillConnect)
FindNextStick();
returnthis;
publicabstractpartialclassClip
publicstaticClipGet_AirLaunch(Spinnerspinner,floatstartTime,floatstartAngle,Vector2jumpV,floatstartSpin,floatduration,Vector2startPos,ClipTypenextClip,Sideside)
Prep.startAngle=startAngle;
Prep.jumpV=jumpV;
Prep.startSpin=startSpin;
Prep.duration=duration;
Prep.startPos=startPos;
Prep.nextClip=nextClip;
returnPoolClip(ClipType.AirLaunch,spinner,startTime,side);
namespaceAnim
publicabstractclassSpinnerAnim:PoolObject
publicstaticreadonlySpinnerAnimNone=newAnim_Default();
privatereadonlyAnimLerp[][]lerps;
privatereadonlyint[]lerpCount;
protectedreadonlyPosestartPose=newPose();
staticSpinnerAnim()
Anim_Jump.pool=newPool<Anim_Jump>(()=>newAnim_Jump(),700);
Anim_Swing.pool=newPool<Anim_Swing>(()=>newAnim_Swing(),700);
protectedSpinnerAnim()
lerpCount=newint[Pose.Length];
lerps=newAnimLerp[Pose.Length][];
for(inti=0;i<Pose.Length;i++)
lerps[i]=newAnimLerp[10];
publicSpinnerAnimReset()
for(inti=0;i<Pose.Length;i++)
intcount=lerpCount[i];
for(inte=0;e<count;e++)
lerps[i][e].Reset();
lerpCount[i]=0;
PoolReturn();
returnnull;
protectedabstractvoidPoolReturn();
protectedvoidAdd(intpart,AnimLerpanimLerp)
lerps[part][lerpCount[part]++]=animLerp;
protectedvoidAdd(intpart,AnimLerp.Bundlebundle)
lerps[part][lerpCount[part]++]=bundle.a;
lerps[part][lerpCount[part]++]=bundle.b;
publicabstractPoseSampleAnimation(floattime,floatlocalTime);
protectedfloatGetLerp(intpart,floattime)
intcount=lerpCount[part];
intvalid=0;
floatvalue=0;
AnimLerplastLerp=null;
for(inti=0;i<count;i++)
AnimLerplerp=lerps[part][i];
if(lerp.startTime<=time)
if(lerp.endTime>=time)
value+=lerp.GetValue(time);
valid++;
lastLerp=lerp;
returnvalid>0?value:lastLerp!=null?lastLerp.GetValue(time):startPose[part];
[Switch("Anim/WiggleTest")]privatestaticboolwiggleIt=false;
protectedvoidSetTurns(Posepose,floattime)
pose.Set(Pose.TurnB,GetLerp(Pose.TurnT,time)).
Set(Pose.TurnT,GetLerp(Pose.TurnB,time));
protectedvoidSetWiggle(Posepose,floattime,floatlocalTime)
floatbendT=GetLerp(Pose.BendT,time);
floatbendB=GetLerp(Pose.BendB,time);
if(wiggleIt)
pose.Set(Pose.BendT,bendT+Mth.SmoothPP(localTime*3.5f)*-.25f).
Set(Pose.BendB,bendB+Mth.SmoothPP(localTime*4)*.25f);
pose.Set(Pose.BendT,bendT).
Set(Pose.BendB,bendB);
publicabstractclassAnimLerp:PoolObject
publicfloatstartTime,endTime;
protectedfloatstartValue,endValue;
privateAnimLerpSetup(floatstartTime,floatendTime,floatstartValue,floatendValue)
this.startTime=startTime;
this.endTime=endTime;
this.startValue=startValue;
this.endValue=endValue;
returnthis;
publicabstractvoidReset();
publicabstractfloatGetValue(floattime);
staticAnimLerp()
poolFL=newPool<AnimLerp>(()=>newAnimLerpFL(),7000);
poolLF=newPool<AnimLerp>(()=>newAnimLerpLF(),7000);
poolFF=newPool<AnimLerp>(()=>newAnimLerpFF(),7000);
protectedstaticreadonlyPool<AnimLerp>poolFL,poolLF,poolFF;
publicstaticAnimLerpLF(floatstartTime,floatendTime,floatstartValue,floatendValue)
returnpoolLF.GetFree().Setup(startTime,endTime,startValue,endValue);
publicstaticAnimLerpFL(floatstartTime,floatendTime,floatstartValue,floatendValue)
returnpoolFL.GetFree().Setup(startTime,endTime,startValue,endValue);
publicstaticAnimLerpFF(floatstartTime,floatendTime,floatstartValue,floatendValue)
returnpoolFF.GetFree().Setup(startTime,endTime,startValue,endValue);
privatestaticreadonlyBundlebundle=newBundle();
publicstaticBundleLFL(floatstartTime,floatmidTime,floatendTime,floatstartValue,floatendValue)
returnbundle.Set(LF(startTime,midTime,startValue,endValue),
FL(midTime,endTime,endValue,startValue));
publicstaticBundleLFF(floatstartTime,floatmidTime,floatendTime,floatstartValue,floatendValue)
returnbundle.Set(LF(startTime,midTime,startValue,endValue),
FF(midTime,endTime,endValue,startValue));
publicstaticBundleFFL(floatstartTime,floatmidTime,floatendTime,floatstartValue,floatendValue)
returnbundle.Set(FF(startTime,midTime,startValue,endValue),
FL(midTime,endTime,endValue,startValue));
publicstaticBundleFFF(floatstartTime,floatmidTime,floatendTime,floatstartValue,floatendValue)
returnbundle.Set(FF(startTime,midTime,startValue,endValue),
FF(midTime,endTime,endValue,startValue));
publicclassBundle
publicAnimLerpa,b;
publicBundleSet(AnimLerpa,AnimLerpb)
this.a=a;
this.b=b;
returnthis;
publicclassAnimLerpFL:AnimLerp
publicoverridevoidReset(){poolFL.Return(this);}
publicoverridefloatGetValue(floattime)
returnMathf.Lerp(startValue,endValue,Ease.FL((time-startTime)/(endTime-startTime)));
publicclassAnimLerpLF:AnimLerp
publicoverridevoidReset(){poolLF.Return(this);}
publicoverridefloatGetValue(floattime)
returnMathf.Lerp(startValue,endValue,Ease.LF((time-startTime)/(endTime-startTime)));
publicclassAnimLerpFF:AnimLerp
publicoverridevoidReset(){poolFF.Return(this);}
publicoverridefloatGetValue(floattime)
returnMathf.Lerp(startValue,endValue,Ease.FF((time-startTime)/(endTime-startTime)));
namespaceAnim
publicclassAnim_Jump:SpinnerAnim
[Switch("Anim/FailedGrabs")]privatestaticboolfailedGrabs=true;
publicstaticPool<Anim_Jump>pool;
privateJumpjump;
publicstaticAnim_JumpGet(Clipclip,PosestartPose)
returnpool.GetFree().Setup(clip,startPose);
privateAnim_JumpSetup(Clipclip,PosestartPose)
jump=(Jump)clip;
this.startPose.Copy(startPose);
floatjumpStart=jump.startTime;
floatjumpDuration=jump.WillHit?jump.duration:5;
floatjumpEnd=jumpStart+jumpDuration;
if(startPose[Pose.TumbleT]>0)
Add(Pose.TumbleT,AnimLerp.FF(jumpStart,jumpStart+Mathf.Min(jumpDuration,.3f),startPose[Pose.TumbleT],0));
if(startPose[Pose.TumbleB]>0)
Add(Pose.TumbleB,AnimLerp.FF(jumpStart,jumpStart+Mathf.Min(jumpDuration,.3f),startPose[Pose.TumbleB],0));
floatinTime=1.25f,outTime=.75f;
if(inTime+outTime>jumpDuration)
floatmulti=jumpDuration/(inTime+outTime);
inTime*=multi;
outTime*=multi;
floatstartLean=startPose[Pose.Lean];
floatmaxLean=-Mathf.Sign(jump.startSpin)*
Mathf.Lerp(1,0,Mathf.Abs(jump.startSpin)/11)*
Mathf.Lerp(0,1,jumpDuration*.7f);
floatendLean=jump.next==ClipType.Bump?0:maxLean*.1f;
Add(Pose.Lean,AnimLerp.FF(jumpStart,jumpStart+inTime,startLean,maxLean));
Add(Pose.Lean,AnimLerp.FF(jumpStart+jumpDuration-outTime,jumpStart+jumpDuration,maxLean,endLean));
constfloatpushA=.31f,
pushB=pushA*1.25f,
howMuch=.45f,
fractA=.355f,
fractB=.645f;
boolhands=jump.stick.hands;
floatsign=hands?Mathf.Sign(jump.startSpin):-Mathf.Sign(jump.startSpin);
floatpushMulti=Mathf.Clamp01(Mathf.Abs(jump.startSpin)/25f);
floatamount=howMuch*sign*pushMulti;
intlimb=hands?Pose.BendT:Pose.BendB;
floatduration=Mathf.Min(jumpDuration,pushA*(1+pushMulti*.4f));
floatpushAmount=amount*(duration/pushA);
floatinEnd=jumpStart+duration*fractA,
outEnd=inEnd+duration*fractB;
Add(limb,AnimLerp.LFF(jumpStart,inEnd,outEnd,0,pushAmount));
intlimb=hands?Pose.BendB:Pose.BendT;
floatduration=Mathf.Min(jumpDuration,pushB*(1+pushMulti*.4f));
floatswingAmount=amount*(duration/pushB)*-.8f;
floatinEnd=jumpStart+duration*fractA,
outEnd=inEnd+duration*fractB;
Add(limb,AnimLerp.LFF(jumpStart,inEnd,outEnd,0,swingAmount));
if(failedGrabs)
constfloatflip=.45f,grab=flip*1.65f,delay=.05f;
JumpInfoinfo=jump.info;
floatminTime=jumpStart+delay;
floatmaxTime=jumpEnd-flip-delay;
intproxyCount=info.proxCount;
Spinnerspinner=jump.spinner;
floatspinnerRadius=spinner.size.y*.5f;
constfloatreachDist=2f;
floatcheckDist=Mathf.Pow(spinnerRadius+reachDist,2);
floatturn=startPose[Pose.TurnB];
for(inti=0;i<proxyCount;i++)
ProxItemproxItem=info.proxItems[i];
Itemitem=proxItem.item;
if(!Mask.CanBeGrabbed.Fits(item.elementType)||
item==jump.stick.Item||
item==jump.nextStick.Item||
proxItem.closestDist>checkDist)
continue;
floatend=proxItem.closestTime+JumpInfo.StepLength;
floatcheckTime=Mathf.Max(jumpStart,proxItem.closestTime-JumpInfo.StepLength*2);
if(ItemCheck.FirstHit(checkTime,end,JumpInfo.StepLength,jump,item,checkDist,outcheckTime)&&
checkTime>minTime&&checkTime+grab<maxTime)
floatnewTurn=turn+.5f;
Add(Pose.TurnT,AnimLerp.FF(checkTime-delay,checkTime+flip-delay,turn,newTurn));
Add(Pose.TurnB,AnimLerp.FF(checkTime,checkTime+flip,turn,newTurn));
Vector2charPos=jump.BasicPlacement(checkTime).pos;
Vector2itemPos=item.GetPos(checkTime);
floatangle=jump.startAngle+GPhysics.Get_SpinAngle_Deg(jump.startSpin,checkTime-jumpStart);
Vector2handDir=Vector2.up.Rot(angle);
boolhandsAreClosest=Vector2.Dot(handDir,(itemPos-charPos).normalized)>0;
intlimb=handsAreClosest?Pose.TumbleT:Pose.TumbleB;
Add(limb,AnimLerp.FFF(checkTime-delay,checkTime+grab*.5f,checkTime+grab,0,1f));
turn=newTurn;
minTime=checkTime+grab+delay;
if(jump.WillConnect)
constfloatgrab=.35f,
howMuch=.55f,
fractB=.455f,
fractA=.545f;
boolhands=jump.nextStick.hands;
floatendSpin=GPhysics.Get_SpinSpeed_After(jump.startSpin,jumpDuration);
floatsign=hands?-Mathf.Sign(endSpin):Mathf.Sign(endSpin);
floatpushMulti=Mathf.Clamp01(Mathf.Abs(endSpin)/25f);
floatamount=howMuch*sign*pushMulti;
intlimb=hands?Pose.BendT:Pose.BendB;
floatduration=Mathf.Min(jumpDuration,grab*(1+pushMulti*.4f));
floatgrabAmount=amount*(duration/grab);
floatinEnd=jumpEnd-duration+duration*fractA,
outEnd=inEnd+duration*fractB;
Add(limb,AnimLerp.FFL(jumpEnd-duration,inEnd,outEnd,0,grabAmount));
returnthis;
protectedoverridevoidPoolReturn()
pool.Return(this);
publicoverridePoseSampleAnimation(floattime,floatlocalTime)
Pose.Reader.Zero().Set(Pose.Lean,GetLerp(Pose.Lean,time));
floattumble=GetTumble(time);
Pose.Reader.Set(Pose.TumbleT,Mathf.Max(GetLerp(Pose.TumbleT,time),tumble*1.5f));
Pose.Reader.Set(Pose.TumbleB,Mathf.Max(GetLerp(Pose.TumbleB,time),tumble*1.5f));
SetWiggle(Pose.Reader,time,localTime);
SetTurns(Pose.Reader,time);
returnPose.Reader;
privatefloatGetTumble(floattime)
floatflightTime=time-jump.startTime;
floatspinSpeed=GPhysics.Get_SpinSpeed_After(jump.startSpin,flightTime);
floatspeed=Mathf.Clamp01(jump.GetMV(time).magnitude*.0135f);
constfloatlerpDuration=.15f;
if(jump.WillHit)
floatactualLerpDuration=lerpDuration*2>jump.duration?jump.duration*.5f:lerpDuration;
floatinLerp=Mathf.SmoothStep(0,1,Mathf.InverseLerp(0,actualLerpDuration,flightTime));
floatoutLerp=Mathf.SmoothStep(0,1,Mathf.InverseLerp(jump.duration,jump.duration-actualLerpDuration,flightTime));
floattumble=Mathf.Max(speed,Mathf.InverseLerp(7.4f,3.5f,Mathf.Abs(spinSpeed)));
returninLerp*outLerp*tumble;
floatinLerp=Mathf.SmoothStep(0,1,Mathf.InverseLerp(0,lerpDuration,flightTime));
floattumble=Mathf.Max(speed,Mathf.InverseLerp(9.8f,3.2f,Mathf.Abs(spinSpeed)));
returninLerp*tumble;
namespaceAnim
publicclassAnim_Default:SpinnerAnim
protectedoverridevoidPoolReturn(){}
publicoverridePoseSampleAnimation(floattime,floatlocalTime)
Pose.Reader.Zero();
SetTurns(Pose.Reader,time);
SetWiggle(Pose.Reader,time,localTime);
returnPose.Reader;
publicclassAnim_Swing:SpinnerAnim
publicstaticPool<Anim_Swing>pool;
privateSwingswing;
publicstaticAnim_SwingGet(Clipclip,PosestartPose)
returnpool.GetFree().Setup(clip,startPose);
privateAnim_SwingSetup(Clipclip,PosestartPose)
this.startPose.Copy(startPose);
swing=(Swing)clip;
Vector2impactV=newVector2(swing.startMotion.x,swing.startMotion.y+GPhysics.Gravity*-.75f);
floatimpactV_M=impactV.magnitude;
Vector2pivotUp=V2.up.Rot(swing.startAngle,swing.startStick.Sign);
floatimpact=impactV_M>0?Vector3.Dot(impactV*(1f/impactV_M),pivotUp)*impactV_M:0;
floatabsImpact=Mathf.Abs(impact);
floatamount=Mathf.Clamp01(absImpact*.015f)*-Mathf.Sign(impact);
floatfrequency=absImpact/clip.spinner.size.y/5.5f;
floatduration=absImpact/60f*2.5f;
Spinner.Squash.AddNewSquash(swing.spinner,swing.startTime,amount,frequency,duration);
CalculateConnectionSwing();
intlimb=swing.startStick.hands?Pose.TumbleB:Pose.TumbleT;
floattumbleAmount=Mathf.Clamp(impactV_M*.035f,0,2);
Add(limb,AnimLerp.LFF(swing.startTime,swing.startTime+.2f,swing.startTime+1.3f,0,tumbleAmount));
returnthis;
protectedoverridevoidPoolReturn()
pool.Return(this);
publicoverridePoseSampleAnimation(floattime,floatlocalTime)
Pose.Reader.Zero().Set(Pose.Lean,GetLean(time));
SetTurns(Pose.Reader,time);
SetWiggle(Pose.Reader,time,localTime);
Pose.Reader.Set(Pose.TumbleT,GetLerp(Pose.TumbleT,time));
Pose.Reader.Set(Pose.TumbleB,GetLerp(Pose.TumbleB,time));
returnPose.Reader;
privatevoidCalculateConnectionSwing()
floatspeedChange;
if(f.Same(Mathf.Sign(swing.startSpinSpeed),Mathf.Sign(swing.spinSpeed)))
if(Mathf.Sign(swing.startSpinSpeed)>Mathf.Sign(swing.spinSpeed))
speedChange=Mathf.Abs(swing.startSpinSpeed)-Mathf.Abs(swing.spinSpeed);
else
speedChange=-(Mathf.Abs(swing.spinSpeed)-Mathf.Abs(swing.startSpinSpeed));
else
speedChange=-(Mathf.Abs(swing.spinSpeed)+Mathf.Abs(swing.startSpinSpeed));
floatoverlap=speedChange*swing.spinSpeed*.0025f*swing.startStick.Sign;
Vector2up=V2.up.Rot(swing.startAngle);
Vector2impactVector=(swing.startMotion!=V2.zero)?swing.startMotion+newVector2(0,GPhysics.Gravity*-0.45f):V2.zero;
floatimpactAngle=Vector3.Angle(impactVector,up);
if(impactAngle>90)
impactAngle=180-impactAngle;
floatimpactAngleFactor=impactAngle/90;
floatmagnitude=1+swing.startMotion.magnitude;
floatimpactAngleLean=magnitude*impactAngleFactor*.1f;//0.05f
if(f.Same(Mathf.Sign(swing.spinSpeed),1)&&swing.startStick.hands
||f.Same(Mathf.Sign(swing.spinSpeed),-1)&&!swing.startStick.hands)
impactAngleLean*=-1;
overlap+=impactAngleLean;
floatlerpFactor=Mathf.Abs(swing.spinSpeed)*.0185f;
overlap=Mathf.Lerp(overlap,0,lerpFactor);
floatlerpInLength=2.6f/(magnitude*1.2f);
floatlerpOutLength=lerpInLength*.25f+.025f*magnitude;
Add(Pose.Lean,AnimLerp.LFF(swing.startTime,swing.startTime+lerpInLength,swing.startTime+lerpInLength+lerpOutLength,0,overlap));
privatefloatGetLean(floattime)
if(swing==null)
return0;
floatlerp=swing.BasicRot(time).eulerAngles.z/360;
floatleandir=1;
switch((int)Mathf.Sign(swing.spinSpeed))
case1:
if(!swing.startStick.hands)
lerp=Mathf.Repeat(lerp-.5f,1);
leandir=-1;
break;
case-1:
if(swing.startStick.hands)
lerp=1-lerp;
leandir=-1;
else
lerp=1-Mathf.Repeat(lerp-.5f,1);
break;
floatcurveLean=Curves.SwingLeanAnim.Evaluate(lerp);
floatspinLean=curveLean*2f*leandir;
floatleanLerp=Mathf.Clamp((time-swing.startTime)*.25f,0,.25f)*4;
floatstickLean=Mathf.Lerp(Mathf.Lerp(spinLean,0,Mathf.Abs(swing.GetActualSpeed(time))*.0255f),startPose[Pose.Lean],1-leanLerp);
returnstickLean+GetLerp(Pose.Lean,time);
namespaceClips
publicclassBump:Clip
publicBump():base(ClipType.Bump){}
privateVector2startPos;
publicVector2mV;
privatefloatstartAngle,startSpin;
publicItembumpItem;
privateFlyPathflyPath;
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
base.Setup(spinner,startTime,startSide);
flyPath=newFlyPath(Prep.Jump.startPos,Prep.Jump.jumpV);
startPos=flyPath.GetPos(Prep.Jump.duration);
startAngle=Prep.Jump.startAngle+GPhysics.Get_SpinAngle_Deg(Prep.Jump.startSpin,Prep.Jump.duration);
bumpItem=Search.ClosestItem(startPos,startTime,startSide,Mask.IsItem);
if(bumpItem==null)
returnthis;
Vector2charMV=flyPath.GetMV(Prep.Jump.duration);
Vector2itemPos=bumpItem.GetLagPos(startTime);
Vector2bodyDir=V2.up.Rot(startAngle,spinner.size.y-spinner.size.x);
Vector2pointOnLine=Line.NewMidDirLine(startPos,bodyDir).ClosestPoint(itemPos);
Vector2hitNormal=(itemPos-pointOnLine).normalized;
Vector2hitPoint=itemPos-hitNormal*bumpItem.radius;
floatcharRadSpin=GPhysics.Get_SpinSpeed_After(Prep.Jump.startSpin,Prep.Jump.duration)*GPhysics.SpinMulti*Mathf.Deg2Rad;
Vector2charToHitpoint=hitPoint-startPos;
Vector2charAngularVel=charRadSpin.Cross(charToHitpoint);
Vector2charHitpointVel=charMV+charAngularVel;
Vector2itemHitpointVel=bumpItem.GetMV(startTime);//+0f.Cross(hitPoint-itemPos);stickAngularVel;
Vector2relativeVelocity=charHitpointVel-itemHitpointVel;
floatvelAlongNormal=Vector2.Dot(relativeVelocity,hitNormal);
floathitDirCross=charToHitpoint.Cross(hitNormal);
constfloate=.55f;
constfloatmass=10;
constfloatcolliderMass=100000;
constfloatinertia=8;
floatimpulse=-(1+e)*velAlongNormal/
(
1/mass+1/colliderMass
+Mth.IntPow(hitDirCross,2)/inertia
/*+Mathf.Pow(Extensions.CrossProduct(stickRadiusVector,Tri.HitNormalInverse),2)/inertia*///Stickinertiaisinfinite
);
Vector2impulseV=hitNormal*impulse;
mV=charMV+impulseV/mass;
startSpin=(charRadSpin+hitDirCross/inertia*impulse)*Mathf.Rad2Deg/GPhysics.SpinMulti;
flyPath=newFlyPath(startPos,mV);
returnthis;
publicoverridePlacementBasicPlacement(floattime,boolshadow=false)
Vector3pos=flyPath.GetPos(time-startTime);
floatangle=startAngle+GPhysics.Get_SpinAngle_Deg(startSpin,time-startTime);
returnnewPlacement(pos,angle);
publicoverridePlacementFinalPlacement(floattime)
floatzShift=spinner.GetZShift(time);
floatdist=(Level.WallDepth+Level.PlaneOffset+zShift)*startSide.Sign;
PlacementbasePlacement=BasicPlacement(time);
returnnewPlacement(basePlacement.pos.SetZ(dist),basePlacement.rot);
publicoverrideVector2GetMV(floattime)
returnflyPath.GetMV(time-startTime);
/*publicoverrideboolGetClipBounds(ClipBoundPoolpool)
flyPath=newFlyPath(startPos,mV);
floatstart=Mathf.Max(startTime,pool.min);
floatend=Mathf.Min(startTime+6,pool.max);
for(floattimeA=start;timeA<end;timeA+=ClipBounds.SearchStep)
floattimeB=Mathf.Min(timeA+ClipBounds.SearchStep,end);
ClipBoundscBounds=pool.Get.Set(timeA,timeB,Type,startSide);
floatflightA=timeA-startTime,flightB=timeB-startTime;
cBounds.bounds.Set(flyPath.GetPos(flightA)).Add(flyPath.GetPos(flightB));
if(flyPath.apexTime>flightA&&flyPath.apexTime<=flightB)
cBounds.bounds.Add(flyPath.GetPos(flyPath.apexTime));
cBounds.bounds.Pad(spinner.size.y*.5f);
returntrue;
publicabstractpartialclassClip
publicstaticClipGet_Bump(Jumpjump)
Prep.Jump=jump;
returnPoolClip(ClipType.Bump,jump.spinner,jump.HitTime,jump.startSide);
namespaceClips
publicabstractpartialclassClip:PoolObject
protectedClip(ClipTypeType){this.Type=Type;}
publicreadonlyClipTypeType;
publicSpinnerspinner;
publicClipbefore,after;
publicfloatstartTime,duration;
publicSidestartSide;
privateSpinnerAnimanim;
publicboolhasBeenSet;
publicabstractPlacementBasicPlacement(floattime,boolshadow=false);
publicabstractPlacementFinalPlacement(floattime);
/*publicvirtualboolGetClipBounds(ClipBoundPoolpool)
returntrue;
protectedvirtualClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
this.spinner=spinner;
this.startTime=startTime;
this.startSide=startSide;
returnthis;
publicabstractVector2GetMV(floattime);
publicvirtualvoidEnable()
Interaction.SetClip(this);
publicvoidSetClipBefore(Clipbefore)
this.before=before;
SetAnim();
privatevoidSetAnim()
if(before!=null)
before.ReadPose(startTime);
else
Pose.Reader.Zero();
if(Type.IsAnyJump())
anim=Anim_Jump.Get(this,Pose.Reader);
if(Type.IsAnySwing())
anim=Anim_Swing.Get(this,Pose.Reader);
if(anim==null)
anim=SpinnerAnim.None;
publicvoidSetClipAfter(Clipafter)
this.after=after;
if(Type.IsAnySwing())
duration=after!=null?after.startTime-startTime:0;
publicPoseReadPose(floattime)
returnanim.SampleAnimation(time,time-spinner.startTime);
publicvirtualSideGetSide(floattime){returnstartSide;}
publicabstractpartialclassClip
staticClip()
pools=new[]
null,
newPool<Clip>(()=>newJump(),700),
newPool<Clip>(()=>newSwing(),700),
newPool<Clip>(()=>newBump(),100),
newPool<Clip>(()=>newAirLaunch(),100),
newPool<Clip>(()=>newDead(),100),
newPool<Clip>(()=>newSpawn(),100),
null
dummys=newClip[]
null,
newJump(),
newSwing(),
newBump(),
newAirLaunch(),
newDead(),
newSpawn(),
null
publicvoidReset()
anim=anim!=null?anim.Reset():null;
pools[(int)Type].Return(this);
duration=0;
before=null;
after=null;
spinner=null;
hasBeenSet=false;
privatestaticreadonlyPool<Clip>[]pools;
privatestaticreadonlyClip[]dummys;
publicvirtualboolSerialize(BinaryWriterwriter)
Debug.Log(Type+"hasnoserializer");
returntrue;
publicstaticClipDeserialize(BinaryReaderreader,Spinnerspinner,ClipTypeclipType,Sideside,floattimeShift=0)
switch(clipType)
default:returnnull;
caseClipType.Jump:returnJump.DeserializeClip(reader,spinner,side,timeShift);
caseClipType.Dead:returnDead.DeserializeClip(reader,spinner,side,timeShift);
caseClipType.Spawn:returnSpawn.DeserializeClip(reader,spinner,side,timeShift);
publicstaticvoidSkipClip(BinaryReaderreader,ClipTypeclipType)
intbyteCount;
switch(clipType)
default:byteCount=0;break;
caseClipType.Jump:byteCount=15;break;
caseClipType.Dead:byteCount=2;break;
caseClipType.Spawn:byteCount=4;break;
reader.BaseStream.Seek(byteCount,SeekOrigin.Current);
/*publicstaticClipDeserializeBounds(ReplayGettergetter,ClipTypeclipType,Sideside)
Spinner.Dummy.size=getter.replay.charSize;
Clipclip=Deserialize(getter.reader,Spinner.Dummy,clipType,side);
if(clip!=null)
clip.GetClipBounds(getter.pool);
getter.pool.AddToList(getter.clipBounds);
returnclip;
publicstaticClipPoolClip(ClipTypeclipType,Spinnerspinner,floatstartTime,Sideside)
returnspinner==Spinner.Dummy?dummys[(int)clipType].Setup(spinner,startTime,side):
pools[(int)clipType].GetFree().Setup(spinner,startTime,side);
protectedstaticclassPrep
publicstaticfloatstartAngle,startSpin;
publicstaticfloatstartTime,duration;
publicstaticVector2jumpV,startPos;
publicstaticStickIDstickID;
publicstaticClipTypenextClip;
publicstaticfloatweightLerp;
publicstaticJumpJump;
namespaceClips
publicclassDead:None
publicDead():base(ClipType.Dead){}
publicoverrideboolSerialize(BinaryWriterwriter)
boolserializingWorked=true;
writer.Write(Crunch.FloatToShort(startTime,2,refserializingWorked));
returnserializingWorked;
publicstaticClipDeserializeClip(BinaryReaderreader,Spinnerspinner,Sideside,floattimeShift)
returnPoolClip(ClipType.Dead,spinner,Crunch.ShortToFloat(reader.ReadInt16(),2)+timeShift,side);
/*publicoverrideboolGetClipBounds(ClipBoundPoolpool)
pool.Get.Set(startTime,pool.max,Type,startSide);
returntrue;
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
duration=GTime.RewindTime;
returnbase.Setup(spinner,startTime,startSide);
namespaceClips
publicpartialclassJump:Clip
publicJump(ClipTypetype=ClipType.Jump):base(type){}
publicClipTypenext;
publicStickIDstick,nextStick;
publicfloatstartAngle,startSpin;
privatefloatweightLerp;
publicVector2jumpV,startPos;
publicFlyPathflyPath;
publicreadonlyJumpInfoinfo=newJumpInfo();
publicboolWillHit,WillConnect;
publicfloatHitTime;
privatereadonlyOffsetteroffsetter=newOffsetter();
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
base.Setup(spinner,startTime,startSide);
next=Prep.nextClip;
startAngle=Prep.startAngle;
jumpV=Prep.jumpV;
startSpin=Prep.startSpin;
stick=Prep.stickID;
weightLerp=Prep.weightLerp;
duration=Prep.duration;
WillHit=next!=0;
WillConnect=next.IsAnySwing();
HitTime=startTime+duration;
startPos=CalculateStartPos(stick,spinner.ConnectRadius(stick.Item),startAngle,startTime);
flyPath=newFlyPath(startPos,jumpV);
if(WillConnect)
FindNextStick();
info.Analyze(this);
returnthis;
privatestaticVector2CalculateStartPos(StickIDstickID,floatradius,floatangle,floatstartTime)
Vector2bodyVector=V2.up.Rot(angle,-stickID.Sign*radius);
Vector2stickPos=stickID.Item.GetLagPos(startTime);
returnnewVector2(bodyVector.x+stickPos.x,bodyVector.y+stickPos.y);
protectedvoidFindNextStick()
floatconnectTime=startTime+duration;
Vector2charPosition=BasicPos(connectTime);
ItemclosestStick=Search.ClosestItem(charPosition,connectTime,startSide,Mask.CanBeGrabbed);
if(closestStick!=null)
floatangleNow=GPhysics.Get_SpinAngle_Deg(startSpin,duration);
Vector2stickPos=closestStick.GetLagPos(connectTime);
Vector2bodyVector=V2.up.Rot(startAngle+angleNow);
Vector2toStick=(stickPos-charPosition).normalized;
boolusingHands=Vector2.Dot(toStick,bodyVector)>=0;
floatnewAngle=angleNow-(usingHands?bodyVector:-bodyVector).Angle_Sign(toStick);
startSpin=GPhysics.GetStartSpin(newAngle,duration);
angleNow=newAngle;
inttrimmSteps=0;
while(startSpin.HasToBeTrimmed(3))
newAngle=angleNow-180*Mathf.Sign(angleNow);
startSpin=GPhysics.GetStartSpin(newAngle,duration);
angleNow=newAngle;
trimmSteps++;
if(trimmSteps>0&&Application.isEditor)
Debug.LogFormat("TrimmedSpin{0}times.Spinnerturns{1}less".B_Salmon(),trimmSteps,trimmSteps*180);
nextStick=newStickID(closestStick,usingHands);
else
Debug.LogFormat("Spinner(Height{0})failedtograbaStick!".B_Lime(),spinner.size.y);
Debug.Log(stick.Item.ID.ToString().B_Red());
DRAW.Circle(charPosition,spinner.ConnectRadius()).SetColor(COLOR.orange.coral).SetDepth(Level.GetPlaneDist(startSide)).HoldFor(5);
DRAW.Circle(startPos,spinner.ConnectRadius()).SetColor(COLOR.yellow.fresh).SetDepth(Level.GetPlaneDist(startSide)).HoldFor(5);
privateVector3BasicPos(floattime)
returnflyPath.GetPos(time-startTime);
privateQuaternionBasicRot(floattime)
floatangle=startAngle+GPhysics.Get_SpinAngle_Deg(startSpin,time-startTime);
returnRot.Z(angle);
publicoverridePlacementBasicPlacement(floattime,boolshadow=false)
Vector3pos=BasicPos(time);
Quaternionrot=BasicRot(time);
if(shadow)
pos+=offsetter.LerpOffset(time,false).pos;
returnnewPlacement(pos,rot);
publicoverridePlacementFinalPlacement(floattime)
Placementoffset=offsetter.LerpOffset(time,true);
PlacementbasePlacement=BasicPlacement(time);
returnnewPlacement(offset.pos+basePlacement.pos,offset.rot*basePlacement.rot);
publicoverrideVector2GetMV(floattime)
/*Vector2pos=flyPath.GetPos(time-startTime);
Vector2pos2=flyPath.GetPos(time-startTime+GPhysics.TimeStep);
return(pos2-pos)/GPhysics.TimeStep;*/
/*Vector2mV=flyPath.GetMV(time-startTime).normalized;
Vector2mV2=flyPath.GetPos(time-startTime+.1f)-flyPath.GetPos(time-startTime).normalized;
floatdot=Vector2.Dot(mV,mV2);
if(dot<0)
Debug.Log("Dotisverywrong");
*/
returnflyPath.GetMV(time-startTime);
publicoverridevoidEnable()
base.Enable();
offsetter.SetupOffsets(this);
publicvoidUpdateOffset()
offsetter.UpdateOffset();
privateclassOffsetter
privateJumpclip;
privatereadonlyPlacement[]mainOffsets=newPlacement[3],
shadowOffsets=newPlacement[3];
privateVector2lastLean;
privatefloatblendStart;
publicPlacementLerpOffset(floattime,boolmain)
returnmain?Placement.Lerp(mainOffsets[0],mainOffsets[1],GetLerp(time)):
Placement.Lerp(shadowOffsets[0],shadowOffsets[1],GetLerp(time));
privatefloatGetLerp(floattime)
floatendTime=clip.WillHit?clip.HitTime:clip.startTime+3;
floatrange=endTime-clip.startTime-blendStart;
return(time-clip.startTime-blendStart)/range;
publicvoidSetupOffsets(Jumpclip)
this.clip=clip;
blendStart=0;
lastLean=Vector2.zero;
GetSwingOffsets(true);
publicvoidUpdateOffset()
GetSwingOffsets(false);
blendStart=GTime.Now-clip.startTime;
privatevoidGetSwingOffsets(boolinit)
if(init)
mainOffsets[2]=newPlacement(Level.GamePlane(clip.startSide),Rot.Zero);
shadowOffsets[2]=Placement.Zero;
mainOffsets[2].DebugIfNaN("MainOffsets2");
Placementbasic=clip.BasicPlacement(clip.startTime);
Swingswing=clip.beforeasSwing;
mainOffsets[0]=swing.FinalPlacement(clip.startTime)-basic;
shadowOffsets[0]=swing.BasicPlacement(clip.startTime,true)-basic;
mainOffsets[0].DebugIfNaN("MainOffsets0");
else
mainOffsets[0]=LerpOffset(GTime.Now,true);
shadowOffsets[0]=LerpOffset(GTime.Now,false);
if(clip.WillConnect)
floatendTime=clip.HitTime;
Swingswing=clip.afterasSwing;
Vector2stickLean=ActorAnim.GetLean(swing.GetStick(endTime).Item,endTime);
if(init||stickLean!=lastLean)
lastLean=stickLean;
Placementbasic=clip.BasicPlacement(endTime);
mainOffsets[1]=swing.FinalPlacement(endTime)-basic;
shadowOffsets[1]=swing.BasicPlacement(endTime,true)-basic;
mainOffsets[1].DebugIfNaN("MainOffsets1");
else
mainOffsets[1]=mainOffsets[2];
shadowOffsets[1]=shadowOffsets[2];
publicabstractpartialclassClip
publicstaticClipGet_Jump(Spinnerspinner,floatstartTime,floatstartAngle,Vector2jumpV,floatstartSpin,floatduration,StickIDstickID,floatweightLerp,ClipTypenextClip,Sideside)
Prep.startAngle=startAngle;
Prep.jumpV=jumpV;
Prep.startSpin=startSpin;
Prep.duration=duration;
Prep.stickID=stickID;
Prep.weightLerp=weightLerp;
Prep.nextClip=nextClip;
returnPoolClip(ClipType.Jump,spinner,startTime,side);
publicpartialclassJump
publicoverrideboolSerialize(BinaryWriterwriter)
boolserializingWorked=true;
writer.Write(Crunch.FloatToShort(startTime,2,refserializingWorked));
writer.Write((short)stick.SerializeValue);
writer.Write((byte)Mathf.Round(weightLerp*100));
if(next==0)
writer.Write((sbyte)next);
writer.Write((byte)0);
else
shortshortDuration=Crunch.FloatToShort(duration,2,refserializingWorked);
sbytenextbyte=(sbyte)((int)next*(shortDuration>255?-1:1));
bytedurationByte=(byte)(shortDuration>255?shortDuration-255:shortDuration);
writer.Write(nextbyte);
writer.Write(durationByte);
/*Debug.Log("JumpX"+jumpV.x+"->"+Crunch.FloatToShort(jumpV.x,2,refserializingWorked));
Debug.Log("JumpY"+jumpV.y+"->"+Crunch.FloatToShort(jumpV.y,2,refserializingWorked));*/
writer.Write(Crunch.FloatToShort(jumpV.x,2,refserializingWorked));
writer.Write(Crunch.FloatToShort(jumpV.y,2,refserializingWorked));
writer.Write(Crunch.FloatToShort(startAngle,2,refserializingWorked));
writer.Write(Crunch.FloatToShort(startSpin,3,refserializingWorked));
returnserializingWorked;
privatestaticvoidDeserializeClip(BinaryReaderreader,floattimeShift)
shortshort_Time=reader.ReadInt16();//2
shortshort_ItemID=reader.ReadInt16();//2
bytebyte_Weight=reader.ReadByte();//1
sbytesbyte_Next=reader.ReadSByte();//1
bytebyte_Duration=reader.ReadByte();//1
shortshort_JumpV_x=reader.ReadInt16();//2
shortshort_JumpV_y=reader.ReadInt16();//2
shortshort_Angle=reader.ReadInt16();//2
shortshort_Spin=reader.ReadInt16();//2
floattime=Crunch.ShortToFloat(short_Time,2);
intitemID=short_ItemID;
Itemitem=Item.Get(Mathf.Abs(itemID)-1,timeShift);
Prep.stickID=newStickID(item,itemID>0);
Prep.startTime=Mathf.Abs(time)+timeShift;
Prep.weightLerp=(float)byte_Weight/100;
sbytesignedNext=sbyte_Next;
shortreaderDuration=(short)(byte_Duration+(signedNext>0?0:255));
Prep.nextClip=(ClipType)Mathf.Abs(signedNext);
Prep.duration=Prep.nextClip==0?0:Crunch.ShortToFloat(readerDuration,2);
Prep.jumpV=newVector3(Crunch.ShortToFloat(short_JumpV_x,2),
Crunch.ShortToFloat(short_JumpV_y,2));
if(f.Same(Prep.jumpV.x,0)||f.Same(Prep.jumpV.y,0))
Debug.Log("CrunchIssue".B_Red());
Prep.startAngle=Crunch.ShortToFloat(short_Angle,2);
Prep.startSpin=Crunch.ShortToFloat(short_Spin,3);
publicstaticClipDeserializeClip(BinaryReaderreader,Spinnerspinner,Sideside,floattimeShift)
DeserializeClip(reader,timeShift);
returnPoolClip(ClipType.Jump,spinner,Prep.startTime,side);
/*publicoverrideboolGetClipBounds(ClipBoundPoolpool)
Vector2pos=CalculateStartPos(stick,spinner.size.y*.5f,startAngle,startTime);
flyPath=newFlyPath(pos,Prep.jumpV);
floatlength=next!=0?duration:10000;
floatstart=Mathf.Max(startTime,pool.min);
floatend=Mathf.Min(startTime+length,pool.max);
for(floattimeA=start;timeA<end;timeA+=ClipBounds.SearchStep)
floattimeB=Mathf.Min(timeA+ClipBounds.SearchStep,end);
ClipBoundscBounds=pool.Get.Set(timeA,timeB,Type,startSide);
floatflightA=timeA-startTime,flightB=timeB-startTime;
cBounds.bounds.Set(flyPath.GetPos(flightA)).Add(flyPath.GetPos(flightB));
if(flyPath.apexTime>flightA&&flyPath.apexTime<=flightB)
cBounds.bounds.Add(flyPath.GetPos(flyPath.apexTime));
cBounds.bounds.Pad(spinner.size.y*.5f);
returntrue;
namespaceClips
publicclassNone:Clip
publicstaticreadonlyNoneGet=newNone();
privatestring_validation;
protectedNone(ClipTypetype=0):base(type){}
publicoverridePlacementBasicPlacement(floattime,boolshadow=false)
returnPlacement.OutOfSight;
publicoverridePlacementFinalPlacement(floattime)
returnPlacement.OutOfSight;
publicoverrideVector2GetMV(floattime)
returnV2.zero;
namespaceClips
publicclassSpawn:Swing
publicSpawn():base(ClipType.Spawn){}
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
duration=Prep.duration;
base.Setup(spinner,startTime,startSide);
returnthis;
publicoverrideboolSerialize(BinaryWriterwriter)
boolserializingWorked=true;
writer.Write(Crunch.FloatToShort(startTime,2,refserializingWorked));
writer.Write(Crunch.FloatToShort(duration,2,refserializingWorked));
returnserializingWorked;
publicstaticClipDeserializeClip(BinaryReaderreader,Spinnerspinner,Sideside,floattimeShift)
Prep.Jump=null;
Prep.startTime=Crunch.ShortToFloat(reader.ReadInt16(),2)+timeShift;
Prep.duration=Crunch.ShortToFloat(reader.ReadInt16(),2);
returnPoolClip(ClipType.Spawn,spinner,Prep.startTime,side);
/*publicoverrideboolGetClipBounds(ClipBoundPoolpool)
floatrunTime=duration>0?duration:ClipBounds.Forever;
pool.Get.Set(startTime,startTime+runTime,Type,startSide).
bounds.Set(Level.StartStick.bounds).Pad(spinner.size.y);
returntrue;
publicabstractpartialclassClip
publicstaticClipGet_Clip_Spawn(Spinnerspinner,floatstartTime,Sideside)
Prep.Jump=null;
Prep.duration=0;
returnPoolClip(ClipType.Spawn,spinner,startTime,side);
namespaceClips
publicclassSwing:Clip
staticSwing()
swingCurve=newAnimationCurve(newKeyframe(0,0,1.6275f,1.6275f),
newKeyframe(.5f,.5f,.78f,.78f),
newKeyframe(1,1,1.6275f,1.6275f))
constintdivision=3600;
angleMap=newfloat[3600];
for(inti=0;i<division;i++)
floatstartRot=i*.1f;
floatsampleTime=Mathf.Repeat(ClosestSampleRotationTime(startRot,0,36,1f/36)-1f/36,1);
angleMap[i]=ClosestSampleRotationTime(startRot,sampleTime,200,.01f/36);
publicSwing(ClipTypetype=ClipType.Swing):base(type){}
publicStickIDstartStick;
publicVector2startMotion;
publicfloatstartAngle,startSpinSpeed,spinSpeed;
privatefloatc_ResultSpeed,c_Accel2New,c_Time2New,c_Accel2Basic,c_Time2Basic;
privateconstfloatflyDirection=.35f;
privateboolHands{get{returnstartStick.hands;}}
publicboolDebugCrash;
privatestaticreadonlyAnimationCurveswingCurve,inverseCurve;
privatestaticreadonlyfloat[]angleMap;
publicQuaternionBasicRot(floattime)
floatanimLerp=GetAnimLerp(time);
floatangle=Mathf.Repeat(swingCurve.Evaluate(animLerp)*360f+(Hands?0:180),360);
returnRot.Z(angle);
publicoverridePlacementBasicPlacement(floattime,boolshadow=false)
StickIDstick=GetStick(time);
Vector2stickPos=stick.Item.GetLagPos(time);
Quaternionrot2D=BasicRot(time);
Vector2bodyV;
if(shadow)
stickPos+=ActorAnim.GetLean(stick.Item,time);
bodyV=rot2D*newVector2(0,-stick.Sign*spinner.size.y*.5f*spinner.GetSquash(time));
else
bodyV=rot2D*newVector2(0,-stick.Sign*spinner.ConnectRadius(stick.Item));
returnnewPlacement(stickPos+bodyV,rot2D);
publicoverridePlacementFinalPlacement(floattime)
StickIDstick=GetStick(time);
Sideside=GetSide(time);
Vector2pos=stick.Item.GetPos(time);
Vector2leanPos=stick.Item.GetLagPos(time);
Vector2animLean=ActorAnim.GetLean(stick.Item,time);
QuaternionstickRot=(animLean+(leanPos-pos)).LeanRotGlobal(side);
PlacementposeOffset=spinner.rig.poser.GetSwingOffset(ReadPose(time),spinner.GetSquash(time),stick.hands,stick.Item.radius);
Quaternionrot2D=poseOffset.rot*BasicRot(time);
Vector3bodyOffset=rot2D*poseOffset.pos;
floatalongStick=(Level.PlaneOffset+spinner.GetZShift(time))*side.Sign;
Vector3resultPos=pos.V3(Level.WallDepth*side.Sign)
+stickRot*bodyOffset.AddZ(alongStick);
returnnewPlacement(resultPos,stickRot*rot2D);
publicoverrideVector2GetMV(floattime)
returnGetStick(time).Item.GetMV(time)*.55f;
publicVector2GetForceV(floattime)
StickIDStick=GetStick(time);
floatactualSpin=GetActualSpeed(time);
floatspinSign=Mathf.Sign(actualSpin);
Quaternionrot2D=BasicRot(time);
booltoBack=!f.Same(spinSign,Stick.Sign);
Vector2rotateVector=rot2D*newVector2(toBack?1:-1,0);
Vector2bodyVector=rot2D*newVector2(0,Stick.Sign);
Vector2forceV=Vector2.Lerp(bodyVector,rotateVector,flyDirection);
returnforceV.SetLength(actualSpin*-spinSign*GPhysics.JumpForce);
publicVector2GetWeightDir(floattime)
boolhands=GetStick(time).hands;
floatweightLerp=GetWeightLerp(time);
floatspin=GetJumpSpin(time);
Quaternionrot=BasicRot(time);
returnGetWeightForce(rot,spin,weightLerp,hands);
publicstaticVector2GetWeightForce(Quaternionrot,floatspinSpeed,floatweightLerp,boolhands)
constfloatplayerWeight=.012f;//.0305f;
floathandFeetSign=hands?-1:1;
Vector2forceDir=rot*newVector2(0,handFeetSign*Mathf.Abs(spinSpeed));
returnnewVector2(forceDir.x*weightLerp*playerWeight,forceDir.y*weightLerp*playerWeight);
privatefloatGetWeightLerp(floattime)
constfloatweightLerpSpeed=6;
returnMathf.SmoothStep(0,1,(time-startTime)*weightLerpSpeed);
publicfloatGetActualSpeed(floattime)
floatstickTime=time-startTime;
if(stickTime>=c_Time2Basic)
returnGPhysics.SpinSpeed*Mathf.Sign(spinSpeed);
returnspinSpeed+.5f*c_Accel2Basic*(stickTime*stickTime)*Mathf.Sign(spinSpeed);
privateboolwarpTriggered;
privateStickIDwarpStick;
privatefloatwarpTime;
privateboolHasWarped(floattime)
if(time>=warpTime)
if(!warpTriggered)
warpTriggered=true;
if(spinner.isFocus&&startStick.Item.side==warpStick.Item.side)
MoveCam.SetWarp(time,startStick.Item.GetPos(time),warpStick.Item.GetPos(time));
ActorAnimator.OnWarp(this,time);
Sound.Get(Audio.Sound.StickWarp).PlayerMulti(spinner).SetItem(startStick.Item).Play();
returntrue;
returnfalse;
publicStickIDGetStick(floattime)
returnHasWarped(time)?warpStick:startStick;
publicoverrideSideGetSide(floattime)
returnHasWarped(time)?warpStick.Item.side:startSide;
privatefloatGetAnimLerp(floattime)
floatonStickTime=time-startTime;
floatspunSoFar;
if(onStickTime<c_Time2Basic)
spunSoFar=AccelSpin(onStickTime);
else
spunSoFar=AccelSpin(c_Time2Basic)+SpinAngle_Deg(GPhysics.SpinSpeed*Mathf.Sign(spinSpeed),onStickTime-c_Time2Basic);
constfloatcurveMapFactor=.7265f;
spunSoFar*=curveMapFactor;
floatangle=startAngle+spunSoFar+(Hands?0:180);
returnMathf.Repeat(angle%360f/360f,1);
privatestaticfloatSpinAngle_Deg(floatstartSpin,floattime)
returnstartSpin*time*GPhysics.SpinMulti;
privatefloatAccelSpin(floattime)
floatreturnAngle;
if(time<c_Time2New)
returnAngle=c_ResultSpeed*time+.5f*c_Accel2New*time*time;
else
returnAngle=c_ResultSpeed*c_Time2New+.5f*c_Accel2New*c_Time2New*c_Time2New;
returnAngle+=spinSpeed*(time-c_Time2New)+.5f*c_Accel2Basic*(time-c_Time2New)*(time-c_Time2New)*Mathf.Sign(spinSpeed);
returnreturnAngle*GPhysics.SpinMulti;
protectedoverrideClipSetup(Spinnerspinner,floatstartTime,SidestartSide)
base.Setup(spinner,startTime,startSide);
warpTime=float.MaxValue;
warpTriggered=false;
if(Prep.Jump==null)
startStick=newStickID(Level.StartStick,true);
startSpinSpeed=GPhysics.SpinSpeed*.95f;
spinSpeed=GPhysics.SpinSpeed;
else
startStick=Prep.Jump.nextStick;
Placementplacement=Prep.Jump.BasicPlacement(startTime);
floatangleNow=placement.rot.eulerAngles.z;
Vector2charPos=placement.pos;
Vector2charMotion=newFlyPath(Vector2.zero,Prep.Jump.jumpV).GetMV(Prep.Jump.duration);
if(charMotion.magnitude>=FlyPath.CrashSpeed)
DebugCrash=true;
if(startStick.Item==null)
Debug.Log("SwingStartItemIsNull...");
Vector2stickPosition=startStick.Item.GetLagPos(startTime);
Vector2stickMovement=startStick.Item.GetMV(startTime);
Vector2combinedMotion=charMotion-stickMovement;
floatangle=Vector2.Angle(combinedMotion,V2.up.Rot(angleNow));
if(angle>90)
angle=90-(angle-90);
constfloatdivMulti=1f/90;
angle*=divMulti;
constfloatc_spinConnectionFactor=.3f;
constfloatc_speedConnectionFactor=.9f;
Vector2stickDir=stickPosition+combinedMotion.normalized-stickPosition;
Vector2stickPos=charPos-stickPosition;
intstickSide=stickDir.Side_Sign(stickPos);
floatmomentumSpin=combinedMotion.magnitude*c_speedConnectionFactor*(stickSide>=0?1:-1);
floatspinSpin=(f.Same(stickSide,Mathf.Sign(startSpinSpeed))?angle:-angle)*Mathf.Abs(startSpinSpeed)*c_spinConnectionFactor;
floatcombinedSpinSpeed=Mathf.Lerp(momentumSpin,spinSpin,.5f);
startMotion=combinedMotion;
floatgravityLerp=Vector2.Angle(V2.down,combinedMotion)/180;
floatgravitySpin=Mathf.Lerp(10.75f,7.25f,gravityLerp);
spinSpeed=gravitySpin*Mathf.Sign(combinedSpinSpeed)+combinedSpinSpeed;
startAngle=GetStartRot(angleNow,startStick.Sign);
floata=Mathf.Repeat(angleNow,360);
floatb=Mathf.Repeat(BasicRot(startTime).eulerAngles.z,360);
if(Mathf.Abs(a-b)>2)
Debug.Log("Before:"+a+"After:"+b);
c_ResultSpeed=Mathf.Lerp(startSpinSpeed,spinSpeed,.5f);
floatspeedDifference=spinSpeed-c_ResultSpeed;
c_Time2New=Mathf.Abs(speedDifference)*.0475f/(1+startMotion.magnitude*.515f);
c_Accel2New=speedDifference/c_Time2New;
constfloatabsGoal=GPhysics.SpinSpeed;
floatabsSpeed=Mathf.Abs(spinSpeed);
floatspeedDiff=Mathf.Abs(absSpeed-absGoal);
c_Accel2Basic=absSpeed>absGoal?-2.2f:20;
c_Time2Basic=speedDiff/Mathf.Abs(c_Accel2Basic);
c_Time2Basic+=c_Time2New;
returnthis;
publicvoidSetWarp(ItemwarpBuddy)
warpTime=startTime+Warp.warpTime;
warpStick=newStickID(warpBuddy,startStick.hands);
privatestaticfloatGetStartRot(floatstartRot,floatspinPoint)
startRot=Mathf.Repeat(startRot+(spinPoint<0?180:0),360f);
returnangleMap[(int)Mathf.Repeat(Mathf.Round(startRot*10),3600)]*360+(spinPoint<0?180:0);
privatestaticfloatClosestSampleRotationTime(floatstartRot,floatgotTime,intsteps,floatstepLength)
floatdifference=float.MaxValue;
floatreturnTime=0;
for(inti=0;i<steps;i++)
floatcheckTime=gotTime+stepLength*i;
floatsampleAngle=swingCurve.Evaluate(checkTime)*360;
floatcheckDiff=Mathf.Abs(sampleAngle-startRot);
if(checkDiff<difference)
difference=checkDiff;
returnTime=checkTime;
returnreturnTime;
/*publicoverrideboolGetClipBounds(ClipBoundPoolpool)
floatrunTime=duration>0?duration:ClipBounds.Forever;
if(startStick.Item.parent==null)
ItemwarpBuddy=(Item)startStick.Item.GetLink(linkType.Warp,true).b;
if(warpBuddy!=null)
boolwarpHappens=runTime>=Warp.warpTime;
pool.Get.Set(startTime,startTime+(warpHappens?Warp.warpTime:runTime),Type,startSide).
bounds.Set(startStick.Item.bounds).Pad(spinner.size.y);
if(warpHappens)
pool.Get.Set(startTime+Warp.warpTime,startTime+runTime,Type,warpBuddy.side).bounds.
Set(warpBuddy.bounds).Pad(spinner.size.y);
else
pool.Get.Set(startTime,startTime+runTime,Type,startSide).bounds.Set(startStick.Item.bounds).Pad(spinner.size.y);
returntrue;
Itemitem=startStick.Item;
Tracktrack=item.parent;
if(track.subBoundCount==1)
pool.Get.Set(startTime,startTime+runTime,Type,item.side).bounds.Set(track.bounds).Pad(spinner.size.y);
returntrue;
floatstart=Mathf.Max(startTime,pool.min);
floatend=pool.max;
intsubStep=track.SubStep(item,start);
intsubIndex=track.SubIndex(subStep);
floatboundStart=start;
ClipBoundscBounds=null;
floatradiusTweak=startStick.Item.radius-track.maxItemRadius+spinner.size.y;
for(floattimeA=start;timeA<=end;timeA+=ClipBounds.SearchStep)
intnewSubStep=track.SubStep(item,timeA);
intdiff=newSubStep-subStep;
intabsDiff=Mathf.Abs(diff);
if(absDiff==0)
continue;
intnewSubIndex=track.SubIndex(newSubStep);
if(newSubIndex!=subIndex)
cBounds=pool.Get.Set(boundStart,timeA,Type,item.side);
cBounds.bounds.Set(track.GetSubBound(subIndex).bounds);
if(absDiff>1)
intdir=diff>0?1:-1;
for(inti=1;i<absDiff;i++)
intsubIndexStep=track.SubIndex(subStep+dir*i);
cBounds.bounds.Set(track.GetSubBound(subIndexStep).bounds);
cBounds.bounds.Pad(radiusTweak);
boundStart=timeA-ClipBounds.SearchStep;
subStep=newSubStep;
subIndex=newSubIndex;
if(timeA+ClipBounds.SearchStep>=end&&cBounds!=null)
cBounds.endTime=end;
returnfalse;
publicClipGetJumpData(floateventTime,Spinnerspinner)
eventTime=eventTime.DigitCeil(2);
PlacementbasicPlacement=BasicPlacement(eventTime);
Profiler.BeginSample("Stick_JumpFromCheck");
ClipjumpClip=Prediction.JumpCheck(eventTime,spinner,basicPlacement.pos,GetWeightLerp(eventTime),basicPlacement.rot,GetForceV(eventTime),GetJumpSpin(eventTime),GetStick(eventTime));
Profiler.EndSample();
returnjumpClip;
privatefloatGetJumpSpin(floattime)
floatspinAnimLerp=GetAnimLerp(time);
floatfirst=swingCurve.Evaluate(Mathf.Repeat(spinAnimLerp,1));
floatsecond=swingCurve.Evaluate(Mathf.Repeat(spinAnimLerp+.01f,1));
Vector3tangentVector=newVector3(spinAnimLerp+.01f,second,0)-newVector3(spinAnimLerp,first,0);
floatscaleFactor=1f/tangentVector.x;
floatmultiplier=tangentVector.y*scaleFactor;
if(multiplier<0)
multiplier+=100;
returnGetActualSpeed(time)*multiplier*.85f;
publicabstractpartialclassClip
publicstaticClipGet_Clip_Swing(Jumpjump)
Prep.Jump=jump;
returnPoolClip(ClipType.Swing,jump.spinner,jump.HitTime,jump.startSide);
publicstaticclassCrunch
publicstaticVector2DigitClamp(thisVector2vector,intdigits)
floatxMulti=Mathf.Clamp01(short.MaxValue/Mathf.Round(Mathf.Abs(vector.x)*Mth.IntPow(10,digits)));
floatyMulti=Mathf.Clamp01(short.MaxValue/Mathf.Round(Mathf.Abs(vector.y)*Mth.IntPow(10,digits)));
floatfactor=Mathf.Min(xMulti,yMulti);
returnTrim(vector*factor,digits);
privatestaticVector2Trim(thisVector2vector,intdigits)
returnnewVector2(vector.x.DigitRound(digits),vector.y.DigitRound(digits));
publicstaticfloatDigitCeil(thisfloatvalue,intdigits)
floatfactor=Mth.IntPow(10,digits);
returnMathf.Ceil(value*factor)/factor;
publicstaticfloatDigitRound(thisfloatvalue,intdigits)
floatfactor=Mth.IntPow(10,digits);
returnMathf.Round(value*factor)/factor;
publicstaticfloatDigitFloor(thisfloatvalue,intdigits)
floatfactor=Mth.IntPow(10,digits);
returnMathf.Floor(value*factor)/factor;
publicstaticshortFloatToShort(floatinputValue,intdigits,refboolserializingWorked)
inttoShort=Mathf.RoundToInt(inputValue*Mth.IntPow(10,digits));
if(toShort>short.MaxValue||toShort<short.MinValue)
Debug.Log((inputValue+"doesn'tfitshort:"+toShort).B_Red());
serializingWorked=false;
return0;
return(short)toShort;
publicstaticfloatShortToFloat(shortinputValue,intdigits)
returninputValue/Mth.IntPow(10,digits);
publicstaticboolHasToBeTrimmed(thisfloatvalue,intdigits)
returnshort.MaxValue/Mathf.Round(Mathf.Abs(value)*Mth.IntPow(10,digits))<1;
publicstaticclassDigit
publicstaticfloatRound(floatvalue,floatdivision)
floata=Mathf.Floor(value);
floatb=Mathf.Round(value%1f*division);
returna+b/division;
publicstaticvoidRoundWrite(floatvalue,intdivision,BinaryWriterwriter,booldigitNegative=false)
floata=Mathf.Floor(value);
floatb=Mathf.Round(value%1f*division);
writer.Write((short)a);
writer.Write((sbyte)(b*(digitNegative?-1:1)));
publicstaticfloatFloor(floatvalue,floatdivision)
floata=Mathf.Floor(value);
floatb=Mathf.Floor(value%1f*division);
returna+b/division;
publicstaticvoidFloorWrite(floatvalue,intdivision,BinaryWriterwriter,booldigitNegative=false)
floata=Mathf.Floor(value);
floatb=Mathf.Floor(value%1f*division);
writer.Write((short)a);
writer.Write((sbyte)(b*(digitNegative?-1:1)));
publicstaticfloatCeil(floatvalue,floatdivision)
floata=Mathf.Floor(value);
floatb=Mathf.Ceil(value%1f*division);
returna+b/division;
publicstaticvoidCeilWrite(floatvalue,intdivision,BinaryWriterwriter,booldigitNegative=false)
floata=Mathf.Floor(value);
floatb=Mathf.Ceil(value%1f*division);
writer.Write((short)a);
writer.Write((sbyte)(b*(digitNegative?-1:1)));
publicstaticfloatRead(BinaryReaderreader,floatdivision,outfloatdigitSign)
floata=reader.ReadInt16();
floatb=reader.ReadSByte();
digitSign=Mathf.Sign(b);
returna+Mathf.Abs(b)/division;
publicstaticclassGPhysics
publicconstfloatStepsPerSecond=20;
publicconstfloatTimeStep=1f/StepsPerSecond;
publicconstfloatGravity=17;//19.25f;//19;
publicconstfloatSpinSpeed=14.5f;
publicconstfloatSpinMulti=35;
publicconstfloatJumpForce=.9f;//.95f;//1f;
privateconstfloatspinDamp=95;//95f;
publicstaticfloatGet_SpinAngle_Deg(floatstartSpin,floattime)
time=Mathf.Min(time,Get_SpinStopTime(startSpin));
floatabsStartSpin=Mathf.Abs(startSpin);
returnMathf.Sign(startSpin)*(absStartSpin*SpinMulti*time+.5f*-spinDamp*Mth.IntPow(time,2));
publicstaticfloatGet_SpinSpeed_After(floatstartSpin,floattime)
floattimeUntilStop=Get_SpinStopTime(startSpin);
if(time<=timeUntilStop)
returnstartSpin+spinDamp/SpinMulti*time*-Mathf.Sign(startSpin);
return0;
publicstaticfloatGet_SpinStopTime(floatstartSpin)
returnMathf.Abs(startSpin)*SpinMulti/spinDamp;
publicstaticfloatGetStartSpin(floatendAngle,floattime)
returnMathf.Sign(endAngle)*(Mathf.Abs(endAngle)/time--spinDamp*time*.5f)/SpinMulti;
publicstaticfloatOscillate(floattime,floatmaxTime,floatfrequency,floatdampExp,floatspringAccel,floatoffset=0)
floatlerp=time/maxTime;
floatamplitude=Mathf.Pow(1-lerp,dampExp);
floataccel=.5f*frequency*springAccel*time*time;
return(Mathf.Sin((offset+frequency*time+accel)*Mathf.PI*2)*amplitude).NaNChk();
publicstaticfloatNewOscillate(floattime,floatfrequency,floatduration=10,booloneSided=false)
floatlerp=Mathf.Clamp01(time/duration);
floatsideLerp=oneSided?1-Mathf.Pow(1-lerp,3):0;
floatamplitude=Mathf.Pow(1-lerp,2)*(1-.5f*sideLerp);
return((Mathf.Sin(frequency*time*Mathf.PI*2)*amplitude).NaNChk()+sideLerp)*amplitude;
publicstructFlyPath
publicconstfloatCrashSpeed=35;
privateconstfloatPow=2.5f;//2.4f;
privateconstfloatLinearStartSpeed=31.5f;//27.5f;
privateconstfloatMaxFallSpeed=60;
privateconstfloatGravity=GPhysics.Gravity;
publicreadonlyVector2startPos,startMV;
privatereadonlyVector2expMV;
publicreadonlyfloatapexTime,linearStart,maxSpeedTime;
privatereadonlyfloatexpY;
publicFlyPath(Vector2startPos,Vector2startMv)
this.startPos=startPos;
this.startMV=startMv;
linearStart=GetLinearStartTime(startMv);
maxSpeedTime=GetMaxFallSpeedTime(startMv,linearStart);
apexTime=Get_ApexTime(startMv);
expY=startMv.y*linearStart-.5f*GPhysics.Gravity*Mathf.Pow(linearStart,Pow)+startPos.y;
expMV=Get_MotionVector(linearStart,startMv,linearStart,maxSpeedTime);
publicVector2GetPos(floattime)
floatw=1/(.005f*Mathf.Abs(startMV.x));
floatmovedX=startMV.x*w*Mathf.Log(1+time/w);
floatx=movedX+startPos.x;
floaty;
if(time<=linearStart)
y=startMV.y*time-.5f*Gravity*Mathf.Pow(time,Pow)+startPos.y;
elseif(time<=maxSpeedTime)
floatlinearTime=time-linearStart;
y=expMV.y*linearTime-.5f*Gravity*Mth.IntPow(linearTime,2)+expY;
else
floatlinearTime=maxSpeedTime-linearStart;
floatlinearY=expMV.y*linearTime-.5f*Gravity*Mth.IntPow(linearTime,2)+expY;
y=linearY-MaxFallSpeed*(time-maxSpeedTime);
returnnewVector2(x,y);
publicVector2GetMV(floattime)
returnGet_MotionVector(time,startMV,linearStart,maxSpeedTime);
privatestaticfloatGet_ApexTime(Vector3mV)
if(mV.y<=0)
return0;
floatexpAccel=Mathf.Pow(mV.y/(.5f*Gravity*Pow),1f/(Pow-1));
returnexpAccel;
privatestaticVector2Get_MotionVector(floattime,Vector2mV,floatlinearStart,floatmaxSpeedTime)
floatxVel=AirXVelocity(mV.x,time);
floatyVel;
if(time<=linearStart)
yVel=mV.y-.5f*Gravity*Pow*Mathf.Pow(time,Pow-1);
elseif(time<=maxSpeedTime)
floatexpY_Vel=mV.y-.5f*Gravity*Pow*Mathf.Pow(linearStart,Pow-1);
floatlinearTime=time-linearStart;
yVel=expY_Vel-Gravity*linearTime;
else
yVel=-MaxFallSpeed;
returnnewVector2(xVel,yVel);
privatestaticfloatAirXVelocity(floatxSpeed,floattime)
floatw=1/(.005f*Mathf.Abs(xSpeed));
returnxSpeed/(1+time/w);
privatestaticfloatGetMaxFallSpeedTime(Vector3mV,floatlinearStart)
Vector2expMV=Get_MotionVector(linearStart,mV,linearStart,float.MaxValue);
floatspeed=expMV.y+MaxFallSpeed;
if(speed<=0)
returnlinearStart;
returnlinearStart+speed/Gravity;
privatestaticfloatGetLinearStartTime(Vector3mV)
floatspeed=mV.y+LinearStartSpeed;
if(speed<=0)
return0;
returnMathf.Pow(speed/(.5f*Gravity*Pow),1f/(Pow-1));
publicBounds2DFillBounds(floattimeA,floattimeB)
Vector2posA=GetPos(timeA);
Vector2posB=GetPos(timeB);
Bounds2Dbounds=newBounds2D(posA).Add(posB);
if(timeA<=apexTime&&timeB>=apexTime)
bounds=bounds.Add(GetPos(apexTime));
returnbounds;
publicstaticclassLayers
publicconstintMainA=8;
publicconstintMainB=9;
publicconstintMainA_bit=1<<MainA;
publicconstintMainB_bit=1<<MainB;
publicconstintBackA=12;
publicconstintBackB=13;
publicconstintBackA_bit=1<<BackA;
publicconstintBackB_bit=1<<BackB;
publicconstintShadowA=16;
publicconstintShadowB=17;
publicconstintLightA=14;
publicconstintLightB=15;
publicstaticclassSetVolume
staticSetVolume()
everything=Resources.Load("Audio/Everything")asAudioMixer;
privatestaticreadonlyAudioMixereverything;
privatestaticbool_mute;
[Switch("Audio/Mute")]
publicstaticboolMute
set
_mute=value;
everything.SetFloat("masterVolume",_mute?-80:0);
get{return_mute;}
publicstaticvoidUpdateVolume()
everything.SetFloat("masterVolume",_mute||GTime.Paused?-80:0);
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
privatestaticvoidMainFirstStart()
Run.PutInScene();
Run.Inst.StartCoroutine(WaitRun());
privatestaticIEnumeratorWaitRun()
yieldreturnnull;
if(SceneManager.GetActiveScene().name=="main")
UpdateVolume();
publicclassFade:Singleton<Fade>
publicImageimage;
privatestaticImageImage{get{returnInst.image;}}
privatestaticboolvisible;
privateconstfloatfadeSpeed=.8f;
publicstaticvoidSetVisibility(boolvisible)
Image.transform.parent.gameObject.SetActive(true);
Image.enabled=visible;
Colorc=Image.color;
Image.color=newColor(c.r,c.g,c.b,visible?1:0);
Fade.visible=visible;
publicstaticvoidTransition(Action<bool>setActive,Action<bool>setInactive)
setActive(true);
setInactive(false);
privateIEnumeratorTransitionFade(Action<bool>setActive,Action<bool>setInactive)
if(!visible)
yieldreturnStartCoroutine(FadeIn());
setActive(true);
setInactive(false);
StartCoroutine(FadeOut());
privatestaticIEnumeratorFadeIn()
visible=true;
floatstart=Image.color.a;
floatspeed=1f/Mathf.Abs(start-1);
Image.enabled=true;
Image.transform.parent.gameObject.SetActive(true);
floatlerp=0;
Colorc=Image.color;
while(lerp<1&&visible)
lerp+=Time.deltaTime*fadeSpeed*speed;
Image.color=newColor(c.r,c.g,c.b,Mathf.SmoothStep(start,1,lerp));
yieldreturnnull;
privatestaticIEnumeratorFadeOut()
visible=false;
floatstart=Image.color.a;
floatspeed=1f/Mathf.Abs(start-0);
Image.enabled=true;
Image.transform.parent.gameObject.SetActive(true);
floatlerp=0;
Colorc=Image.color;
while(lerp<1&&!visible)
lerp+=Time.deltaTime*fadeSpeed*speed;
Image.color=newColor(c.r,c.g,c.b,Mathf.Lerp(start,0,lerp));
yieldreturnnull;
if(visible)
yieldbreak;
Image.enabled=false;
Image.transform.parent.gameObject.SetActive(false);
publicclassHeight:MonoBehaviour
privatestaticTextMeshProUGUIheightText;
privatestaticintheight;
publicconstfloatFactor=10/3f;
privateconstfloatMulti=1f/Factor;
privatevoidAwake()
heightText=GetComponent<TextMeshProUGUI>();
privatevoidOnEnable()
ResetHeight();
GTime.onPaused+=onPaused;
privatevoidOnDisable()
GTime.onPaused-=onPaused;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
Clipclip=Spinner.CurrentPlayerClip;
if(clip==null)
return;
intcharHeight=Mathf.FloorToInt((clip.BasicPlacement(GTime.Now).pos.y-clip.spinner.size.y*.5f)*Multi);
if(charHeight>height)
height=charHeight;
heightText.text=height.PrepString();
publicstaticvoidResetHeight()
height=0;
if(heightText!=null)
heightText.text=height.PrepString();
privatestaticvoidonPaused(boolpaused)
heightText.enabled=!paused;
publicclassNonDrawingGraphic:Graphic
publicoverridevoidSetMaterialDirty(){}
publicoverridevoidSetVerticesDirty(){}
privateintcount;
protectedoverridevoidOnPopulateMesh(VertexHelpervh)
color=newColor(0,0,0,0);
raycastTarget=true;
publicclassPillUI:MonoBehaviour
privatestaticTextMeshProUGUItext;
privatevoidAwake()
text=GetComponent<TextMeshProUGUI>();
publicstaticvoidSetPillCount(intcount)
if(text!=null)
text.text=count.PrepString();
publicclassPlayerNameUI:MonoBehaviour
[Switch("UI/ShowNames")]privatestaticboolshowLines=true;
privateTextMeshProUGUI[]texts;
privateboolshowingNames;
privateRectTransformrect;
privatevoidAwake()
rect=GetComponent<RectTransform>();
texts=newTextMeshProUGUI[transform.childCount];
for(inti=0;i<texts.Length;i++)
texts[i]=transform.GetChild(i).GetComponent<TextMeshProUGUI>();
texts[i].enabled=false;
privatevoidOnEnable()
GTime.onPaused+=onPaused;
privatevoidOnDisable()
GTime.onPaused-=onPaused;
privatevoidonPaused(boolpaused)
showingNames=paused;
if(!showingNames||!showLines)
for(inti=0;i<texts.Length;i++)
texts[i].enabled=false;
privatevoidLateUpdate()
if(!Application.isMobilePlatform&&Input.GetKeyDown(KeyCode.N))
showingNames=!showingNames;
onPaused(showingNames);
if(!showingNames)
return;
if(!showLines)
for(inti=0;i<texts.Length;i++)
texts[i].enabled=false;
return;
intactiveCount=Spinner.active.Count;
for(inti=0;i<texts.Length;i++)
Spinnerspinner=i<activeCount?Spinner.active[i]:null;
if(spinner!=null&&spinner.visible)
Clipclip=spinner.currentClip;
if(!clip.GetSide(GTime.Now).IsVisible)
if(texts[i].enabled)
texts[i].enabled=false;
continue;
if(!texts[i].enabled)
texts[i].enabled=true;
if(texts[i].text!=spinner.name)
texts[i].text=spinner.name;
Vector3pos=spinner.currentPlacement.pos;
Vector3offset=Camera.main.transform.up*spinner.size.y*-.85f;
Vector3screen=Camera.main.WorldToScreenPoint(pos+offset);
Vector2rectPos;
RectTransformUtility.ScreenPointToLocalPointInRectangle(rect,screen,null,outrectPos);
texts[i].rectTransform.anchoredPosition=rectPos;
else
if(texts[i].enabled)
texts[i].enabled=false;
publicstaticclassScore
staticScore()
playerScores=newint[Spinner.Count];
scoredSticks=newint[Item.TotalCount];
privatestaticreadonlyint[]playerScores;
privatestaticreadonlyint[]scoredSticks;
publicstaticintPlayerOneScore{get{returnplayerScores[0];}}
privatestaticintHighScore;
privatestaticintgameID;
privatestaticScoreUI_scoreUI;
privatestaticboolScoreThisPlayer(Spinnerspinner)
switch(GameManager.Mode)
default:returnfalse;
caseMode.SpinUp:returnspinner.isPlayer;
publicstaticvoidSetScoreUI(ScoreUIscoreUI)
_scoreUI=scoreUI;
publicstaticvoidDeleteHighscore()
UserSave.Height=0;
HighScore=UserSave.Highscore;
if(_scoreUI!=null)
_scoreUI.SetHighScore(HighScore,false);
publicstaticvoidResetScore()
for(inti=0;i<playerScores.Length;i++)
playerScores[i]=0;
gameID+=Spinner.Count;
HighScore=UserSave.Highscore;
if(_scoreUI!=null)
_scoreUI.SetHighScore(HighScore,false);
if(_scoreUI!=null)
_scoreUI.SetScore(PlayerOneScore);
publicstaticvoidOnSwing(Swingswing)
Itemitem=swing.startStick.Item;
if(item.elementType!=elementType.Stick||!ScoreThisPlayer(swing.spinner))
return;
ScoreStick.AddNewState(swing);
if(item==Level.StartStick)
return;
intspinnerID=swing.spinner.ID;
intcheckNumber=spinnerID+gameID;
if(scoredSticks[item.ID]==checkNumber)
Sound.Get(Audio.UI.OldStick).Play();
return;
playerScores[spinnerID]++;
scoredSticks[item.ID]=checkNumber;
Sound.Get(Audio.UI.ScoreUp).Play();
if(_scoreUI!=null)
_scoreUI.SetScore(PlayerOneScore);
publicstaticvoidOnlineScore(intonlineScore)
if(onlineScore>HighScore)
Debug.Log("BetterOnlineScore".B_Yellow());
UserSave.Highscore=HighScore=onlineScore;
if(_scoreUI!=null)
_scoreUI.SetHighScore(HighScore,false);
publicstaticIEnumeratorCheckForHighScore()
if(PlayerOneScore>HighScore)
if(Database.IsConnected)
UserSave.Highscore=PlayerOneScore;
HighScore=PlayerOneScore;
if(_scoreUI!=null)
_scoreUI.SetHighScore(HighScore,true);
Sound.Get(Audio.UI.HighScore).Play();
Debug.Log("NewHighscore!".B_Purple()+Emoji.Success.B_Teal());
yieldbreak;
publicclassScoreUI:MonoBehaviour
publicTextMeshProUGUIscoreText,highScoreText;
privateGameObjectscoreObject,highscoreObject;
privateRectTransformscoreRect,highScoreRect;
privateboolshowScore
set
scoreObject.SetActive(value);
highscoreObject.SetActive(value);
privatevoidAwake()
scoreObject=scoreText.gameObject;
highscoreObject=highScoreText.transform.parent.gameObject;
scoreRect=scoreText.rectTransform;
highScoreRect=highscoreObject.GetComponent<RectTransform>();
privatevoidOnEnable()
BoolSwitch.Link("UI/Score",true,v=>showScore=v);
Score.SetScoreUI(this);
publicvoidSetScore(intscore)
if(score==0)
scoreText.text="X";
else
scoreText.text=score.PrepString();
/*if(score>oldScore&&score>0)
StartCoroutine(Pop());
if(score<oldScore)
StartCoroutine(UnPop());*/
publicvoidSetHighScore(inthighScore,boolanimate)
highScoreText.text=highScore.PrepString();
/*if(animate)
StartCoroutine(PopHighScore());*/
privateIEnumeratorPop()
floatlerp=0;
while(lerp<1)
lerp+=Time.deltaTime*10;
floatscale=Mathf.Lerp(1.45f,1,lerp);
scoreRect.localScale=newVector3(scale,scale,scale);
yieldreturnnull;
privateIEnumeratorUnPop()
floatlerp=0;
while(lerp<1)
floatscale=Mathf.Lerp(.5f,1,lerp);
scoreRect.localScale=newVector3(scale,scale,scale);
lerp+=Time.deltaTime*10;
yieldreturnnull;
privateIEnumeratorPopHighScore()
for(inti=0;i<6;i++)
floatcount=0;
while(count<1)
floatscale=i%2==0?Mathf.Lerp(1,1.2f,count):Mathf.Lerp(1.2f,1,count);
highScoreRect.localScale=newVector3(scale,scale,scale);
count+=Time.deltaTime*15;
yieldreturnnull;
publicclassTimeSliderUI:MonoBehaviour
publicGameObjectsliderObject;
publicTextMeshProUGUIminTimeText,maxTimeText;
[Space(10)]
publicRectTransformsliderRange;
publicRectTransformactualSlider;
publicRectTransformhandle;
[Space(10)]publicGameObjectplayButton;
privatefloatminTime,maxTime;
privatereadonlyVector3[]corners=newVector3[4];
privatefloatsliderLerp,smoothlerp;
privateboolgrabbing;
privateVector2mousePos;
publicstaticboolplayingSlowMo;
privateboolplayNormalSpeed;
privatevoidOnEnable()
GTime.onPaused+=onPaused;
sliderObject.SetActive(false);
playButton.SetActive(false);
privatevoidOnDisable()
GTime.onPaused-=onPaused;
privatevoidonPaused(boolpaused)
sliderObject.SetActive(paused);
playButton.SetActive(paused);
if(!paused)
return;
playingSlowMo=false;
maxTime=GTime.Now;
minTime=Mathf.Clamp(maxTime-GTime.RewindTime,GTime.StartTime,float.MaxValue);
minTimeText.text=Mathf.FloorToInt(minTime).PrepString();
maxTimeText.text=Mathf.FloorToInt(maxTime).PrepString();
sliderLerp=smoothlerp=1;
privatevoidUpdate()
if(!sliderObject.activeInHierarchy)
return;
sliderRange.GetLocalCorners(corners);
actualSlider.offsetMin=V2.right*Mathf.Lerp(0,corners[3].x-corners[0].x,Mathf.InverseLerp(maxTime-GTime.RewindTime,maxTime,minTime));
if(!Input.GetMouseButton(0)&&grabbing)
grabbing=false;
if(grabbing)
actualSlider.GetWorldCorners(corners);
sliderLerp=Mathf.InverseLerp(corners[0].x,corners[3].x,Controll.TouchPos.x);
if(Input.GetKeyDown(KeyCode.LeftShift))
playNormalSpeed=!playNormalSpeed;
if(playingSlowMo)
floatspeed=1f/(maxTime-minTime)*(playNormalSpeed?1:.25f);
smoothlerp=sliderLerp=Mathf.Repeat(sliderLerp+Time.deltaTime*speed,1);
else
smoothlerp=Mathf.Lerp(smoothlerp,sliderLerp,Time.deltaTime*4);
actualSlider.GetLocalCorners(corners);
handle.anchoredPosition=newVector2(Mathf.Lerp(0,corners[3].x-corners[0].x,sliderLerp),0);
GTime.Now=Mathf.Lerp(minTime,maxTime,smoothlerp);
publicvoidGrabbingHandle()
playingSlowMo=false;
grabbing=true;
publicstaticvoidPlayButtonPress()
playingSlowMo=!playingSlowMo;
publicclassToggleUI:MonoBehaviour
publicboolhideOnMobile;
[Space]
publicGameObject[]objects;
privateboolvisible=true;
privatevoidUpdate()
if(Application.isMobilePlatform&&hideOnMobile&&GameManager.Running&&visible)
Toggle();
enabled=false;
if(KeyMap.GetDownKey==KeyCode.F8)
Toggle();
privatevoidToggle()
visible=!visible;
for(inti=0;i<objects.Length;i++)
objects[i].SetActive(visible);
UI_Manager.Show(visible);
publicclassUI_Creator:Singleton<UI_Creator>,IamUI
publicRectTransformparent;
[Space(10)]
publicGameObjectsavePrompt;
publicTextMeshProUGUIsaveName;
publicGameObjectsaveButton,xButton,newButton;
[Space(10)]
publicGameObjectoverWritePrompt;
publicGameObjectoverwriteButton,returnButton;
privatestaticList<UI_Button>categorys;
privatestaticList<List<UI_Button>>categoryButtons;
publicstaticUI_LinkButtonLinkButton;
privatereadonlyList<elementType>allElements=newList<elementType>();
privatestaticboolShowingSavePrompt{get{returnInst!=null&&Inst.savePrompt.activeInHierarchy;}set{Inst.savePrompt.SetActive(value);}}
privatestaticboolShowingOverwrite{get{returnInst!=null&&Inst.overWritePrompt.activeInHierarchy;}set{Inst.overWritePrompt.SetActive(value);}}
publicstaticboolSavingOrLoading{get{returnShowingSavePrompt||ShowingOverwrite;}}
privatestaticreadonlyElementMask[]masks={Mask.IsItem,Mask.IsCollectable,Mask.IsFluff,Mask.IsTrack};
privatestaticreadonlystring[]names={"Items","Stuff","Fluff","Tracks"};
privateconstintcolumns=5,rowButtons=columns-1;
privatestaticGroup[]MaskGroups(ElementMaskmask)
List<Group>returnGroups=newList<Group>();
for(inti=0;i<Groups.All.Length;i++)
Groupgroup=Groups.All[i];
if(mask.Fits(group.Get(0)))
returnGroups.Add(group);
returnreturnGroups.ToArray();
privatevoidOnEnable()
ShowingSavePrompt=ShowingOverwrite=false;
categoryButtons=newList<List<UI_Button>>();
Color[]active={COLOR.blue.cornflower,COLOR.yellow.fresh,COLOR.green.spring};
for(inti=0;i<names.Length;i++)
List<UI_Button>buttonList=newList<UI_Button>();
intbuttonIndex=0;
ColorcolorA=active[i%3];
Group[][]groups=newGroup[4][];
groups[0]=MaskGroups(Mask.IsItem);
groups[1]=MaskGroups(Mask.IsCollectable);
groups[2]=MaskGroups(Mask.IsFluff);
groups[3]=MaskGroups(Mask.IsTrack);
for(inte=0;e<groups[i].Length;e++)
intx=buttonIndex%rowButtons;
inty=1+Mathf.FloorToInt(buttonIndex/(float)rowButtons);
buttonList.Add(newUI_GroupButton(newVector2(x,y),colorA,groups[i][e]));
buttonIndex++;
foreach(elementTypeelementTinEnum.GetValues(typeof(elementType)))
if(Mask.CreatorButton.Fits(elementT)&&masks[i].Fits(elementT))
boolskip=false;
for(inte=0;e<groups[i].Length;e++)
if(groups[i][e].Contains(elementT))
skip=true;
break;
if(skip)
continue;
intindex=allElements.Count;
allElements.Add(elementT);
intx=buttonIndex%rowButtons;
inty=1+Mathf.FloorToInt(buttonIndex/(float)rowButtons);
buttonList.Add(newUI_ElementButton(newVector2(x,y),colorA,elementT.ToString(),
()=>{Creator.SetElementType(allElements[index]);}));
buttonIndex++;
categoryButtons.Add(buttonList);
LinkButton=newUI_LinkButton(Color.grey,"",newVector2(rowButtons,0));
categorys=newList<UI_Button>();
for(inti=0;i<names.Length;i++)
intindex=i;
categorys.Add(newUI_ElementButton(newVector2(i,0),Color.grey,names[i],()=>{SetCategory(index);}));
categorys[0].SetActive(true);
privatevoidLateUpdate()
if(!Input.GetKey(KeyCode.T))
if(Input.GetKeyDown(KeyCode.Alpha1))SetCategory(0);
if(Input.GetKeyDown(KeyCode.Alpha2))SetCategory(1);
if(Input.GetKeyDown(KeyCode.Alpha3))SetCategory(2);
if(Input.GetKeyDown(KeyCode.Alpha4))SetCategory(3);
publicboolHitUI(boolclick)
if(Inst==null)
returnfalse;
if(!SavingOrLoading&&UI_Button.PointedAt(click))
returntrue;
if(UI_Manager.ImPointedAt(saveButton)&&Inst.saveName.text!="")
if(click)
if(LevelSaveLoad.NewSaveFile(Inst.saveName.text))
LevelSaveLoad.SaveLevel(Inst.saveName.text);
else
ShowingOverwrite=true;
returntrue;
ShowingSavePrompt=false;
returntrue;
if(UI_Manager.ImPointedAt(newButton))
if(click)
Creator.NewLevel();
ShowingSavePrompt=false;
returntrue;
if(UI_Manager.ImPointedAt(xButton))
if(click)
ShowingSavePrompt=false;
returntrue;
if(UI_Manager.ImPointedAt(overwriteButton))
if(click)
LevelSaveLoad.SaveLevel(Inst.saveName.text);
ShowingOverwrite=false;
ShowingSavePrompt=false;
returntrue;
if(UI_Manager.ImPointedAt(returnButton))
if(click)
ShowingOverwrite=false;
ShowingSavePrompt=true;
returntrue;
returnfalse;
publicstaticvoidSetCategory(intcategory)
for(inti=0;i<categorys.Count;i++)
categorys[i].StayActive(i==category);
for(inti=0;i<categoryButtons.Count;i++)
boolvisible=i==category;
for(inte=0;e<categoryButtons[i].Count;e++)
categoryButtons[i][e].Show(visible);
Creator.currentFilter=category<4?masks[category]:null;
UI_Button.SetSelectedName(names[category]);
publicstaticvoidSetCurrentElement(stringname)
UI_Button.SetSelectedName(name);
publicstaticvoidShowSavePrompt(stringcurrentLevelName)
ShowingSavePrompt=true;
Inst.saveName.text=currentLevelName!=UI_LevelList.NewLevel?currentLevelName:"";
[Serializable]
privateclassUI_ElementButton:UI_Button
privatereadonlyAction_clickAction;
privateboolstayActive;
publicUI_ElementButton(Vector2offset,ColorcolorOn,stringname,ActionclickAction):base(colorOn,name,offset)
_clickAction=clickAction;
text.text=Regex.Replace(name,"(\\B[A-Z])","$1").Replace("_","").ToUpper();
publicoverridevoidSetActive(boolactive,boolfireAction=true)
image.color=active||stayActive?colorOn:colorOff;
text.color=active||stayActive?Color.black:Color.white;
if(active)
if(fireAction)
_clickAction();
for(inti=0;i<allButtons.Count;i++)
if(allButtons[i]!=this)
allButtons[i].SetActive(false,false);
publicoverridevoidStayActive(boolstayActive)
this.stayActive=stayActive;
protectedoverrideboolPointingAtMe(boolclick)
if(visible&&UI_Manager.ImPointedAt(gameObject))
if(click)
SetActive(true);
returntrue;
returnfalse;
protectedoverrideboolCheckNameMatch(stringname)
if(this.name==name)
SetActive(true,false);
returntrue;
returnfalse;
[Serializable]
privateclassUI_GroupButton:UI_Button
privatereadonlyGroupgroup;
privateintpick;
privatefloatscroll;
privatevoidUpdateText()
stringt=Regex.Replace(group.Get(pick).ToString(),"(\\B[A-Z])","$1").Replace("_","").ToUpper();
text.text=t+""+(pick+1)+"/"+group.Length;
publicUI_GroupButton(Vector2offset,ColorcolorOn,Groupgroup):base(colorOn,"",offset)
this.group=group;
UpdateText();
publicoverridevoidSetActive(boolactive,boolfireAction=true)
image.color=active?colorOn:colorOff;
text.color=active?Color.black:Color.white;
if(active)
if(fireAction)
Creator.SetElementType(group.Get(pick));
for(inti=0;i<allButtons.Count;i++)
if(allButtons[i]!=this)
allButtons[i].SetActive(false,false);
protectedoverrideboolPointingAtMe(boolclick)
if(visible&&UI_Manager.ImPointedAt(gameObject))
if(click)
SetActive(true);
else
scroll+=Controll.ScrollWheelDelta*1000;
if(Mathf.Abs(scroll)>=1)
pick=(pick+(int)Mathf.Sign(scroll)).Repeat(group.Length);
UpdateText();
Creator.SetElementType(group.Get(pick));
scroll=0;
returntrue;
returnfalse;
protectedoverrideboolCheckNameMatch(stringname)
for(inti=0;i<group.Length;i++)
if(group.Get(i).ToString().Contains(name))
pick=i;
UpdateText();
SetActive(true,false);
returntrue;
returnfalse;
[Serializable]
publicclassUI_LinkButton:UI_Button
privateintpick;
privatefloatscroll;
privatestaticreadonlylinkType[]validLinks={linkType.Jump,linkType.Path,linkType.Action,linkType.Look};
privateboolactive;
publicUI_LinkButton(ColorcolorOn,stringname,Vector2offset):base(colorOn,name,offset)
UpdateText();
privatevoidUpdateText()
text.text=active?validLinks[pick].ToString().ToUpper()+""+(pick+1)+"/"+validLinks.Length:"EDITLINKS";
LinkEdit.linkType=validLinks[pick];
image.color=active?validLinks[pick].Color().Multi(.75f):colorOff;
text.color=active?Color.black:Color.white;
publicoverridevoidSetActive(boolactive,boolfireAction=true)
if(fireAction)
this.active=active;
LinkEdit.LinkMode=active;
UpdateText();
publicvoidNextPick()
pick=(pick+(int)Mathf.Sign(scroll)).Repeat(validLinks.Length);
UpdateText();
protectedoverrideboolPointingAtMe(boolclick)
if(UI_Manager.ImPointedAt(gameObject))
if(click)
SetActive(!active);
else
if(active)
scroll+=Controll.ScrollWheelDelta*1000;
if(Mathf.Abs(scroll)>=1)
NextPick();
scroll=0;
returntrue;
returnfalse;
protectedoverrideboolCheckNameMatch(stringname)
returnfalse;
[Serializable]
publicabstractclassUI_Button
protectedreadonlystringname;
protectedreadonlyTextMeshProUGUItext;
protectedreadonlyImageimage;
protectedreadonlyColorcolorOn,colorOff;
privatestaticGameObjectprefab;
privatestaticTransformparent;
protectedreadonlyGameObjectgameObject;
protectedboolvisible=true;
protectedUI_Button(ColorcolorOn,stringname,Vector2offset)
this.name=name;
if(prefab==null)
prefab=Resources.Load("UI/Assets/Button")asGameObject;
if(parent==null)
parent=Inst.parent;
gameObject=Instantiate(prefab,parent,false).SetName(name).SetScale(1,1,1);
this.colorOn=colorOn;
colorOff=colorOn.Multi(.75f);
text=gameObject.transform.GetChild(0).GetComponent<TextMeshProUGUI>();
image=gameObject.GetComponent<Image>();
Vector2size=image.rectTransform.sizeDelta;
constfloatgap=5;
Vector2pos=newVector2(gap+(size.x+gap)*(offset.x-(columns-1)*.5f),
-gap+(size.y+gap)*-offset.y);
gameObject.GetComponent<RectTransform>().anchoredPosition=pos;
image.color=colorOff;
text.color=Color.white;
text.alignment=TextAlignmentOptions.Midline;
allButtons.Add(this);
protectedstaticreadonlyList<UI_Button>allButtons=newList<UI_Button>();
publicabstractvoidSetActive(boolactive,boolfireAction=true);
publicvoidShow(boolvisible)
this.visible=visible;
image.enabled=visible;
text.enabled=visible;
publicvirtualvoidStayActive(boolstayActive){}
protectedabstractboolPointingAtMe(boolclick);
protectedabstractboolCheckNameMatch(stringname);
publicstaticboolPointedAt(boolclick)
for(inti=0;i<allButtons.Count;i++)
if(allButtons[i].PointingAtMe(click))
returntrue;
returnfalse;
publicstaticvoidSetSelectedName(stringname)
for(inti=0;i<allButtons.Count;i++)
if(allButtons[i].CheckNameMatch(name))
return;
publicvoidShow(boolshow)
gameObject.SetActive(show);
publicclassUI_ElementInfo:MonoBehaviour
publicGameObjectelementInfo;
privateTextMeshProUGUIelementInfoText;
privateImageelementInfoImage;
privateColorinfoA,infoB;
privatestaticElementhighlight;
privatevoidOnEnable()
elementInfoText=elementInfo.GetComponentInChildren<TextMeshProUGUI>();
elementInfoImage=elementInfo.GetComponentInChildren<Image>();
infoA=elementInfoImage.color;
infoB=COLOR.purple.orchid;
privatevoidLateUpdate()
if(ElementEdit.element!=null)
elementInfoImage.color=infoB;
elementInfoText.text=ElementEdit.element.GetInfo();
elementInfoImage.rectTransform.sizeDelta=newVector2(elementInfoText.preferredWidth+20,elementInfoText.preferredHeight+20);
return;
if(highlight!=LevelCheck.ClosestElement||elementInfoImage.color!=infoA)
highlight=LevelCheck.ClosestElement;
elementInfo.SetActive(highlight!=null);
if(highlight!=null)
elementInfoImage.color=infoA;
elementInfoText.text=highlight.GetInfo();
elementInfoImage.rectTransform.sizeDelta=newVector2(elementInfoText.preferredWidth+20,elementInfoText.preferredHeight+20);
publicclassUI_LevelList:Singleton<UI_Creator>,IamUI
publicconststringNewLevel="NEW!";
publicstaticLevelListlevelList;
privatestaticreadonlyList<GameObject>loadButtons=newList<GameObject>(20);
publicGameObjectreferenceButton;
privatevoidOnEnable()
levelList=LevelSaveLoad.LevelList;
if(levelList.levels.Count==0)
LevelSaveLoad.CurrentLevel=NewLevel;
return;
loadButtons.Clear();
referenceButton.SetActive(true);
floatyOffset=100f*.5f*
(levelList.levels.Count+(GameManager.Mode==Mode.Creator?1:0));
for(inti=0;i<levelList.levels.Count;i++)
if(levelList.levels[i]==null)
continue;
GameObjectnewButton=Instantiate(referenceButton,transform,false);
newButton.name=newButton.transform.GetChild(0).GetComponent<TextMeshProUGUI>().text=levelList.levels[i].name;
newButton.GetComponent<RectTransform>().anchoredPosition=Vector2.up*(yOffset-i*100);
loadButtons.Add(newButton);
if(GameManager.Mode==Mode.Creator)
GameObjectnewButton=Instantiate(referenceButton,transform,false);
newButton.GetComponent<Image>().color=COLOR.red.tomato;
newButton.name=newButton.transform.GetChild(0).GetComponent<TextMeshProUGUI>().text=NewLevel;
newButton.GetComponent<RectTransform>().anchoredPosition=Vector2.up*(yOffset-levelList.levels.Count*100);
loadButtons.Add(newButton);
referenceButton.SetActive(false);
publicboolHitUI(boolclick)
for(inti=0;i<loadButtons.Count;i++)
if(UI_Manager.ImPointedAt(loadButtons[i]))
if(click)
LevelSaveLoad.CurrentLevel=loadButtons[i].name;
returntrue;
returnfalse;
publicvoidShow(boolshow)
gameObject.SetActive(show);
publicstaticclassUI_Manager
privatestaticGameObjectclock_Canvas;
publicstaticGameObjectShow_Clock(boolactive)
if(active)
clock_Canvas="Debug/Clock_Canvas".ResourceInst(SceneLocator.UI);
returnclock_Canvas;
if(clock_Canvas!=null)
Object.Destroy(clock_Canvas);
returnnull;
privatestaticGameObjectspinup_Canvas;
privatestaticbool_showSpinUp
set
if(value)
spinup_Canvas="UI/SpinUp_Canvas".ResourceInst(SceneLocator.UI);
activeUI.Add(spinup_Canvas.GetComponent<IamUI>());
else
if(spinup_Canvas!=null)
activeUI.Remove(spinup_Canvas.GetComponent<IamUI>());
Object.Destroy(spinup_Canvas);
publicstaticvoidShow_SpinUp_UI()
Fade.Transition(v=>_showSpinUp=v,v=>_showMainMenu=v);
privatestaticGameObjectcreator_Canvas;
privatestaticbool_showCreator
set
if(value)
creator_Canvas="UI/Creator_Canvas".ResourceInst(SceneLocator.UI);
activeUI.Add(creator_Canvas.GetComponent<IamUI>());
else
if(creator_Canvas!=null)
activeUI.Remove(creator_Canvas.GetComponent<IamUI>());
Object.Destroy(creator_Canvas);
publicstaticvoidShow_Edit_UI()
Fade.Transition(v=>_showCreator=v,v=>_showMainMenu=v);
privatestaticGameObjectmainmenu_Canvas;
privatestaticbool_showMainMenu
set
if(value)
mainmenu_Canvas=Object.Instantiate(Resources.Load("UI/MainMenu_Canvas")asGameObject,SceneLocator.UI,true);
else
if(spinup_Canvas!=null)
Object.Destroy(mainmenu_Canvas);
publicstaticvoidShow_MainMenu_UI()
Fade.Transition(v=>_showMainMenu=v,v=>_showFrame=v);
privatestaticGameObjectlevelList_Canvas;
privatestaticbool_showLevelList;
privatestaticboolShowLevelList
set
if(value)
levelList_Canvas="UI/LevelList_Canvas".ResourceInst(SceneLocator.UI);
activeUI.Add(levelList_Canvas.GetComponent<IamUI>());
else
activeUI.Remove(levelList_Canvas.GetComponent<IamUI>());
if(levelList_Canvas!=null)
Object.Destroy(levelList_Canvas);
_showLevelList=value;
get{return_showLevelList;}
publicstaticvoidShow_LevelList(boolshow)
ShowLevelList=show;
privatestaticGameObjectframe_Canvas;
privatestaticbool_showFrame;
[Switch("UI/Frame")]
privatestaticboolshowFrame
set
if(value)
frame_Canvas=Object.Instantiate(Resources.Load("Debug/Frame_Canvas")asGameObject,SceneLocator.UI,true);
else
if(frame_Canvas!=null)
Object.Destroy(frame_Canvas);
_showFrame=value;
get{return_showFrame;}
privatestaticGameObjectpoolDebug_Canvas;
privatestaticbool_showPoolDebug;
[Switch("Info/Pools")]
privatestaticboolshowPoolDebug
set
if(value)
poolDebug_Canvas=Object.Instantiate(Resources.Load("Debug/PoolDebug_Canvas")asGameObject,SceneLocator.UI,true);
else
if(poolDebug_Canvas!=null)
Object.Destroy(poolDebug_Canvas);
_showPoolDebug=value;
get{return_showPoolDebug;}
privatestaticGameObjectactorDebug_Canvas;
privatestaticbool_showActorDebug;
[Switch("Info/ActorInstances")]
privatestaticboolshowActorDebug
set
if(value)
actorDebug_Canvas=Object.Instantiate(Resources.Load("Debug/ActorDebug_Canvas")asGameObject,SceneLocator.UI,true);
else
if(actorDebug_Canvas!=null)
Object.Destroy(actorDebug_Canvas);
_showActorDebug=value;
get{return_showActorDebug;}
publicstaticboolHitUI;
privatestaticreadonlyList<RaycastResult>Hits;
publicstaticreadonlyList<IamUI>activeUI;
staticUI_Manager()
Hits=newList<RaycastResult>(100);
activeUI=newList<IamUI>(10);
privatestaticEventSystemsystem;
privatestaticPointerEventDatapointer;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
privatestaticvoidGetSystem()
system=EventSystem.current;
pointer=newPointerEventData(system);
publicstaticvoidCheckUI()
HitUI=false;
Hits.Clear();
pointer.position=Input.mousePosition;
system.RaycastAll(pointer,Hits);
boolclick=Input.GetMouseButtonDown(0);
intcount=activeUI.Count;
for(inti=0;i<count;i++)
if(activeUI[i].HitUI(click))
HitUI=true;
break;
publicstaticboolImPointedAt(GameObjectgameObject)
for(inti=0;i<Hits.Count;i++)
if(Hits[i].gameObject==gameObject)
returntrue;
returnfalse;
publicstaticvoidShow(boolshow)
for(inti=0;i<activeUI.Count;i++)
activeUI[i].Show(show);
publicinterfaceIamUI
boolHitUI(boolclick);
voidShow(boolshow);
publicclassUI_SpinUp:Singleton<UI_SpinUp>,IamUI{
publicGameObject[]buttons;
[Space(10)]
publicTimeSliderUIslider;
publicTextMeshProUGUIpauseButtonText;
publicboolHitUI(boolclick)
for(inte=0;e<buttons.Length;e++)
if(UI_Manager.ImPointedAt(buttons[e]))
if(click)
ButtonPress(buttons[e].name);
returntrue;
returnfalse;
privatevoidButtonPress(stringbuttonName)
if(!Input.GetMouseButtonDown(0))
return;
switch(buttonName)
case"PauseButton":
if(!GTime.Paused)
GTime.Pause();
else
GTime.UnPause();
pauseButtonText.text=GTime.Paused?"#":"II";
break;
case"HandleCast":
slider.GrabbingHandle();
break;
case"PlayButton":
TimeSliderUI.PlayButtonPress();
break;
publicvoidShow(boolshow)
gameObject.SetActive(show);
[CanEditMultipleObjects,CustomEditor(typeof(NonDrawingGraphic),false)]
publicclassNonDrawingGraphicEditor:GraphicEditor
publicoverridevoidOnInspectorGUI()
serializedObject.Update();
EditorGUILayout.PropertyField(m_Script);
RaycastControlsGUI();
serializedObject.ApplyModifiedProperties();
publicclassBoolSwitchKeyToggle:MonoBehaviour
privatevoidUpdate()
switch(KeyMap.GetDownKey)
caseKeyCode.T:
BoolSwitch.ToggleValue("Anim/TurnTest");
break;
caseKeyCode.R:
BoolSwitch.ToggleValue("Anim/WiggleTest");
break;
caseKeyCode.V:
BoolSwitch.ToggleValue("Dev/ReplayDir");
break;
caseKeyCode.Equals:
BoolSwitch.ToggleValue("Visuals/Wireframe");
break;
caseKeyCode.RightBracket:
BoolSwitch.ToggleValue("Visuals/ShadowTest");
break;
caseKeyCode.Insert:
BoolSwitch.ToggleValue("Dev/Keycodes");
break;
caseKeyCode.F9:
BoolSwitch.ToggleValue("Jump/JumpLines");
BoolSwitch.ToggleValue("Jump/ConnectionShapes");
BoolSwitch.ToggleValue("Jump/Zappy");
break;
caseKeyCode.F10:
BoolSwitch.ToggleValue("Elements/Tracks");
BoolSwitch.ToggleValue("Elements/StartStick");
BoolSwitch.ToggleValue("Elements/Links");
break;
caseKeyCode.F11:
BoolSwitch.ToggleValue("Bounds/Cells");
BoolSwitch.ToggleValue("Bounds/Elements");
BoolSwitch.ToggleValue("Bounds/Player");
BoolSwitch.ToggleValue("Jump/Bounds");
break;
publicclassBoolSwitchToggle:MonoBehaviour,IamUI
publicstringvalueName;
publicboolonMobile;
privateImageimage;
privateColorcolor;
privateGameObjectchild;
privatevoidAwake()
image=GetComponent<Image>();
color=image.color;
image.color=Color.Lerp(Color.black,color,BoolSwitch.GetValue(valueName)?1:.5f);
child=transform.GetChild(0).gameObject;
privatevoidOnEnable()
if(Application.isMobilePlatform&&!onMobile)
gameObject.SetActive(false);
return;
UI_Manager.activeUI.Add(this);
publicboolHitUI(boolclick)
if(UI_Manager.ImPointedAt(child))
if(click)
BoolSwitch.ToggleValue(valueName);
image.color=Color.Lerp(Color.black,color,BoolSwitch.GetValue(valueName)?1:.5f);
returntrue;
returnfalse;
publicvoidShow(boolshow)
gameObject.SetActive(show);
publicstaticclassByteStream
publicstaticreadonlyMemoryStreamstream=newMemoryStream(newbyte[102400]);
publicstaticreadonlyBinaryReaderreader=newBinaryReader(stream);
publicstaticreadonlyBinaryWriterwriter=newBinaryWriter(stream);
publicstaticvoidSet(byte[]bytes,intstart,intend)
stream.SetLength(0);
intlength=end-start;
for(inti=0;i<length;i++)
writer.Write(bytes[i+start]);
publicstaticvoidSet(byte[]bytes,intlength)
stream.SetLength(0);
for(inti=0;i<length;i++)
writer.Write(bytes[i]);
stream.Position=0;
publicstaticvoidSet(byte[]bytes)
stream.SetLength(0);
writer.Write(bytes);
stream.Position=0;
publicclassCellLineTest:MonoBehaviour
publicTransformp1,p2;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
Vector3pos1=p1.position,
pos2=p2.position;
DRAW.Vector(pos1,pos2-pos1).SetColor(Color.white).SetDepth(Z.P);
intcount;
Vector2Int[]cells=SuperCover.GetLineCells(pos1/Level.CellSize,pos2/Level.CellSize,outcount);
for(inti=0;i<count;i++)
DRAW.Rectangle(cells[i]*Level.CellSize+Vector2.one*Level.CellHalfSize,Vector2.one*Level.CellHalfSize*1.8f).
SetColor(Color.white).SetDepth(Z.P);
publicclassDebugDrawUpdate:MonoBehaviour
privatestaticbool_draw=true;
privatestaticDebugDrawUpdateInst;
[Switch("Dev/DrawUpdate")]
privatestaticboolDrawAnything
get{return_draw;}
set
_draw=value;
if(_draw&&Inst==null)
Inst=newGameObject("DebugDrawUpdate").AddComponent<DebugDrawUpdate>();
if(!_draw&&Inst!=null)
Destroy(Inst.gameObject);
privatevoidLateUpdate()
SpinnerDebug.DebugUpdate();
LevelDebug.DebugUpdate();
Prediction.ShowPrediction();
publicstaticclassDebugLogToggle
[Switch("Dev/DebugLog")]
publicstaticboolLogsEnabled
get{return_logsEnabled;}
set
Debug.unityLogger.logEnabled=value;
_logsEnabled=value;
privatestaticbool_logsEnabled;
publicclassDebugPulse:MonoBehaviour
privatevoidUpdate()
if(GameManager.Running&&Input.GetKeyDown(KeyCode.P)&&!GTime.Paused)
ActorAnimator.DebugPulse();
publicclassDigitTest:MonoBehaviour
publicfloatvalue;
publicintdivision;
[Space(10)]
publicfloata;
publicfloatb;
[Space(10)]
publicfloatresult;
voidUpdate()
a=Mathf.Floor(value);
b=Mathf.Ceil(value%1f*division);
result=a+b/division;
publicstaticclassZ
publicstaticfloatW{get{returnWall(.00f);}}
publicstaticfloatW05{get{returnWall(.05f);}}
publicstaticfloatW10{get{returnWall(.10f);}}
publicstaticfloatW15{get{returnWall(.15f);}}
publicstaticfloatW20{get{returnWall(.20f);}}
publicstaticfloatW25{get{returnWall(.25f);}}
publicstaticfloatW30{get{returnWall(.30f);}}
publicstaticfloatW35{get{returnWall(.35f);}}
publicstaticfloatW40{get{returnWall(.40f);}}
publicstaticfloatP{get{returnPlane(0);}}
publicstaticfloatP75{get{returnPlane(.75f);}}
privatestaticfloatWall(floatoffset)
return(Level.WallDepth+offset)*GameCam.CurrentSide.Sign;
privatestaticfloatPlane(floatoffset)
return(Level.WallDepth+Level.PlaneOffset+offset)*GameCam.CurrentSide.Sign;
publicpartialclassDRAW
publicstaticfloatWallZ(floatoffset)
return(Level.WallDepth+offset)*GameCam.CurrentSide.Sign;
publicstaticfloatPlaneZ(floatoffset)
return(Level.WallDepth+offset)*GameCam.CurrentSide.Sign;
publicstaticclassDrawHelp
privateconstintshellSteps=12,arcSteps=50;
publicstaticDRAW.ShapeDraw(thisLineline)
returnDRAW.Vector(line.l1,line.dir);
publicstaticDRAW.ShapeDrawTips(thisLineline)
returnDRAW.Circle(line.l1,.075f,20).SetSub(DRAW.Arrow(line.GetL2(),line.dir.normalized*.15f,.2f));
publicstaticDRAW.ShapeDrawShell(thisLineline,floatthickness,booldrawLine=false)
Vector2pointer=line.dir.Rot90().SetLength(thickness);
DRAW.Shapeshape=DRAW.Shape.Get(shellSteps*2+1);
constfloatangle=180f/(shellSteps-1);
for(inti=0;i<shellSteps;i++)
shape.Set(i,line.l1+line.dir+pointer.Rot(180+angle*i));
for(inti=0;i<shellSteps;i++)
shape.Set(i+shellSteps,line.l1+pointer.Rot(angle*i));
shape.Copy(0,shellSteps+shellSteps);
if(drawLine)
shape.SetSub(line.Draw());
returnshape;
publicstaticDRAW.ShapeDraw(thisCirclecircle,intpoints)
returnDRAW.Circle(circle.center,circle.radius,points);
publicstaticDRAW.ShapeDraw(thisArcarc,intpoints)
returnDRAW.Arc(arc.center,arc.radius,arc.bend,arc.angle,points);
publicstaticDRAW.ShapeDrawTips(thisArcarc)
returnDRAW.Circle(arc.LerpPos(0),.075f,20).SetSub(DRAW.Arrow(arc.LerpPos(1),arc.LerpDir(1)*.15f,.2f));
publicstaticDRAW.ShapeDrawShell(thisArcarc,floatthickness,booldrawArc=false)
intpointIndex=0;
DRAW.Shapeshape=DRAW.Shape.Get(shellSteps*2+arcSteps*2+1);
constfloatangleStep=180f/(shellSteps-1);
floatsignedRadius=arc.SignedRadius;
QuaternionrotA=Rot.Z(arc.angle);
Vector2pointer=rotA*Vector2.right.SetLength(thickness);
Vector2p1=arc.center+(rotA*Vector2.up.SetLength(signedRadius)).V2();
floatsign=Mathf.Sign(signedRadius);
for(inti=0;i<shellSteps;i++)
shape.Set(pointIndex++,p1+pointer.Rot(-90+angleStep*i*sign));
floatarcAngleStep=Mathf.Abs(arc.bend)*360/arcSteps;
pointer=Vector2.up.SetLength(signedRadius+thickness);
for(inti=0;i<arcSteps;i++)
shape.Set(pointIndex++,arc.center+(Rot.Z(arc.angle+arcAngleStep*i)*pointer).V2());
QuaternionrotB=Rot.Z(arc.angle+Mathf.Abs(arc.bend)*360);
pointer=rotB*Vector2.right.SetLength(thickness);
Vector2p2=arc.center+(rotB*Vector2.up.SetLength(signedRadius)).V2();
for(inti=0;i<shellSteps;i++)
shape.Set(pointIndex++,p2+pointer.Rot(-270+angleStep*i*sign));
pointer=Vector2.up.SetLength(signedRadius-thickness);
for(inti=0;i<arcSteps;i++)
shape.Set(pointIndex++,arc.center+(Rot.Z(arc.angle+Mathf.Abs(arc.bend)*360-arcAngleStep*i)*pointer).V2());
shape.Copy(0,shellSteps*2+arcSteps*2);
if(drawArc)
shape.SetSub(arc.Draw(100));
returnshape;
publicstaticDRAW.ShapeDraw(thisFlyPathflypath,floatstart,floatend,intsteps=100,boolextra=false)
floatstep=(end-start)/(steps-1);
DRAW.Shapeshape=DRAW.Shape.Get(steps);
for(inti=0;i<steps;i++)
shape.Set(i,flypath.GetPos(start+i*step));
if(extra)
DRAW.Shapeparent=shape;
intmin=Mathf.CeilToInt(start);
intmax=Mathf.CeilToInt(end);
for(inti=min;i<max;i++)
Vector2dir=flypath.GetMV(i).Rot90().normalized;
DRAW.Shapeline=DRAW.Vector(flypath.GetPos(i)-dir*.1f,dir*.2f);
parent.SetSub(line);
parent=line;
DRAW.Shapetip=DRAW.Arrow(flypath.GetPos(end),flypath.GetMV(end).normalized*.2f,.2f);
parent.SetSub(tip);
if(flypath.apexTime>=start&&flypath.apexTime<=end)
tip.SetSub(DRAW.Circle(flypath.GetPos(flypath.apexTime),.1f,20));
returnshape;
publicstaticDRAW.ShapeDraw(thisBounds2Dbounds,floatscale=1)
returnDRAW.Rectangle(bounds.Center,bounds.Size*scale);
publicstaticDRAW.ShapeDrawSubDiv(thisBounds2Dbounds,intxSplits,intySplits,floatscale=1)
Vector2min=bounds.BL,size=bounds.Size;
xSplits++;
ySplits++;
floatxStep=size.x/xSplits,yStep=size.y/ySplits;
size=newVector2(xStep,yStep);
DRAW.Shapeshape=null;
for(inty=0;y<ySplits;y++)
for(intx=0;x<xSplits;x++)
Vector2center=min+newVector2((x+.5f)*xStep,(y+.5f)*yStep);
Sideside=GameCam.CurrentSide;
Bounds2Db=newBounds2D(center-size*.5f).Add(center+size*.5f);
Search.Items(b,side,GTime.Now,Mask.Debug);
boolfoundSomething=Search.itemCount>0;
if(!foundSomething)
Search.Tracks(b,side);
for(inti=0;i<Search.trackCount;i++)
if(Search.boundTracks[i].AnyItemMatchesMask(Mask.Debug))
foundSomething=true;
break;
if(foundSomething)
shape=DRAW.Rectangle(center,size*scale).SetSub(shape);
returnshape??DRAW.NullShape;
publicclassEditorCamControll:Singleton<EditorCamControll>
privateboolfollow
get{returnPlayerPrefs.GetInt("EditorCamControll")==1;}
set{PlayerPrefs.SetInt("EditorCamControll",value?1:0);}
privatestaticEditorWindowgameView;
privatevoidStart()
gameView=EditorWindow.focusedWindow;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.LeftBracket))
follow=!follow;
if(!follow||EditorWindow.focusedWindow!=gameView)
return;
UpdateEditorCamPos();
privatevoidUpdateEditorCamPos()
if(SceneView.lastActiveSceneView!=null&&GameCam.Cam!=null)
Transformcam=GameCam.Cam.transform;
Rayray=newRay(cam.position,cam.forward);
floatdist;
newPlane(Vector3.forward,Vector3.zero).Raycast(ray,outdist);
Vector3hitPoint=ray.origin+ray.direction*dist;
SceneView.lastActiveSceneView.orthographic=true;
SceneView.lastActiveSceneView.LookAtDirect(hitPoint,cam.rotation);
publicstaticvoidSetEditorFocus()
Inst.StartCoroutine(Inst.UpdateAnyway());
privateIEnumeratorUpdateAnyway()
while(EditorWindow.focusedWindow!=gameView)
yieldreturnnull;
UpdateEditorCamPos();
publicclassEditorCoroutine
publicstaticEditorCoroutinestart(IEnumerator_routine)
EditorCoroutinecoroutine=newEditorCoroutine(_routine);
coroutine.start();
returncoroutine;
privatereadonlyIEnumeratorroutine;
privateEditorCoroutine(IEnumerator_routine)
routine=_routine;
privatevoidstart()
EditorApplication.update+=update;
publicvoidstop()
EditorApplication.update-=update;
privatevoidupdate()
/*NOTE:noneedtotry/catchMoveNext,
*ifanIEnumeratorthrowsitsnextiterationreturnsfalse.
*Also,UnityprobablycatcheswhencallingEditorApplication.update.
*/
if(!routine.MoveNext())
stop();
publicclassFocusSpinnerDebug:MonoBehaviour
publicTexttext;
privatevoidLateUpdate()
if(!GameManager.Running)
return;
Spinnerspinner=Spinner.CurrentFocusClip!=null?Spinner.CurrentFocusClip.spinner:null;
text.text=spinner!=null?spinner.ID+""+spinner.name:"NONE";
publicclassFrame:MonoBehaviour{
publicRectTransform[]horizontalLines;
publicRectTransform[]verticalLines;
privatevoidOnEnable()
ScreenControll.onOrientationChange+=Update_3Split;
Update_3Split();
privatevoidOnDisable()
ScreenControll.onOrientationChange-=Update_3Split;
privatevoidUpdate_3Split()
floatwidth=ScreenControll.Width;
floatheight=ScreenControll.Height;
horizontalLines[0].anchoredPosition=newVector2(0,height/3f);
horizontalLines[1].anchoredPosition=newVector2(0,height/3f*2);
verticalLines[0].anchoredPosition=newVector2(width/3f,0);
verticalLines[1].anchoredPosition=newVector2(width/3f*2,0);
publicclassMaskCheck:MonoBehaviour
publicboolmain,contact,occlusion,floor;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
bytebyteValue=((byte)0).Set(main,contact,occlusion,floor);
floatfloatValue=byteValue/255f;
Debug.Log(floatValue);
publicclassPaletteDebug:MonoBehaviour,IamUI
privateImageimage;
privateColorcolor;
privateGameObjectchild;
publicboolfullTex;
privatevoidAwake()
image=GetComponent<Image>();
color=image.color;
image.color=Color.Lerp(Color.black,color,fullTex?1:.5f);
child=transform.GetChild(0).gameObject;
privatevoidOnEnable()
UI_Manager.activeUI.Add(this);
publicboolHitUI(boolclick)
if(UI_Manager.ImPointedAt(child))
if(click)
fullTex=!fullTex;
image.color=Color.Lerp(Color.black,color,fullTex?1:.5f);
Palette.Load(fullTex);
returntrue;
returnfalse;
publicvoidShow(boolshow)
gameObject.SetActive(show);
publicclassPoseUI:MonoBehaviour
publicTextMeshProUGUItext;
publicRectTransformbg;
privatereadonlyStringBuilderwriter=newStringBuilder(1000);
privateboolvisible;
privatestring[]names;
privatevoidAwake()
if(Application.isMobilePlatform)
gameObject.SetActive(false);
return;
List<string>nameList=newList<string>();
Typetype=typeof(Anim.Pose);
FieldInfo[]fieldInfos=type.GetFields(BindingFlags.Public|BindingFlags.Static);
intlongest=0;
for(inti=0;i<fieldInfos.Length;i++)
stringfieldName=fieldInfos[i].Name;
nameList.Add(fieldName);
longest=Mathf.Max(longest,fieldName.Length+1);
for(inti=0;i<fieldInfos.Length;i++)
nameList[i]=nameList[i].PadRight(longest);
names=nameList.ToArray();
privatevoidLateUpdate()
if(!GameManager.Running)
return;
if(Input.GetKeyDown(KeyCode.I))
visible=!visible;
text.gameObject.SetActive(visible);
bg.gameObject.SetActive(visible);
if(visible)
Spinnerspinner=Spinner.Get(0);
spinner.rig.poser.currentPose.GetInfo(writer,names);
/*if(spinner.currentClip!=null&&spinner.currentClip.Type.IsAnySwing())
writer.Append("\nSpin:").Append(((Swing)spinner.currentClip).GetActualSpeed(GTime.Now).ToString("F4"));*/
text.text=writer.ToString();
constfloatmargin=5;
bg.sizeDelta=newVector2(text.preferredWidth+margin*2,text.preferredHeight+margin*2);
bg.anchoredPosition=newVector2(-margin,-margin);
publicclassPrintColorValue:MonoBehaviour
privatevoidStart()
Meshmesh=GetComponent<MeshFilter>().mesh;
Colorcolor=mesh.colors[0];
Debug.Log(color.b);
publicclassQualitySwitches:MonoBehaviour,IamUI
publicenumMethod{Quality,SkinnedMeshes,Backgrounds}
[Serializable]
publicclassButton
publicGameObjectgameObject;
publicboolvalue;
publicMethodmethod;
privateImageimage;
privateColorcolor;
privateGameObjectbttn;
publicvoidSetup()
bttn=gameObject.transform.GetChild(0).gameObject;
image=gameObject.GetComponent<Image>();
color=image.color;
image.color=Color.Lerp(Color.black,color,value?1:.5f);
publicboolPress(boolclick)
if(UI_Manager.ImPointedAt(bttn))
if(click)
value=!value;
image.color=Color.Lerp(Color.black,color,value?1:.5f);
switch(method)
caseMethod.Quality:
QualitySettings.vSyncCount=value?1:2;
break;
caseMethod.SkinnedMeshes:
Spinner.ToggleSkins(value);
break;
caseMethod.Backgrounds:
EdgeMaster.SetActive(value);
break;
returntrue;
returnfalse;
publicButton[]buttons;
privatevoidAwake()
UI_Manager.activeUI.Add(this);
for(inti=0;i<buttons.Length;i++)
buttons[i].Setup();
publicboolHitUI(boolclick)
for(inti=0;i<buttons.Length;i++)
if(buttons[i].Press(click))
returntrue;
returnfalse;
publicvoidShow(boolshow)
gameObject.SetActive(show);
publicclassScreeny:MonoBehaviour
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.F12))
stringpath=Environment.GetFolderPath(Environment.SpecialFolder.Desktop).Replace("\\","/")+"/"+
SceneManager.GetActiveScene().name+"_"+
DateTime.Now.ToShortDateString().Replace("/",".")+
"."+DateTime.Now.Hour+"."+DateTime.Now.Minute+"."+DateTime.Now.Second+
".png";
ScreenCapture.CaptureScreenshot(path);
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
publicstaticvoidRegister()
if(!Application.isMobilePlatform)
SceneManager.sceneLoaded+=PutInScene;
privatestaticvoidPutInScene(Scenescene,LoadSceneModemode)
newGameObject().AddComponent<Screeny>();
publicclassShowClips:MonoBehaviour
publicVector2xRange,yRange;
publicfloatmargin;
privatevoidOnValidate()
xRange=xRange.RangeChecked(0,1);
yRange=yRange.RangeChecked(0,1);
margin=Mathf.Clamp01(margin);
privatevoidLateUpdate()
if(!GameManager.Running)
return;
floatxMin=Screen.width*xRange.x;
floatxMax=Screen.width*xRange.y;
floatyMin=Screen.height*yRange.x;
floatyMax=Screen.height*yRange.y;
floatheight=yMax-yMin;
floatpad=Mathf.Min(Screen.width*margin,Screen.height*margin);
floatrewindTime=GTime.Now-GTime.RewindTime*2f;
floatfutureTime=GTime.Now+GTime.RewindTime*2f;
DrawRectangle(xMin-pad,xMax+pad,yMin-pad,yMax+pad,Color.black.A(0),.2f);
DrawRectangle(xMin-pad,xMax+pad,yMax+pad+pad,yMax+pad+pad+height*.25f,Color.black.A(0),.2f);
intcount=Spinner.active.Count;
for(inti=0;i<count;i++)
Clipclip=Spinner.active[i].GetClip(GTime.Now);
if(clip!=null)
while(true)
Clipbefore=clip.before;
if(before!=null&&before.startTime>=rewindTime)
clip=before;
else
break;
Clipbefore=clip.before;
if(before!=null)
clip=before;
while(true)
if(clip==null||clip.startTime>futureTime)
break;
if(clip.Type==0)
break;
Clipafter=clip.after;
floatstart=clip.startTime;
floatend=after!=null?after.startTime:f.Same(clip.duration,0)?Mathf.Max(GTime.Now,clip.startTime+.25f):start+clip.duration;
Colorc=clip.Type.Color();
floatclipMin=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,start));
floatclipMax=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,end));
constfloatyOffset=.25f;
boolactiveNow=start<=GTime.Now&&end>=GTime.Now;
DrawRectangle(
clipMin,
clipMax,
yMin+height*yOffset*(i),
yMin+height*(.2f+yOffset*(i)),
c.A(activeNow?1:0),.55f);
clip=after;
if(!f.Same(Boundary.meetStart,float.MaxValue))
floatintersectMin=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,Boundary.meetStart));
floatintersectMax=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,Boundary.meetEnd));
DrawRectangle(intersectMin,intersectMax,yMin+height*.5f,yMin+height*.6f,Color.red.A(0));
DRAW.Vector(newVector3((xMin+xMax)*.5f,yMin,0),V3.up*(yMax-yMin)).ToScreen();
DRAW.Vector(newVector3(Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,GTime.Now-GTime.RewindTime)),yMin,0),V3.up*(yMax-yMin)).SetColor(Color.white.A(.5f)).ToScreen();
DRAW.Vector(newVector3(Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,GTime.Now+GTime.RewindTime)),yMin,0),V3.up*(yMax-yMin)).SetColor(Color.white.A(.5f)).ToScreen();
floatindicator=Mathf.Ceil(rewindTime);
while(indicator<futureTime)
if(indicator>=0)
floatx=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,indicator));
DRAW.Vector(newVector3(x,yMin+height*.5f,0),V3.up*(height*.5f+pad)).SetColor(Color.white.A(.75f)).ToScreen();
DRAW.Text(indicator.RoundString(),newVector3(x,yMin+height+pad+pad+height*.125f),Color.white,1.5f,screenSpace:true);
indicator++;
for(inti=0;i<2;i++)
Boundary.SpinnerBoundarybounds=Boundary.Inst.boundarys[i];
for(inte=0;e<bounds.cBounds.Count;e++)
floatstart=bounds.cBounds[e].startTime;
floatbMin=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,start));
floatyOffset=i==1?0:.25f;
DRAW.Circle(newVector3(bMin,yMin+height*(.1f+yOffset)),.035f*height,16).ToScreen().Fill(.8f,true);
if(e==bounds.cBounds.Count-1)
floatend=bounds.cBounds[e].endTime;
floatbMax=Mathf.Lerp(xMin,xMax,Mathf.InverseLerp(rewindTime,futureTime,end));
DRAW.Circle(newVector3(bMax,yMin+height*(.1f+yOffset)),.035f*height,16).ToScreen().Fill(.8f,true);
privatestaticvoidDrawRectangle(floatclipMin,floatclipMax,floatbottom,floattop,Colorcolor,floatalpha=.4f)
DRAW.Rectangle(newVector3((clipMin+clipMax)*.5f,(top+bottom)*.5f),newVector2(clipMax-clipMin,bottom-top)).
SetColor(color).Fill(alpha).ToScreen();
publicstaticclassclipExt
publicstaticColorColor(thisClipTypeclipType)
switch(clipType)
default:returnCOLOR.orange.coral;
caseClipType.Swing:returnCOLOR.blue.cornflower;
caseClipType.Spawn:returnCOLOR.grey.light;
caseClipType.Bump:returnCOLOR.purple.maroon;
caseClipType.Dead:returnCOLOR.grey.dark;
publicclassSpinnerIndicator:MonoBehaviour
[Switch("Char/Indicator")]
publicstaticboolIndication;
privatevoidLateUpdate()
if(!GameManager.Running||!Indication)
return;
intactiveCount=Spinner.active.Count;
for(inti=0;i<activeCount;i++)
Spinnerspinner=Spinner.active[i];
Clipclip=spinner.currentClip;
if(clip==null||clip.Type.IsNotPlaying())
continue;
boolsameSide=clip.GetSide(GTime.Now)==GameCam.CurrentSide;
Colorcolor=sameSide?Color.white:Color.gray;
Vector2screenPos=GameCam.Cam.WorldToScreenPoint(spinner.currentPlacement.pos);
boolonScreen=OnScreen(screenPos);
if(sameSide&&onScreen)
continue;
if(!onScreen)
Vector2center=newVector2(ScreenControll.Width*.5f,ScreenControll.Height*.5f);
LinedirLine=newLine(center,screenPos);
Vector2point;
if(newLine(A,B).Contact(dirLine,outpoint)||
newLine(B,C).Contact(dirLine,outpoint)||
newLine(C,D).Contact(dirLine,outpoint)||
newLine(D,A).Contact(dirLine,outpoint))
screenPos=point;
DRAW.Circle(screenPos,IndicatorRadius*.95f,20).SetColor(Color.black).ToScreen().Fill(.5f,true);
DRAW.MultiCircle(screenPos,IndicatorRadius,3,IndicatorRadius*.025f,20).SetColor(clip.Type.Color()).ToScreen();
DRAW.Text(i.PrepString(),screenPos,color,IndicatorRadius*.2f,screenSpace:true);
privatestaticfloatIndicatorRadius
get{return(ScreenControll.Landscape?ScreenControll.Width:ScreenControll.Height)*.0125f;}
privatestaticboolOnScreen(Vector2screenPos)
returnscreenPos.x>=IndicatorRadius&&screenPos.x<ScreenControll.Width-IndicatorRadius&&screenPos.y>=IndicatorRadius&&screenPos.y<ScreenControll.Height-IndicatorRadius;
privatestaticVector2A{get{returnnewVector2(IndicatorRadius,IndicatorRadius);}}
privatestaticVector2B{get{returnnewVector2(IndicatorRadius,ScreenControll.Height-IndicatorRadius);}}
privatestaticVector2C{get{returnnewVector2(ScreenControll.Width-IndicatorRadius,ScreenControll.Height-IndicatorRadius);}}
privatestaticVector2D{get{returnnewVector2(ScreenControll.Width-IndicatorRadius,IndicatorRadius);}}
publicstaticclassStaticConstructor
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
privatestaticvoidInitStaticClasses()
Type[]initTypes=
typeof(KeyMap),//
typeof(ElementMask),
typeof(Level),//
typeof(Search),//
typeof(LevelSaveLoad),//
typeof(LevelElements.Element),
typeof(LevelElements.Item),
typeof(LevelElements.Track),//
typeof(Generation.Cell),//
typeof(GPhysics),
typeof(GeoMath.Bounds2D),//
typeof(GeoMath.Circle),
typeof(GeoMath.Line),
typeof(GeoMath.Quad),
typeof(GeoMath.Rectangle),
typeof(GeoMath.ShapeCollision),
typeof(GeoMath.Tri),
typeof(Tape),
typeof(Clips.Clip),
typeof(Clips.AirLaunch),
typeof(Clips.Bump),
typeof(Clips.Dead),
typeof(Clips.Jump),
typeof(Clips.None),
typeof(Clips.Spawn),
typeof(Clips.Swing),
typeof(Anim.SpinnerAnim),//
typeof(Anim.Anim_Jump),//
typeof(Anim.Anim_Swing),//
typeof(Anim.AnimLerp),//
typeof(ActorAnimation.ActorAnim),//
typeof(ActorAnimator.ActorList),//
typeof(ActorAnimation.Shake),//
typeof(Future.Prediction),//
typeof(Future.PathSlice),//
typeof(JumpInfo),//
typeof(Spinner),//
typeof(ScoreStick),//
typeof(Spinner.Squash),//
typeof(SquashAnim),//
typeof(Score),//
typeof(Controll),
typeof(UI_Manager),
typeof(SpinnerDebug),
typeof(Boundary),//
typeof(Rot),
typeof(DRAW),
typeof(DRAW.ReusableMesh),
typeof(DRAW.Shape),
typeof(SetVolume),//
typeof(Audio),
typeof(Audio.Ambient),//
typeof(Audio.Music),//
typeof(Audio.Reaction),//
typeof(Audio.Sound),//
typeof(Audio.UI),//
typeof(Mixer),//
typeof(Encryption)//
for(inti=0;i<initTypes.Length;i++)
RuntimeHelpers.RunClassConstructor(initTypes[i].TypeHandle);
publicclassStringDisplay:MonoBehaviour
publicText[]texts;
publicvoidSetTexts(string[]strings)
for(inti=0;i<texts.Length;i++)
texts[i].text=i<strings.Length?strings[i]:"";
publicstaticclassTimer
publicenumEntry
CreateRects,
DetectOccupiedCells,
Piecer,
Occlusion,
MakePillars,
TellLevelAboutOcclusion,
FindUsedCells
privatestaticreadonlyfloat[]times;
privatestaticreadonlyStringBuilderbuilder;
publicstaticvoidStart(Entryentry)
times[(int)entry]=Time.realtimeSinceStartup;
publicstaticvoidEnd(Entryentry)
times[(int)entry]=Time.realtimeSinceStartup-times[(int)entry];
publicstaticfloatGet(Entryentry)
returntimes[(int)entry];
publicstaticstringLog(Entryentry)
builder.Length=0;
returnbuilder.Append(entry.ToString()).Append(":").Append(times[(int)entry]).Append("|").ToString();
publicstaticstringLog(Entryentry,reffloatadd)
builder.Length=0;
floatvalue=times[(int)entry];
add+=value;
returnbuilder.Append(value.ToString("F4")).Append(":").Append(entry.ToString()).ToString();
staticTimer()
builder=newStringBuilder(100);
times=newfloat[Enum.GetValues(typeof(Entry)).Length];
publicclassAppControllWindow:EditorWindow
privatestaticAppControllWindowwindow;
[MenuItem("Window/AppControll")]
privatestaticvoidOpenWindow()
window=GetWindow(typeof(AppControllWindow),false,"AppControll")asAppControllWindow;
window.minSize=newVector2(260,25);
privatevoidOnGUI()
EditorGUILayout.BeginHorizontal();
string[]names=Enum.GetNames(typeof(Mode));
intselection=(int)GameManager.SavedMode;
for(inti=1;i<names.Length;i++)
GUI.color=i==selection?
Color.Lerp(COLOR.yellow.fresh,COLOR.green.lime,(float)(i-1)/(names.Length-2)):
Color.white;
if(GUILayout.Button(names[i],GUILayout.Width(80),GUILayout.Height(20)))
GameManager.SavedMode=(Mode)i;
GUILayout.FlexibleSpace();
GUI.color=0==selection?COLOR.red.tomato:Color.gray;
if(GUILayout.Button(names[0],GUILayout.Width(80),GUILayout.Height(20)))
GameManager.SavedMode=0;
GUI.color=Color.white;
EditorGUILayout.EndHorizontal();
publicstaticclassLayoutToggle
[MenuItem("Window/ToggleLayout&F1",false,999)]
privatestaticvoidToggleLayout()
intlayoutNumber=PlayerPrefs.GetInt("Editor_LayoutNumber")==0?1:0;
PlayerPrefs.SetInt("Editor_LayoutNumber",layoutNumber);
EditorApplication.ExecuteMenuItem(layoutNumber==0?"Window/Layouts/LogSwitchFull":"Window/Layouts/Nexus_Layout");
publicclassMergeMesh:MonoBehaviour
[MenuItem("Tools/MergeLevelMesh%&m",false,100)]
privatestaticvoidMergeLevelMesh()
if(!Application.isPlaying)
return;
Transformlevel=GameObject.Find("Level").transform;
for(intc=0;c<level.childCount;c++)
Transformcategory=level.GetChild(c);
for(intg=0;g<category.childCount;g++)
GameObjectgroup=category.GetChild(g).gameObject;
MeshFilter[]meshFilters=group.GetComponentsInChildren<MeshFilter>();
if(meshFilters.Length==0)
continue;
Meshmesh=MeshExt.GetMergedMesh(meshFilters,level);
stringpath="Assets/MergeMeshes/"+group.name+".asset";
AssetDatabase.CreateAsset(mesh,path);
AssetDatabase.ImportAsset(path);
ActorAnimator.HideAllBecauseWeMergedMeshes();
publicstaticclassQuickBuild
privatestaticBuildTarget_buildTargetBefore=BuildTarget.NoTarget;
privatestaticvoidIncreaseVersion()
intversion=Mathf.Max(PlayerPrefs.GetInt("AppVersion"),PlayerSettings.Android.bundleVersionCode)+1;
PlayerPrefs.SetInt("AppVersion",version);
PlayerSettings.Android.bundleVersionCode=version;
[MenuItem("Tools/QuickBuild/MobileDevBuild#&F7")]
privatestaticvoidMobileDevBuildScene()
_buildTargetBefore=EditorUserBuildSettings.activeBuildTarget;
PlayerSettings.productName="SPiNuP";
PlayerSettings.companyName="JanisZappa";
PlayerSettings.keystorePass="78fe!4tHH";
PlayerSettings.keyaliasPass="klP1Z89k";
IncreaseVersion();
stringdate=DateTime.Now.ToShortDateString().Replace("/",".");
PlayerSettings.bundleVersion=date+"alphav"+PlayerSettings.Android.bundleVersionCode;
EditorBuildSettingsScene[]scenesBefore=EditorBuildSettings.scenes;
BuildPlayerOptionsbuildPlayerOptions=newBuildPlayerOptions
scenes=new[]{"Assets/03_Scenes/ShowVersion/ShowVersion.unity",
SceneManager.GetActiveScene().path,
"Assets/03_Scenes/Login/Login.unity"},
locationPathName=QuickBuilds+"SPiNuP_Dev.apk",
target=BuildTarget.Android
EditorUserBuildSettings.development=true;
EditorUserBuildSettings.connectProfiler=true;
BuildPipeline.BuildPlayer(buildPlayerOptions);
EditorUserBuildSettings.development=false;
EditorUserBuildSettings.connectProfiler=false;
EditorBuildSettings.scenes=scenesBefore;
[MenuItem("Tools/QuickBuild/MobileBuild#&F6")]
privatestaticvoidMobileBuildScene()
_buildTargetBefore=EditorUserBuildSettings.activeBuildTarget;
PlayerSettings.productName="SPiNuP";
PlayerSettings.companyName="JanisZappa";
PlayerSettings.keystorePass="78fe!4tHH";
PlayerSettings.keyaliasPass="klP1Z89k";
IncreaseVersion();
stringdate=DateTime.Now.ToShortDateString().Replace("/",".");
PlayerSettings.bundleVersion=date+"alphav"+PlayerSettings.Android.bundleVersionCode;
EditorBuildSettingsScene[]scenesBefore=EditorBuildSettings.scenes;
BuildPlayerOptionsbuildPlayerOptions=newBuildPlayerOptions
scenes=new[]{"Assets/03_Scenes/ShowVersion/ShowVersion.unity",
SceneManager.GetActiveScene().path,
"Assets/03_Scenes/Login/Login.unity"},
locationPathName=QuickBuilds+"SPiNuP.apk",
target=BuildTarget.Android
EditorUserBuildSettings.development=false;
EditorUserBuildSettings.connectProfiler=false;
BuildPipeline.BuildPlayer(buildPlayerOptions);
EditorBuildSettings.scenes=scenesBefore;
Process.Start(QuickBuilds);
[MenuItem("Tools/QuickBuild/iOSBuild")]
privatestaticvoidIOSBuild()
_buildTargetBefore=EditorUserBuildSettings.activeBuildTarget;
PlayerSettings.productName="SPiNuP";
PlayerSettings.companyName="JanisZappa";
PlayerSettings.keystorePass="78fe!4tHH";
PlayerSettings.keyaliasPass="klP1Z89k";
IncreaseVersion();
stringdate=DateTime.Now.ToShortDateString().Replace("/",".");
PlayerSettings.bundleVersion=date;
EditorBuildSettingsScene[]scenesBefore=EditorBuildSettings.scenes;
BuildPlayerOptionsbuildPlayerOptions=newBuildPlayerOptions
scenes=new[]{"Assets/03_Scenes/ShowVersion/ShowVersion.unity",
SceneManager.GetActiveScene().path,
"Assets/03_Scenes/Login/Login.unity"},
locationPathName=QuickBuilds+"iOSBuild",
target=BuildTarget.iOS
EditorUserBuildSettings.development=false;
EditorUserBuildSettings.connectProfiler=false;
BuildPipeline.BuildPlayer(buildPlayerOptions);
EditorBuildSettings.scenes=scenesBefore;
Process.Start(QuickBuilds);
[MenuItem("Tools/QuickBuild/CurrentScenePCBuild#&F5")]
privatestaticvoidCurrentScenePCBuild()
_buildTargetBefore=EditorUserBuildSettings.activeBuildTarget;
boolvalidFileSelected=Selection.activeObject!=null&&Selection.activeObject.ToString().Contains("SceneAsset");
stringsceneName=validFileSelected?Selection.activeObject.name:SceneManager.GetActiveScene().name;
stringscenePath=validFileSelected?AssetDatabase.GetAssetPath(Selection.activeObject):SceneManager.GetActiveScene().path;
if(!Directory.Exists(QuickBuilds))
Directory.CreateDirectory(QuickBuilds);
stringfolder=QuickBuilds+sceneName;
stringbackupFolder=folder+"/backup";
stringsaveName=folder+"/"+sceneName+".exe";
stringbackupInfo=backupFolder+"/backupCount.txt";
if(!Directory.Exists(folder))
Directory.CreateDirectory(folder);
Directory.CreateDirectory(backupFolder);
File.WriteAllLines(backupInfo,new[]{"1"});
else
if(File.Exists(saveName))
DateTimecreation=File.GetCreationTime(saveName);
stringlastVersionFolder=backupFolder+"/"+sceneName+"_"+creation.ToString("s").Replace(":","_").Replace("-","_").Replace("T","__");
Directory.CreateDirectory(lastVersionFolder);
foreach(stringfileinDirectory.GetFiles(folder))
if(!file.Contains("backup"))
FileMove(file,lastVersionFolder+file.Replace(folder,""));
foreach(stringdirinDirectory.GetDirectories(folder))
if(!dir.Contains("backup"))
DirectoryMove(dir,lastVersionFolder+dir.Replace(folder,""));
else
foreach(stringfileinDirectory.GetFiles(folder))
if(!file.Contains("backup"))
File.Delete(file);
foreach(stringdirinDirectory.GetDirectories(folder))
if(!dir.Contains("backup"))
Directory.Delete(dir);
if(File.Exists(backupInfo))
intbackupCount=int.Parse(File.ReadAllLines(backupInfo)[0]);
List<string>allBackUps=Directory.GetDirectories(backupFolder).ToList();
allBackUps.Sort();
allBackUps.Reverse();
while(allBackUps.Count>backupCount)
Directory.Delete(allBackUps[allBackUps.Count-1],true);
allBackUps.RemoveAt(allBackUps.Count-1);
PlayerSettings.fullScreenMode=FullScreenMode.Windowed;
PlayerSettings.displayResolutionDialog=ResolutionDialogSetting.Enabled;
EditorBuildSettingsScene[]scenesBefore=EditorBuildSettings.scenes;
stringproductNameBefore=PlayerSettings.productName;
PlayerSettings.productName=sceneName;
BuildPlayerOptionsbuildPlayerOptions=newBuildPlayerOptions
scenes=new[]{scenePath},
locationPathName=saveName,
target=BuildTarget.StandaloneWindows,
options=BuildOptions.AutoRunPlayer
EditorUserBuildSettings.development=false;
EditorUserBuildSettings.connectProfiler=false;
BuildPipeline.BuildPlayer(buildPlayerOptions);
EditorBuildSettings.scenes=scenesBefore;
PlayerSettings.productName=productNameBefore;
privatestaticvoidFileMove(stringsourceFileName,stringdestFileName)
if(File.Exists(destFileName))
File.Delete(destFileName);
File.Move(sourceFileName,destFileName);
privatestaticvoidDirectoryMove(stringsourceFileName,stringdestFileName)
if(Directory.Exists(destFileName))
Directory.Delete(destFileName,true);
Directory.Move(sourceFileName,destFileName);
[PostProcessBuild(1)]
publicstaticvoidOnPostprocessBuild(BuildTargettarget,stringpathToBuiltProject)
if(EditorUserBuildSettings.activeBuildTarget==BuildTarget.Android)
string[]files=Directory.GetFiles(QuickBuilds);
List<string>deleteThese=newList<string>();
for(inti=0;i<files.Length;i++)
if(files[i].Contains(".symbols.zip"))
deleteThese.Add(files[i]);
for(inti=0;i<deleteThese.Count;i++)
File.Delete(deleteThese[i]);
if(EditorUserBuildSettings.activeBuildTarget==_buildTargetBefore||_buildTargetBefore==BuildTarget.NoTarget)
return;
BuildTargetGroupgroup=_buildTargetBefore==BuildTarget.Android?BuildTargetGroup.Android:BuildTargetGroup.Standalone;
EditorUserBuildSettings.SwitchActiveBuildTarget(group,_buildTargetBefore);
_buildTargetBefore=BuildTarget.NoTarget;
privateconststringQuickBuilds="D:/QuickBuilds/";
publicclassSimplify:MonoBehaviour
[MenuItem("Setup/SimplifyAllMeshRenderers",false,11)]
privatestaticvoidSimplifyMeshRenderers()
Object[]objects=FindObjectsOfType<MeshRenderer>();
intlength=objects.Length;
Debug.Log("Simplifying"+length+"MeshRenderer");
for(inti=0;i<length;i++)
(objects[i]asMeshRenderer).Simplify();
[MenuItem("Setup/SimplifySelectedMeshRenderer%m",false,12)]
privatestaticvoidSimplifyMeshRenderer()
MeshRenderermR=Selection.activeGameObject!=null?Selection.activeGameObject.GetComponent<MeshRenderer>():null;
if(mR!=null)
mR.Simplify();
publicstaticclassScriptCreator
[MenuItem("Edit/CreateC#%&C")]
publicstaticvoidCreate()
GameObjectattachToThis=Selection.activeGameObject;
stringfolderPath=ProjectViewPath;
stringsavePath=EditorUtility.SaveFilePanel("CreateC#Script",folderPath,"","");
string[]parts=savePath.Split('/');
Info.typeName=parts[parts.Length-1];
if(string.IsNullOrEmpty(Info.typeName))
return;
Info.path=savePath+".cs";
ScriptCreatorWindow.Open();
if(Info.IsMonoBehaviour&&attachToThis!=null)
GameObjectID=attachToThis.GetInstanceID().ToString();
TypeName=Info.typeName;
else
GameObjectID=null;
TypeName=null;
publicstaticvoidWriteScript()
newStreamWriter(Info.path))
boolusedSomething=false;
if(Info.usingUnityEngine)
outfile.WriteLine("usingUnityEngine;");
usedSomething=true;
if(Info.usingUnityEditor)
if(Info.IsMonoBehaviour)
outfile.WriteLine("#ifUNITY_EDITOR");
outfile.WriteLine("usingUnityEditor;");
outfile.WriteLine("#endif");
else
outfile.WriteLine("usingUnityEditor;");
usedSomething=true;
if(Info.usingSystemCollections)
outfile.WriteLine("usingSystem.Collections;");
usedSomething=true;
if(Info.usingSystemCollectionsGeneric)
outfile.WriteLine("usingSystem.Collections.Generic;");
usedSomething=true;
if(usedSomething)
outfile.Space(2);
if(Info.IsMonoBehaviour)
outfile.WriteLine("publicclass"+Info.typeName+":MonoBehaviour");
else
outfile.WriteLine("publicstaticclass"+Info.typeName);
outfile.WriteLine("{");
boolfirst=true;
if(Info.IsMonoBehaviour)
if(Info.Awake)
outfile.WriteLine(T(1)+"privatevoidAwake()");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(1));
outfile.WriteLine(T(1)+"}");
first=false;
if(Info.OnEnable)
if(!first)outfile.Space(2);
outfile.WriteLine(T(1)+"privatevoidOnEnable()");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(1));
outfile.WriteLine(T(1)+"}");
first=false;
if(Info.Start)
if(!first)outfile.Space(2);
outfile.WriteLine(T(1)+"privatevoidStart()");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(1));
outfile.WriteLine(T(1)+"}");
first=false;
if(Info.Update)
if(!first)outfile.Space(2);
outfile.WriteLine(T(1)+"privatevoidUpdate()");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(1));
outfile.WriteLine(T(1)+"}");
first=false;
if(Info.LateUpdate)
if(!first)outfile.Space(2);
outfile.WriteLine(T(1)+"privatevoidLateUpdate()");
outfile.WriteLine(T(1)+"{");
outfile.WriteLine(T(1));
outfile.WriteLine(T(1)+"}");
first=false;
outfile.WriteLine("}");
AssetDatabase.Refresh();
System.Diagnostics.Process.Start(Info.path);
privatestaticstringGameObjectID
get{returnPlayerPrefs.GetString("ScriptCreator_GOID");}
set{PlayerPrefs.SetString("ScriptCreator_GOID",value);}
privatestaticstringTypeName
get{returnPlayerPrefs.GetString("ScriptCreator_TypeName");}
set{PlayerPrefs.SetString("ScriptCreator_TypeName",value);}
privatestaticTypeGetType(stringname)
Assembly[]assemblies=AppDomain.CurrentDomain.GetAssemblies();
for(vari=0;i<assemblies.Length;i++)
Typet=assemblies[i].GetType(name);
if(t!=null)
returnt;
returnnull;
[UnityEditor.Callbacks.DidReloadScripts]
privatestaticvoidOnScriptsReloaded()
stringinstanceID=GameObjectID;
if(!string.IsNullOrEmpty(instanceID))
Objectobj=EditorUtility.InstanceIDToObject(int.Parse(instanceID));
GameObjectgO=objasGameObject;
if(gO!=null)
stringtypeName=TypeName;
if(!string.IsNullOrEmpty(typeName))
if(gO.name.Contains("GameObject"))
gO.name=typeName;
Componentc=gO.AddComponent(GetType(typeName));
if(c!=null)
GameObjectID=null;
TypeName=null;
publicstaticstringProjectViewPath
get
stringpath="Assets";
foreach(ObjectobjinSelection.GetFiltered(typeof(Object),SelectionMode.Assets))
path=AssetDatabase.GetAssetPath(obj);
if(!string.IsNullOrEmpty(path)&&File.Exists(path))
path=Path.GetDirectoryName(path);
break;
returnpath;
privatestaticstringT(inttabs)
conststringgap="";
stringtabSpace="";
for(inti=0;i<tabs;i++)
tabSpace+=gap;
returntabSpace;
publicstaticclassInfo
publicstaticstringtypeName,path;
publicstaticreadonlyprefBool
IsMonoBehaviour=newprefBool("ScriptCreator_IsMonoBehaviour"),
Awake=newprefBool("ScriptCreator_Awake"),
OnEnable=newprefBool("ScriptCreator_OnEnable"),
Start=newprefBool("ScriptCreator_Start"),
Update=newprefBool("ScriptCreator_Update"),
LateUpdate=newprefBool("ScriptCreator_LateUpdate");
publicclassScriptCreatorWindow:EditorWindow
privatestaticScriptCreatorWindowwindow;
publicstaticvoidOpen()
window=GetWindow(typeof(ScriptCreatorWindow),false,"CreateScript")asScriptCreatorWindow;
window.minSize=newVector2(360,300);
privatevoidOnGUI()
GUILayout.BeginHorizontal();
GUILayout.Label("\""+ScriptCreator.Info.path+"\"");
GUILayout.EndHorizontal();
GUILayout.BeginHorizontal();
GUILayout.FlexibleSpace();
if(GUILayout.Button("Change\""+ScriptCreator.Info.typeName+"\""))
stringnewPath=EditorUtility.SaveFilePanel("C#Script",ScriptCreator.ProjectViewPath,"","");
string[]parts=newPath.Split('/');
ScriptCreator.Info.typeName=parts[parts.Length-1];
if(string.IsNullOrEmpty(ScriptCreator.Info.typeName))
window.Close();
ScriptCreator.Info.path=newPath+".cs";
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
GUILayout.Space(10);
GUILayout.BeginHorizontal();
GUILayout.Label("Usings");
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
ScriptCreator.Info.usingUnityEngine.Set(GUILayout.Toggle(ScriptCreator.Info.usingUnityEngine,"UnityEngine"));
ScriptCreator.Info.usingUnityEditor.Set(GUILayout.Toggle(ScriptCreator.Info.usingUnityEditor,"UnityEditor"));
ScriptCreator.Info.usingSystemCollections.Set(GUILayout.Toggle(ScriptCreator.Info.usingSystemCollections,"System.Collections"));
ScriptCreator.Info.usingSystemCollectionsGeneric.Set(GUILayout.Toggle(ScriptCreator.Info.usingSystemCollectionsGeneric,"System.Collections.Generic"));
GUILayout.Space(10);
GUILayout.BeginHorizontal();
if(GUILayout.Button(ScriptCreator.Info.IsMonoBehaviour?"MonoBehaviour":"StaticClass"))
ScriptCreator.Info.IsMonoBehaviour.Toggle();
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
if(ScriptCreator.Info.IsMonoBehaviour)
GUILayout.Space(10);
GUILayout.BeginHorizontal();
GUILayout.Label("Methods");
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
ScriptCreator.Info.Awake.Set(GUILayout.Toggle(ScriptCreator.Info.Awake,"Awake"));
ScriptCreator.Info.OnEnable.Set(GUILayout.Toggle(ScriptCreator.Info.OnEnable,"OnEnable"));
ScriptCreator.Info.Start.Set(GUILayout.Toggle(ScriptCreator.Info.Start,"Start"));
ScriptCreator.Info.Update.Set(GUILayout.Toggle(ScriptCreator.Info.Update,"Update"));
ScriptCreator.Info.LateUpdate.Set(GUILayout.Toggle(ScriptCreator.Info.LateUpdate,"LateUpdate"));
GUILayout.Space(10);
GUILayout.BeginHorizontal();
if(GUILayout.Button("Create"))
ScriptCreator.WriteScript();
window.Close();
GUILayout.FlexibleSpace();
GUILayout.EndHorizontal();
publicclassFovAdjust:MonoBehaviour
publicboolorthographic;
publicfloatdefaultSize;
publicfloatdefaultFov;
publicfloatdefaultAspect;
publicCameracam;
privateCameraCam
get
if(cam==null)
GetCameraComponent();
returncam;
privatefloatSize{get{returnCam==null?defaultSize:defaultSize*(defaultAspect/Cam.aspect);}}
privatefloatFOV
get
if(Cam==null)
returndefaultFov;
floathFov=2*Mathf.Atan(defaultAspect*Mathf.Tan(defaultFov*.5f*Mathf.Deg2Rad));
return2*Mathf.Atan(Mathf.Tan(hFov*.5f)/Cam.aspect)*Mathf.Rad2Deg;
publicvoidSetDefaultValues()
orthographic=Cam.orthographic;
defaultSize=Cam.orthographicSize;
defaultFov=Cam.fieldOfView;
defaultAspect=Cam.aspect;
privatevoidGetCameraComponent()
cam=GetComponent<Camera>();
privatevoidOnEnable()
AdjustCam();
publicvoidAdjustCam()
if(orthographic)
Cam.orthographicSize=Size;
else
Cam.fieldOfView=FOV;
[CustomEditor(typeof(FovAdjust))]
publicclassFovAdjustEditor:Editor
publicoverridevoidOnInspectorGUI()
FovAdjustmyTarget=(FovAdjust)target;
GUILayout.BeginHorizontal();
EditorGUILayout.HelpBox(
"Orthographic:"+(myTarget.orthographic?"True":"False")+"\r\n"+
"DefaultAspect:"+myTarget.defaultAspect.ToString("F2")+"\r\n"+
"DefaultFov:"+myTarget.defaultFov.ToString("F2")+"\r\n"+
"DefaultSize:"+myTarget.defaultSize.ToString("F2"),
MessageType.Info
);
GUILayout.BeginVertical();
GUI.color=COLOR.yellow.fresh;
if(GUILayout.Button("SetDefault"))
myTarget.SetDefaultValues();
EditorUtility.SetDirty(myTarget);
GUI.color=Color.white;
if(GUILayout.Button("TestAdjustment"))
myTarget.AdjustCam();
GUILayout.EndVertical();
GUILayout.EndHorizontal();
publicclassBadFrame:MonoBehaviour
publicTextMeshProUGUItext;
publicintalertFrameRate;
privateintdrops;
privatevoidOnEnable()
drops=0;
text.text=drops.PrepString();
privatevoidUpdate()
if(1f/Time.deltaTime<=alertFrameRate)
drops++;
text.text=drops.PrepString();
publicclassFrameCounter:MonoBehaviour
publicTextMeshProUGUItextA,textB;
privatefloatdelta;
privateconstfloatstep=.2f;
privatefloatcheckTime;
privateintframes,oldFps=-1,refreshRate,oldActualFps=-1;
privatestring[]prepStrings;
privatevoidAwake()
checkTime=Time.realtimeSinceStartup;
refreshRate=0;
for(inti=0;i<Screen.resolutions.Length;i++)
refreshRate=Mathf.Max(refreshRate,Screen.resolutions[i].refreshRate);
if(refreshRate==0)
refreshRate=60;
intformatting=refreshRate>99?3:2;
prepStrings=newstring[refreshRate+1];
for(inti=0;i<prepStrings.Length;i++)
prepStrings[i]=i.ToString().PadLeft(formatting);
privatevoidUpdate()
if(GameManager.Mode==Mode.Creator)
gameObject.SetActive(false);
floattime=Time.realtimeSinceStartup;
if(time-checkTime>=step)
delta/=frames;
intfps=GetFPS(delta);
if(oldFps!=fps)
oldFps=fps;
textA.text=prepStrings[fps];
frames=0;
checkTime=time;
delta=0;
else
delta+=Time.deltaTime;
frames++;
intactualFps=GetFPS(Time.deltaTime);
if(actualFps!=oldActualFps)
oldActualFps=actualFps;
textB.text=prepStrings[actualFps];
privateintGetFPS(floatdeltaTime)
intmax=refreshRate/QualitySettings.vSyncCount;
intvalue=(int)Mathf.Max(0,Mathf.Clamp(Mathf.Ceil(1f/deltaTime),0,max));
if(value<0)
value=0;
returnvalue;
publicclassGarbageRect:MonoBehaviour
privateImageimage;
privateColorcolor;
privateboolshowRequest,showing;
privatefloatshowTime;
privatevoidAwake()
image=GetComponent<Image>();
color=image.color;
newSpawnMe(this);
Screen.sleepTimeout=SleepTimeout.NeverSleep;
privateclassSpawnMe
privatereadonlyGarbageRectgE;
publicSpawnMe(GarbageRectgE)
this.gE=gE;
~SpawnMe()
GC.ReRegisterForFinalize(this);
gE.showRequest=true;
gE.showing=false;
privatevoidUpdate()
if(showRequest)
if(!showing)
image.color=color;
showing=true;
showTime=Time.realtimeSinceStartup;
showRequest=false;
if(showing&&Time.realtimeSinceStartup-showTime>1f)
showing=false;
image.color=newColor(0,0,0,0);
publicclassFirstUpdate:MonoBehaviour
publicfloatframeStart;
privatevoidUpdate()
frameStart=Time.realtimeSinceStartup;
publicclassFrameTimeCalc:MonoBehaviour
publicFirstUpdatefirstUpdate;
privatefloatframeTime;
privateconstfloatstep=1f;
privateTextMeshProUGUItext;
privatefloatcheckTime;
privateintframes;
privatevoidAwake()
text=GetComponent<TextMeshProUGUI>();
checkTime=Time.realtimeSinceStartup;
privatevoidUpdate()
floattime=Time.realtimeSinceStartup;
if(time-checkTime>=step)
frameTime/=frames;
intfps=(int)Mathf.Max(0,Mathf.Clamp(Mathf.Ceil(1f/frameTime),0,100000));
text.text=fps.PrepString();
frames=0;
checkTime=time;
frameTime=0;
else
frameTime+=time-firstUpdate.frameStart;
frames++;
publicclassInfoPanelUpdate:MonoBehaviour
publicTextMeshProUGUItextL,textM,textR;
privatereadonlyStringBuilderbuildL=newStringBuilder(200),buildM=newStringBuilder(200),buildR=newStringBuilder(200);
privatefloatalpha;
privatestaticfloatdelta;
privatevoidOnEnable()
delta=Time.deltaTime;
privatevoidUpdate()
if(!GameManager.Running)
return;
delta=Mathf.Lerp(delta,Time.deltaTime,Time.deltaTime*10);
buildL.Length=buildM.Length=buildR.Length=0;
switch(GameManager.Mode)
caseMode.SpinUp:
textL.text=buildL.Append("").Append("\n").Append(GTime).Append("\n").Append(Loop).Append("\n").Append(FPS).ToString();
textM.text=buildM.Append(ClipType).Append("\n").Append("").Append("\n").Append("").Append("\n").Append(ClipSide).ToString();
textR.text=buildR.Append("").Append("\n").Append("").Append("\n").Append(ActiveSticks).Append("\n").Append(Zoom).ToString();
break;
caseMode.Creator:
textL.text=buildL.Append(GTime).Append("\n").Append(Loop).Append("\n").Append(FPS).Append("\n").Append("").ToString();
textM.text=buildM.Append("").ToString();
textR.text=buildR.Append(StickCount).Append("\n").Append(ActiveSticks).Append("\n").Append("").Append("\n").Append(Zoom).ToString();
break;
privatestaticstringGTime{get{return"Time:"+global::GTime.Now.ToString("F2");}}
privatestaticstringLoop{get{return"Loop"+global::GTime.LoopTime.ToString("F2")+":"+
Mathf.FloorToInt(global::GTime.LoopFraction*100).ToString("D2");}}
privatestaticstringFPS{get{return"FPS:"+Mathf.CeilToInt(Mathf.Clamp(1/delta,0,60))+"/"+60;}}
privatestaticstringZoom{get{return"CamZ:"+GameCam.CurrentDolly.ToString("F0");}}
privatestaticClipTypeCurrentClipType{get{returnGameManager.Running?Clip.Type:0;}}
privatestaticClipClip{get{returnSpinner.CurrentFocusClip;}}
privatestaticstringClipType{get{return"Clip:"+CurrentClipType;}}
privatestaticstringClipSide{get{return"Side:"+(GameManager.Running?Clip.GetSide(global::GTime.Now):newSide(true));}}
privatestaticstringStickCount{get{return"TotalItems:"+Item.Count.ToString("D2");}}
privatestaticstringActiveSticks{get{return"ActiveItems:"+Level.itemCount.ToString("D2");}}
publicstaticclassInfoPanel
privatestaticGameObjectinfoCanvas;
privatestaticboolShowInfo
set
if(value)
infoCanvas="Debug/InfoPanel_Canvas".ResourceInst(SceneLocator.UI);
else
if(infoCanvas!=null)
Object.Destroy(infoCanvas);
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]
privatestaticvoidRuntimeInitialze()
if(SceneManager.GetActiveScene().name=="main")
BoolSwitch.Link("Info/InfoPanel",false,v=>ShowInfo=v);
publicclassServerTime:Singleton<ServerTime>
privatestaticStringDisplaydisplay;
privatestaticTimeSpandifference;
privatestaticDateTimelevelStart;
privatestaticintwebMilliseconds;
privatestaticboolshowTime;
[Switch("Info/ServerTime")]
privatestaticboolshowLevelLiveTime
get{returnshowTime;}
set
showTime=value;
GameObjectclock=UI_Manager.Show_Clock(showTime);
display=showTime?clock.GetComponent<StringDisplay>():null;
publicstaticIEnumeratorGetTime()
if(Application.internetReachability==NetworkReachability.NotReachable)
DateTimesame=DateTime.Now;
GotDifference(same,same);
yieldbreak;
floattimeNow=Time.realtimeSinceStartup;
WWWwww=newWWW(Database.ServerTimePHP);
floatwaitTime=0;
while(!www.isDone)
waitTime+=Time.deltaTime;
if(waitTime>=1)
yieldbreak;
yieldreturnnull;
if(!www.isDone||www.text.Length==0)
yieldbreak;
webMilliseconds=Mathf.RoundToInt((Time.realtimeSinceStartup-timeNow)*1000);
DateTimelocalNow=DateTime.Now;
stringfirstPart=www.text.Substring(0,19);
stringsecondPart=www.text.Replace(firstPart+"-","");
DateTimeserverNow;
boolgotServerTime=DateTime.TryParseExact(firstPart,"yyyy-MM-dd-HH-mm-ss",CultureInfo.InvariantCulture,DateTimeStyles.None,outserverNow);
intmilliseconds;
boolgotMilliseconds=int.TryParse(secondPart,outmilliseconds);
if(!gotServerTime||!gotMilliseconds)
yieldbreak;
serverNow=serverNow.AddMilliseconds(webMilliseconds+milliseconds);
GotDifference(localNow,serverNow);
privatestaticvoidGotDifference(DateTimelocal,DateTimeserver)
difference=local-server;
inthours=server.Hour%8;
levelStart=newDateTime().AddHours(server.Hour-hours);
privatereadonlystring[]displayStrings=newstring[3];
privatereadonlyStringBuilder[]builders=newStringBuilder[3];
privatevoidAwake()
for(inti=0;i<3;i++)
builders[i]=newStringBuilder(30,30);
privatevoidUpdate()
if(!showLevelLiveTime)
return;
for(inti=0;i<3;i++)
builders[i].Length=0;
builders[0].Append(webMilliseconds);
DateTimeserverNow=DateTime.Now-difference;
builders[1].Append(serverNow.Hour.ToString("D2")).Append(":").
Append(serverNow.Minute.ToString("D2")).Append(":").
Append(serverNow.Second.ToString("D2"));
TimeSpanlevelDuration=serverNow-levelStart;
builders[2].Append(levelDuration.Hours.ToString("D2")).Append(":").
Append(levelDuration.Minutes.ToString("D2")).Append(":").
Append(levelDuration.Seconds.ToString("D2"));
for(inti=0;i<3;i++)
displayStrings[i]=builders[i].ToString();
display.SetTexts(displayStrings);
publicstaticfloatGetGameStartTime()
return(float)((DateTime.Now-difference-levelStart).TotalSeconds%GTime.LoopTime);
publicclassOldMeshes:ScriptableObject
publicstaticclassStoreOldMeshes
/*[MenuItem("Tools/StoreOldMeshes")]
publicstaticvoidFindAndStore()
if(Selection.activeObject==null||Selection.activeObjectasOldMeshes==null)
return;
List<SplitGMesh>splitMeshes=newList<SplitGMesh>();
string[]guids=AssetDatabase.FindAssets(string.Format("t:{0}",typeof(SplitGMesh)));
for(inti=0;i<guids.Length;i++)
stringassetPath=AssetDatabase.GUIDToAssetPath(guids[i]);
SplitGMeshasset=AssetDatabase.LoadAssetAtPath<SplitGMesh>(assetPath);
if(asset!=null)
splitMeshes.Add(asset);
List<Mesh>meshes=newList<Mesh>();
for(inti=0;i<splitMeshes.Count;i++)
Object[]assets=AssetDatabase.LoadAllAssetsAtPath(AssetDatabase.GetAssetPath(splitMeshes[i]));
for(inte=0;e<assets.Length;e++)
if(assets[e]isMesh)
Meshcopy=Object.Instantiate((Mesh)assets[e]);
copy.name=splitMeshes[i].name+"_#_"+assets[e].name;
meshes.Add(copy);
OldMeshesoldMeshes=(OldMeshes)Selection.activeObject;
for(inti=0;i<meshes.Count;i++)
AssetDatabase.AddObjectToAsset(meshes[i],oldMeshes);
EditorUtility.SetDirty(oldMeshes);
AssetDatabase.Refresh();
[CreateAssetMenu]
publicclassThinkingList:ScriptableObject
publicList<string>todo;
[Space(5)]
publicList<string>ideas;
[Space(5)]
publicList<string>musings;
[Space(15)]
publicList<string>warnings;
[Space(5)]
publicList<string>bugs;
[Space(5)]
publicList<string>build;
publicenumThoughtProcess{TODO,Ideas,Musings,Warnings,Bugs,Build}
[HideInInspector]
publicThoughtProcesscurrent;
publicclassThinkingPanel:EditorWindow
privatestaticThinkingPanelwindow;
privatestaticThinkingListthoughts;
privatestaticDateTimelast;
privatestaticintpick;
privatestaticColor[]colors;
privateconstfloatHoldTime=.12f;
privatestaticfloatNextSwitchTime;
[MenuItem("Window/ThinkingPanel")]
privatestaticvoidGetWindow()
window=GetWindow(typeof(ThinkingPanel),false,"ThinkingPanel")asThinkingPanel;
window.maxSize=newVector2(10000,35);
window.minSize=newVector2(10,35);
last=DateTime.Now;
privatevoidOnGUI()
if(thoughts==null)
thoughts=Assets.FindAll<ThinkingList>()[0];
if(colors==null||colors.Length<6)
colors=new[]
COLOR.yellow.fresh,
COLOR.green.spring,
COLOR.turquois.bright,
COLOR.blue.cornflower,
COLOR.purple.magenta,
COLOR.red.tomato
GUILayout.BeginHorizontal();
for(inti=0;i<6;i++)
ThinkingList.ThoughtProcessthoughtProcess=(ThinkingList.ThoughtProcess)i;
List<string>buttonList=GetList(thoughtProcess);
boolactive=buttonList.Count>0;
GUI.color=active?colors[(int)thoughtProcess]:Color.grey;
if(GUILayout.Button(thoughtProcess+"("+buttonList.Count+")")&&active)
thoughts.current=thoughtProcess;
pick=Random.Range(0,buttonList.Count);
last=DateTime.Now;
NextSwitchTime=buttonList[0].Replace("","").Length*HoldTime;
List<string>lines=GetList(thoughts.current);
if(lines.Count>0)
if((DateTime.Now-last).Seconds>NextSwitchTime)
last=DateTime.Now;
pick=(pick+1)%lines.Count;
NextSwitchTime=lines[pick].Replace("","").Length*HoldTime;
GUI.color=Color.white;
GUILayout.EndHorizontal();
GUI.color=colors[(int)thoughts.current];
if(lines.Count>0)
if(GUILayout.Button(lines[pick]+"("+(pick+1)+")"))
Selection.activeObject=thoughts;
GUI.color=Color.white;
privateList<string>GetList(ThinkingList.ThoughtProcessthoughtProcess)
switch(thoughtProcess)
default:returnthoughts.todo;
caseThinkingList.ThoughtProcess.Ideas:returnthoughts.ideas;
caseThinkingList.ThoughtProcess.Musings:returnthoughts.musings;
caseThinkingList.ThoughtProcess.Warnings:returnthoughts.warnings;
caseThinkingList.ThoughtProcess.Bugs:returnthoughts.bugs;
caseThinkingList.ThoughtProcess.Build:returnthoughts.build;
privatevoidOnInspectorUpdate()
if(window==null)
GetWindow();
if((DateTime.Now-last).Seconds>NextSwitchTime)
window.Repaint();
publicclassCloudMoveTest:MonoBehaviour
[Range(0,1)]
publicfloatoffset;
privatevoidUpdate()
constfloatrange=220;
transform.position=V3.right*Mathf.Lerp(-range,range,Mathf.Repeat(GTime.Now*.01f+offset,1));
publicclassSceneryEyes:MonoBehaviour
publicfloatrange;
publicAnimationCurveeyeAnim;
publicfloatspeed;
privateVector3startPos;
privatevoidAwake()
startPos=transform.position;
privatevoidUpdate()
floatsin=Mathf.Sin(GTime.Now*speed);
floatpos=Mathf.Sign(sin)*eyeAnim.Evaluate(Mathf.Abs(sin))*range;
transform.position=startPos+newVector3(pos,0,0);
publicclassShadowTestToggle:Singleton<ShadowTestToggle>
[Switch("Visuals/ShadowTest")]
privatestaticboolShowShadows
get{returnInst!=null&&Inst.shadowTest.activeInHierarchy;}
set
if(Inst!=null)
Inst.shadowTest.SetActive(value);
Inst.treeTest.SetActive(value);
publicGameObjectshadowTest,treeTest;
privateinthighQuality,lowQuality;
privateGameObject[]renderers;
privatevoidAwake()
highQuality=LayerMask.NameToLayer("ShadowSprites");
lowQuality=LayerMask.NameToLayer("Lighting");
List<GameObject>rend=newList<GameObject>();
for(inti=0;i<shadowTest.transform.childCount;i++)
rend.Add(shadowTest.transform.GetChild(i).gameObject);
renderers=rend.ToArray();
privatevoidUpdate()
if(ShowShadows)
for(inti=0;i<renderers.Length;i++)
renderers[i].layer=GameCam.CurrentSide==Side.Front?highQuality:lowQuality;
treeTest.layer=GameCam.CurrentSide==Side.Front?lowQuality:highQuality;
publicclassSimpleAxisRotation:MonoBehaviour
publicVector3axis=Vector3.up;
publicfloatanimSpeed=.75f;
privatefloatt;
privatevoidUpdate()
t+=Time.deltaTime*animSpeed;
transform.localRotation=Quaternion.AngleAxis(t,axis.normalized);
publicclassOrderRandomizer
privatereadonlyint[]values;
publicOrderRandomizer(intmaxLength)
values=newint[maxLength];
publicvoidRandomize(intlength)
for(inti=0;i<length;i++)
values[i]=i;
for(inti=0;i<length;i++)
intother=Random.Range(0,length);
intotherValue=values[other];
intvalue=values[i];
values[other]=value;
values[i]=otherValue;
publicvoidRandomize(intlength,System.Randomrandom)
for(inti=0;i<length;i++)
values[i]=i;
for(inti=0;i<length;i++)
intother=random.Range(0,length);
intotherValue=values[other];
intvalue=values[i];
values[other]=value;
values[i]=otherValue;
publicintthis[intindex]{get{returnvalues[index];}}
publicstaticclassAssets
publicstaticT[]FindAll<T>()whereT:Object
List<T>assets=newList<T>();
string[]guids=AssetDatabase.FindAssets(string.Format("t:{0}",typeof(T)));
for(inti=0;i<guids.Length;i++)
stringassetPath=AssetDatabase.GUIDToAssetPath(guids[i]);
Object[]allObjects=AssetDatabase.LoadAllAssetsAtPath(assetPath);
Tasset=AssetDatabase.LoadAssetAtPath<T>(assetPath);
if(asset!=null)
assets.Add(asset);
returnassets.ToArray();
publicstaticMesh[]FindAllMeshes(stringpath)
List<Mesh>assets=newList<Mesh>();
string[]guids=AssetDatabase.FindAssets("",new[]{"Assets/"+path});
List<string>used=newList<string>();
for(inti=0;i<guids.Length;i++)
stringassetPath=AssetDatabase.GUIDToAssetPath(guids[i]);
if(used.Contains(assetPath))
continue;
Object[]allObjects=AssetDatabase.LoadAllAssetsAtPath(assetPath);
for(into=0;o<allObjects.Length;o++)
if(allObjects[o]isMesh)
assets.Add((Mesh)allObjects[o]);
used.Add(assetPath);
break;
returnassets.ToArray();
publicstaticTGet<T>(stringname)whereT:Object
string[]guids=AssetDatabase.FindAssets(name);
if(guids.Length==0)
Debug.Log("Couldn'tfindAssetwithName\""+name+"\"");
returnnull;
if(guids.Length>1)
Debug.Log("ToomanyAssetswithName\""+name+"\"");
returnnull;
stringguid=guids[0];
Tthing=AssetDatabase.LoadAssetAtPath<T>(AssetDatabase.GUIDToAssetPath(guid));
if(thing==null)
Debug.Log("AssetswithName\""+name+"\"isn'ttherightType");
returnthing;
publicstaticclassCollectionInit
publicstaticT[]Array<T>(intcount)whereT:new()
T[]array=newT[count];
for(inti=0;i<count;i++)
array[i]=newT();
returnarray;
publicstaticList<T>List<T>(intcount)whereT:new()
List<T>list=newList<T>(count);
for(inti=0;i<count;i++)
list.Add(newT());
returnlist;
publicstaticclassDesktopTxt
publicstaticvoidWrite(stringname,string[]lines,stringext=".txt")
File.WriteAllLines(Environment.GetFolderPath(Environment.SpecialFolder.Desktop).Replace("\\","/")+"/"+name+ext,lines);
publicstaticstring[]Read(stringname,stringext=".txt")
stringpath=Environment.GetFolderPath(Environment.SpecialFolder.Desktop).Replace("\\","/")+"/"+name+ext;
returnFile.Exists(path)?File.ReadAllLines(path):newstring[0];
publicstaticclassDocumentsTxt
publicstaticvoidWrite(stringname,string[]lines,stringext=".txt")
File.WriteAllLines(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments).Replace("\\","/")+"/"+name+ext,lines);
publicstaticstring[]Read(stringname,stringext=".txt")
stringpath=Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments).Replace("\\","/")+"/"+name+ext;
returnFile.Exists(path)?File.ReadAllLines(path):newstring[0];
publicstaticclassProjectTxt
publicstaticvoidWrite(stringname,string[]lines,stringext=".txt")
File.WriteAllLines(Application.dataPath+"/"+name+ext,lines);
publicstaticstring[]Read(stringname,stringext=".txt")
stringpath=Application.dataPath+"/"+name+ext;
returnFile.Exists(path)?File.ReadAllLines(path):newstring[0];
publicstaticclassResourceTxt
publicstaticvoidWrite(stringname,string[]lines,stringext=".txt")
File.WriteAllLines(Application.dataPath+"/Resources/"+name+ext,lines);
publicstaticstring[]Read(stringname)
returnResources.Load<TextAsset>(name).text.Split('\n');
publicstaticclassEmoji
publicconststringSad="()";
publicconststringSuccess="(**)";
publicconststringHappy="(/^^)/";
publicconststringConfused="()";
publicconststringShock="()";
publicconststringCrazy="()";
publicconststringSmug="()";
publicconststringSrsly="(_)";
publicconststringAngry="()";
publicconststringRage="(";
publicconststringThink="(())";
publicstaticclassEncryption
staticEncryption()
passwordBytes=newbyte[]{042,088,003,005,005,008,002,002};
saltBytes=newbyte[]{001,006,004,006,124,111,007,034};
privatestaticreadonlybyte[]passwordBytes,saltBytes;
publicstaticbyte[]Encrypt(byte[]bytesToBeEncrypted)
byte[]encryptedBytes;
AES.KeySize=256;
AES.BlockSize=128;
varkey=newRfc2898DeriveBytes(passwordBytes,saltBytes,1000);
AES.Key=key.GetBytes(AES.KeySize/8);
AES.IV=key.GetBytes(AES.BlockSize/8);
AES.Mode=CipherMode.CBC;
cs.Write(bytesToBeEncrypted,0,bytesToBeEncrypted.Length);
cs.Close();
encryptedBytes=ms.ToArray();
returnencryptedBytes;
publicstaticbyte[]Decrypt(byte[]bytesToBeDecrypted)
byte[]decryptedBytes;
AES.KeySize=256;
AES.BlockSize=128;
varkey=newRfc2898DeriveBytes(passwordBytes,saltBytes,1000);
AES.Key=key.GetBytes(AES.KeySize/8);
AES.IV=key.GetBytes(AES.BlockSize/8);
AES.Mode=CipherMode.CBC;
cs.Write(bytesToBeDecrypted,0,bytesToBeDecrypted.Length);
cs.Close();
decryptedBytes=ms.ToArray();
returndecryptedBytes;
publicclassExeEscQuit:MonoBehaviour
privatestaticVector2lastPos;
privatestaticfloatlastMove;
privatevoidAwake()
lastPos=Input.mousePosition;
lastMove=float.MinValue;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Escape))
Application.Quit();
if(Input.GetKeyDown(KeyCode.F11))
Screen.fullScreen=!Screen.fullScreen;
Vector2mousePos=Input.mousePosition;
if(lastPos!=mousePos)
lastPos=mousePos;
lastMove=Time.realtimeSinceStartup;
Cursor.visible=lastMove>=Time.realtimeSinceStartup-2;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
publicstaticvoidRegister()
if(!Application.isMobilePlatform&&!Application.isEditor)
SceneManager.sceneLoaded+=PutInScene;
privatestaticvoidPutInScene(Scenescene,LoadSceneModemode)
newGameObject().AddComponent<ExeEscQuit>();
publicstaticclassFancyString
privatestaticboolNo{get{return!Application.isEditor;}}
publicstaticstringB_Start(stringcolor)
return"<b><color="+color+">";
publicconststringB_End="</color></b>";
publicstaticstringB(thisstringinputString)
returnNo?inputString:"<b>"+inputString+"</b>";
publicstaticstringB(thisstringinputString,intindex)
switch(index)
default:returninputString.B();
case0:returninputString.B_Purple();
case1:returninputString.B_Red();
case2:returninputString.B_Orange();
case3:returninputString.B_Yellow();
case4:returninputString.B_Lime();
case5:returninputString.B_Green();
case6:returninputString.B_Teal();
case7:returninputString.B_LightBlue();
case8:returninputString.B_Blue();
case9:returninputString.B_Pink();
case10:returninputString.B_Salmon();
publicstaticstringB_Frame(thisstringinputString)
returnNo?inputString:inputString.B(Time.frameCount%11);
publicstaticstringB_Purple(thisstringinputString)
returnNo?inputString:B_Start("purple")+inputString+B_End;
publicstaticstringB_Red(thisstringinputString)
returnNo?inputString:B_Start("red")+inputString+B_End;
publicstaticstringB_Orange(thisstringinputString)
returnNo?inputString:B_Start("orange")+inputString+B_End;
publicstaticstringB_Yellow(thisstringinputString)
returnNo?inputString:B_Start("yellow")+inputString+B_End;
publicstaticstringB_Lime(thisstringinputString)
returnNo?inputString:B_Start("lime")+inputString+B_End;
publicstaticstringB_Green(thisstringinputString)
returnNo?inputString:B_Start("green")+inputString+B_End;
publicstaticstringB_Teal(thisstringinputString)
returnNo?inputString:B_Start("teal")+inputString+B_End;
publicstaticstringB_LightBlue(thisstringinputString)
returnNo?inputString:B_Start("aqua")+inputString+B_End;
publicstaticstringB_Blue(thisstringinputString)
returnNo?inputString:B_Start("blue")+inputString+B_End;
publicstaticstringB_Pink(thisstringinputString)
returnNo?inputString:B_Start("magenta")+inputString+B_End;
publicstaticstringB_Salmon(thisstringinputString)
returnNo?inputString:B_Start("#ff726b")+inputString+B_End;
publicstaticstringB_Color(thisstringinputString,Colorcolor)
returnNo?inputString:B_Start(color.ToHex())+inputString+B_End;
publicstaticstringB_Color32(thisstringinputString,Color32color)
returnNo?inputString:B_Start(color.ToHex())+inputString+B_End;
publicstaticstringB_Hex(thisstringinputString,stringhex)
returnNo?inputString:B_Start(hex)+inputString+B_End;
publicstaticstringB_Switch(thisstringinputString,Colora,Colorb,boolselect)
returnNo?inputString:B_Start((select?b:a).ToHex())+inputString+B_End;
privatestaticreadonlyStringBuilderSB=newStringBuilder(100);
privateconststringchars="AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789";
publicstaticstringBlock="";
publicstaticstringGetRandom(intlength)
SB.Length=0;
for(inti=0;i<length;i++)
SB.Append(chars[Random.Range(0,chars.Length)]);
returnSB.ToString();
publicstaticclassEase
publicstaticfloatFF(floatvalue)
floatmapped=Mathf.PI*.5f*(Mathf.Clamp01(value)*2-1);
return.5f+Mathf.Sin(mapped)*.5f;
publicstaticfloatLF(floatvalue)
returnMathf.Sin(Mathf.PI*.5f*Mathf.Clamp01(value));
publicstaticfloatFL(floatvalue)
return1+Mathf.Sin(Mathf.PI*.5f*(Mathf.Clamp01(value)-1));
publicclassHirarchyBlurb:MonoBehaviour
[TextArea(10,20)]
publicstringblurb;
[HideInInspector]publicList<GameObject>subObjects;
privateTransformoldParent;
privatestringoldBlurb;
privateintoldSiblingIndex;
privateconstintmax=26;
publicvoidUpdateNames()
intchildIndex=transform.GetSiblingIndex();
if(oldBlurb==blurb&&oldParent==transform.parent&&oldSiblingIndex==childIndex)
return;
oldBlurb=blurb;
oldParent=transform.parent;
oldSiblingIndex=childIndex;
while(subObjects.Count>0)
DestroyImmediate(subObjects[0]);
subObjects.RemoveAt(0);
List<string>parts=newList<string>();
string[]split=blurb.Split('');
stringpartString="";
for(inti=0;i<split.Length;i++)
if(partString.Length+split[i].Length>max)
parts.Add(partString);
partString="";
partString+=split[i];
if(partString.Length<max&&i<split.Length-1)
partString+="";
if(!string.IsNullOrEmpty(partString))
parts.Add(partString);
if(parts.Count==0)
name="Blurb";
return;
name=""+parts[0];
for(inti=1;i<parts.Count;i++)
GameObjectsub=newGameObject(""+parts[i]){tag="EditorOnly"};
sub.transform.SetParent(oldParent);
sub.transform.SetSiblingIndex(childIndex+i);
subObjects.Add(sub);
publicclassMobileAspectDektopCams:MonoBehaviour
privateconstfloatwidth=561,height=315;
privateenumCamMode
Default,Landscape,Portrait,Square
privatestaticCamModeMode=CamMode.Default;
privatestaticCameraBlackCam;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.C))
if(BlackCam!=null)
Destroy(BlackCam.gameObject);
Mode=(CamMode)(((int)Mode+1)%4);
Camera[]allCams=FindObjectsOfType<Camera>();
constfloatscale=.8f;
Rectrect=newRect(Vector2.zero,Vector2.one);
switch(Mode)
caseCamMode.Default:
rect=newRect(Vector2.zero,Vector2.one);
break;
caseCamMode.Landscape:
constfloatdesiredAspect=width/height;
floatw=Screen.height*scale/Screen.width;
floath=(Screen.height*scale/desiredAspect)/Screen.height;
rect=newRect(newVector2((1-w)*.5f,(1-h)*.5f),newVector2(w,h));
gotoCreateBlackCam;
caseCamMode.Portrait:
constfloatdesiredAspect=height/width;
floatshortSide=Screen.height*scale*desiredAspect;
floatw=shortSide/Screen.width;
floath=scale;
rect=newRect(newVector2((1-w)*.5f,(1-h)*.5f),newVector2(w,h));
gotoCreateBlackCam;
caseCamMode.Square:
constfloatdesiredAspect=height/width;
floatw=(Screen.width*desiredAspect*scale)/Screen.width;
floath=(Screen.width*desiredAspect*scale)/Screen.height;
rect=newRect(newVector2((1-w)*.5f,(1-h)*.5f),newVector2(w,h));
gotoCreateBlackCam;
CreateBlackCam:
BlackCam=newGameObject("BlackCam").AddComponent<Camera>();
BlackCam.depth=-100;
BlackCam.backgroundColor=Color.black;
BlackCam.clearFlags=CameraClearFlags.Color;
BlackCam.cullingMask=0;
for(inti=0;i<allCams.Length;i++)
if(allCams[i].targetTexture==null)
allCams[i].rect=rect;
if(BlackCam!=null)
BlackCam.depth=-100;
BlackCam.backgroundColor=Color.black;
BlackCam.clearFlags=CameraClearFlags.Color;
BlackCam.cullingMask=0;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
publicstaticvoidRegister()
if(!Application.isMobilePlatform)//&&!Application.isEditor)
SceneManager.sceneLoaded+=PutInScene;
privatestaticvoidPutInScene(Scenescene,LoadSceneModemode)
newGameObject().AddComponent<MobileAspectDektopCams>();
publicstaticclassMth
publicconstfloat=3.141593f;
publicconstfloatEulerNum=2.718281f;
publicconstfloatPythagoras=1.414214f;
publicconstfloatFullRad=2*Mathf.PI;
publicconstfloatHalfRad=Mathf.PI;
publicconstfloatQuarterRad=Mathf.PI*.5f;
privatestaticfloatDamp(floatx,floatdampRange)
if(x<0)
returnx;
returndampRange*(1-Mathf.Exp(-x/dampRange));
publicstaticfloatDampedRange(floatvalue,floatremapMin,floatremapMax)
floatrange=remapMax-remapMin;
if(range>=0)
returnDamp(value-remapMin,Mathf.Abs(range))+remapMin;
returnremapMin-Damp(remapMin-value,Mathf.Abs(range));
publicstaticclassChord
publicstaticfloatGetRadians(floatchordLength,floatradius)
return2*Mathf.Asin(chordLength/2/radius);
publicstaticfloatGetAngle(floatchordLength,floatradius)
return2*Mathf.Asin(chordLength/2/radius)*Mathf.Rad2Deg;
publicstaticfloatGetArcLength(floatchordLength,floatradius)
floatradians=2*Mathf.Asin(chordLength/2/radius);
returnradians/2**radius;
publicstaticfloatGetRadius(floatchordLength,floatarcLength)
floatcircleFactor=GetCircleFactor(chordLength,arcLength);
return1f/circleFactor*arcLength//2;
publicstaticfloatGetCircleFactor(floatchordLength,floatarcLength)
if(f.Same(arcLength,chordLength))
return0;
floatcircleFactor=(arcLength-chordLength)/arcLength;
constfloatpower=/EulerNum;
circleFactor=Mathf.Sin(Mathf.Pow(circleFactor,power)*.5f*);
returncircleFactor;
publicstaticfloatGetRadiusFull(floatchordLength,floatarcLength)
return1f/Mathf.Sin(Mathf.Pow((arcLength-chordLength)/arcLength,/EulerNum)*.5f*)*arcLength//2;
publicstaticfloatDivide(thisfloatvalue,floatdivider,intrepeat)
for(inti=0;i<repeat;i++)
value=value/divider;
returnvalue;
publicstaticfloatSmoothPP(floatt)
constfloatstart=Mathf.PI*-.5f;
returnMathf.Sin(start+t*Mathf.PI);
publicstaticfloatSmoothPP(floatmin,floatmax,floatt)
constfloatstart=Mathf.PI*-.5f;
returnmin+(max-min)*(Mathf.Sin(start+t*Mathf.PI)*.5f+.5f);
publicstaticfloatRepeat(floata,floatb,floatvalue)
floatmin=Mathf.Min(a,b);
floatmax=Mathf.Max(a,b);
floatrange=max-min;
floatoffset=-min;
returnMod(value+offset,range)-offset;
privatestaticfloatMod(floata,floatb)
returna-b*Mathf.Floor(a/b);
publicstaticfloatIntPow(floatvalue,intpow)
switch(pow)
case2:returnvalue*value;
case3:returnvalue*value*value;
case4:returnvalue*value*value*value;
case5:returnvalue*value*value*value*value;
case6:returnvalue*value*value*value*value*value;
case7:returnvalue*value*value*value*value*value*value;
case8:returnvalue*value*value*value*value*value*value*value;
case9:returnvalue*value*value*value*value*value*value*value*value;
case10:returnvalue*value*value*value*value*value*value*value*value*value;
case11:returnvalue*value*value*value*value*value*value*value*value*value*value;
case12:returnvalue*value*value*value*value*value*value*value*value*value*value*value;
case13:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value;
case14:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value;
case15:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case16:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case17:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case18:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case19:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case20:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case21:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case22:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case23:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case24:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case25:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case26:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case27:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case28:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case29:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
case30:returnvalue*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value*value;
returnMathf.Pow(value,pow);
publicstaticclassPathResourceInst
publicstaticGameObjectResourceInst(thisstringpath,Transformparent=null)
returnObject.Instantiate(Resources.Load(path)asGameObject,parent);
publicclassprefBool
privatereadonlystringid;
privateboolvalue
get{returnPlayerPrefs.GetInt(id)==1;}
set{PlayerPrefs.SetInt(id,value?1:0);}
publicprefBool(stringid)
this.id=id;
publicvoidKeySwitch(KeyCodekey,booldown=true)
if(down?Input.GetKeyDown(key):Input.GetKeyUp(key))
value=!value;
publicvoidToggle()
value=!value;
publicstaticimplicitoperatorbool(prefBoold)
returnd.value;
publicvoidSet(boolvalue)
this.value=value;
publicclassprefInt
privatereadonlystringid;
privateintvalue
get{returnPlayerPrefs.GetInt(id);}
set{PlayerPrefs.SetInt(id,value);}
publicprefInt(stringid)
this.id=id;
publicstaticimplicitoperatorint(prefIntd)
returnd.value;
publicvoidSet(intvalue)
this.value=value;
publicclassprefFloat
privatereadonlystringid;
privatefloatvalue
get{returnPlayerPrefs.GetFloat(id);}
set{PlayerPrefs.SetFloat(id,value);}
publicprefFloat(stringid)
this.id=id;
publicstaticimplicitoperatorfloat(prefFloatd)
returnd.value;
publicvoidSet(floatvalue)
this.value=value;
publicclassPrintKeycode:MonoBehaviour
[Switch("Dev/Keycodes")]privatestaticboolShowKeys=false;
privateKeyCode[]keyArray;
privateintkeyCount;
privatevoidAwake()
List<KeyCode>getKeys=newList<KeyCode>();
foreach(KeyCodevKeyinSystem.Enum.GetValues(typeof(KeyCode)))
getKeys.Add(vKey);
keyArray=getKeys.ToArray();
keyCount=keyArray.Length;
privatevoidUpdate()
if(ShowKeys&&Input.anyKey)
for(inti=0;i<keyCount;i++)
KeyCodekey=keyArray[i];
if(Input.GetKeyDown(key))
Debug.Log(key);
publicclassQuickList<T>
publicintCount;
privatereadonlyT[]things;
privateintcapacity;
publicTthis[intindex]
get{returnthings[index];}
set{things[index]=value;}
publicQuickList(intcapacity)
things=newT[capacity];
this.capacity=capacity;
publicvoidClear()
Count=0;
publicvoidRemoveAt(intindex)
if(index>=Count)
return;
Count--;
things[index]=things[Count];
publicvoidAdd(Tthing)
if(Count==capacity)
Debug.LogFormat("Can'tadd{0}toQuickList",thing);
return;
things[Count++]=thing;
publicstaticclassRot
publicstaticreadonlyQuaternionZero=Quaternion.identity;
publicstaticQuaternionLimit(thisQuaterniona,floatvalue)
returnQuaternion.Slerp(Rot.Zero,a,value);
publicstaticQuaternionX(floatangle)
returnQuaternion.AngleAxis(angle,Vector3.right);
angle*=Mathf.Deg2Rad*.5f;
returnnewQuaternion(Mathf.Sin(angle),0,0,Mathf.Cos(angle));
publicstaticQuaternionY(floatangle)
returnQuaternion.AngleAxis(angle,Vector3.up);
angle*=Mathf.Deg2Rad*.5f;
returnnewQuaternion(0,Mathf.Sin(angle),0,Mathf.Cos(angle));
publicstaticQuaternionZ(floatangle)
returnQuaternion.AngleAxis(angle,Vector3.forward);
angle*=Mathf.Deg2Rad*.5f;
returnnewQuaternion(0,0,Mathf.Sin(angle),Mathf.Cos(angle));
publicclassRun:MonoBehaviour
publicstaticRunInst;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
publicstaticvoidPutInScene()
if(Inst!=null)
return;
GameObjectinstance=newGameObject("Run");
Inst=instance.AddComponent<Run>();
DontDestroyOnLoad(instance);
publicclassSceneRestart:MonoBehaviour
publicKeyCodekeycode=KeyCode.Alpha0;
privatevoidUpdate()
if(Input.GetKeyDown(keycode))
SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
publicstaticclassSign
publicstaticintRandom{get{returnUnityEngine.Random.Range(0,2)==0?1:-1;}}
publicabstractclassSingleton<T>:MonoBehaviourwhereT:Singleton<T>
privatestaticT_inst;
publicstaticTInst
get{return_inst?_inst:_inst=FindObjectOfType<T>();}
privatevoidAwake()
_inst=FindObjectOfType<T>();
publicclassUniqueList
publicintLength;
privatereadonlyintCapacity;
privatereadonlyint[]values;
privatereadonlyint[]map;
privatereadonlybool[]has;
publicintthis[intindex]
get{returnvalues[index];}
publicUniqueList(intcapacity)
map=newint[capacity];
values=newint[capacity];
has=newbool[capacity];
Capacity=capacity;
publicvoidClear()
Length=0;
has.Clear();
publicboolAdd(intvalue)
if(Length==Capacity)
if(log)
Debug.LogFormat("Can'tadd{0}becauseListisfull",value);
Log();
returnfalse;
if(has[value])
if(log)
Debug.LogFormat("Can'tadd{0}becauseit'salreadyonList",value);
Log();
returnfalse;
has[value]=true;
map[value]=Length;
values[Length]=value;
Length++;
if(log)
Log();
returntrue;
publicintRemoveAt(intwhereToLook)
if(whereToLook>=Length)
if(log)
Debug.LogFormat("Can'tRemoveAt{0}becauseListisn'tthatlong",whereToLook);
Log();
return0;
intvalue=values[whereToLook];
has[value]=false;
intwhatToReplaceItWith=values[Length-1];
map[whatToReplaceItWith]=whereToLook;
values[whereToLook]=whatToReplaceItWith;
Length--;
if(log)
Log();
returnvalue;
publicvoidRemove(intvalue)
intwhereToLook=map[value];
if(whereToLook>=Length)
if(log)
Debug.LogFormat("Can'tRemove{0}becauseit'snotontheList",value);
Log();
return;
if(!has[value])
if(log)
Debug.LogFormat("Can'tRemove{0}becauseit'snotontheList",value);
Log();
return;
has[value]=false;
intwhatToReplaceItWith=values[Length-1];
map[whatToReplaceItWith]=whereToLook;
values[whereToLook]=whatToReplaceItWith;
Length--;
if(log)
Log();
privatevoidLog()
stringloggy="Length:"+Length+"|";
for(inti=0;i<Length;i++)
loggy+=values[i]+(i<Length-1?",":"");
Debug.Log(loggy);
privateconstboollog=false;
publicstaticclassV2
publicstaticreadonlyVector2zero=Vector2.zero;
publicstaticreadonlyVector2one=Vector2.one;
publicstaticreadonlyVector2right=Vector2.right;
publicstaticreadonlyVector2left=Vector2.left;
publicstaticreadonlyVector2up=Vector2.up;
publicstaticreadonlyVector2down=Vector2.down;
publicstaticreadonlyVector2away=newVector2(0,-1000);
publicstaticVector2Random(floatrange)
returnnewVector2(UnityEngine.Random.Range(-range*.5f,range*.5f),UnityEngine.Random.Range(-range*.5f,range*.5f));
publicstaticfloatInverseLerp(Vector2a,Vector2dir,Vector2value)
Vector2AV=value-a;
returnVector2.Dot(AV,dir)/Vector2.Dot(dir,dir);
publicstaticclassV3
publicstaticreadonlyVector3zero=Vector3.zero;
publicstaticreadonlyVector3one=Vector3.one;
publicstaticreadonlyVector3right=Vector3.right;
publicstaticreadonlyVector3left=Vector3.left;
publicstaticreadonlyVector3up=Vector3.up;
publicstaticreadonlyVector3down=Vector3.down;
publicstaticreadonlyVector3forward=Vector3.forward;
publicstaticreadonlyVector3back=Vector3.back;
publicstaticreadonlyVector3away=newVector3(0,-1000,0);
publicstaticclassV3Volume
publicstaticVector3VolumeScaleX(thisVector3vector,floatscale)
floatvolume=vector.x*vector.y*vector.z;
floatfactor=Mathf.Sqrt(volume/(vector.x*scale))/Mathf.Sqrt(vector.y*vector.z);
returnnewVector3(vector.x*scale,vector.y*factor,vector.z*factor);
publicstaticVector3VolumeScaleY(thisVector3vector,floatscale)
floatvolume=vector.x*vector.y*vector.z;
floatfactor=Mathf.Sqrt(volume/(vector.y*scale))/Mathf.Sqrt(vector.x*vector.z);
returnnewVector3(vector.x*factor,vector.y*scale,vector.z*factor);
publicstaticVector3VolumeScaleZ(thisVector3vector,floatscale)
floatvolume=vector.x*vector.y*vector.z;
floatfactor=Mathf.Sqrt(volume/(vector.z*scale))/Mathf.Sqrt(vector.x*vector.y);
returnnewVector3(vector.x*factor,vector.y*factor,vector.z*scale);
publicstaticVector3GetFactors(thisVector3vector,Vector3otherVector)
returnnewVector3(otherVector.x/vector.x,otherVector.y/vector.y,otherVector.z/vector.z);
publicstaticVector3ZeroDamp(thisVector3vector)
returnnewVector3(Mth.DampedRange(vector.x,1,0),Mth.DampedRange(vector.y,1,0),Mth.DampedRange(vector.z,1,0));
publicstaticclassBlankSpace
[MenuItem("Assets/Create/BlankSpaceBefore%UP")]
publicstaticvoidCreateBefore()
Create(true);
[MenuItem("Assets/Create/BlankSpaceAfter%DOWN")]
publicstaticvoidCreateAfter()
Create(false);
privatestaticvoidCreate(boolbefore)
if(Selection.activeGameObject==null)
return;
Transformt=Selection.activeGameObject.transform;
intindex=t.GetSiblingIndex()+(before?0:1);
GameObjectblank=newGameObject("");
blank.transform.SetParent(t.parent,false);
blank.transform.SetSiblingIndex(index);
blank.tag="EditorOnly";
internalstaticclassUsefulShortcuts
[MenuItem("Edit/ClearConsole_^")]
privatestaticvoidClearConsole()
/*varlogEntries=System.Type.GetType("UnityEditorInternal.LogEntries,UnityEditor.dll");
varclearMethod=logEntries.GetMethod("Clear",System.Reflection.BindingFlags.Static|System.Reflection.BindingFlags.Public);
clearMethod.Invoke(null,null);*/
publicstaticclassGroupSelection
[MenuItem("Edit/GroupItems%g")]
publicstaticvoidGroupItems()
GameObject[]selection=Selection.gameObjects;
if(selection.Length==0)
return;
Transformparent=selection[selection.Length-1].transform.parent;
GameObjectgroup=newGameObject("Group");
group.transform.SetParent(parent);
for(inti=0;i<selection.Length;i++)
selection[i].transform.SetParent(group.transform,true);
[CustomEditor(typeof(HirarchyBlurb))]
publicclassHirarchyBlurbEditor:Editor
publicoverridevoidOnInspectorGUI()
HirarchyBlurbblurb=targetasHirarchyBlurb;
EditorGUI.BeginChangeCheck();
base.OnInspectorGUI();
if(EditorGUI.EndChangeCheck()||blurb.transform.hasChanged)
(targetasHirarchyBlurb).UpdateNames();
publicstaticclassNameGameObjectLikeScript
[MenuItem("Edit/NameGameObjectlikeScript%9")]
privatestaticvoidNameIt()
GameObjectgO=Selection.activeGameObject;
if(gO==null||!gO.name.Contains("GameObject"))
return;
Component[]allComponents=gO.GetComponents<Component>();
for(inti=0;i<allComponents.Length;i++)
stringname=allComponents[i].GetType().ToString();
if(!name.Contains("UnityEngine"))
gO.name=name;
break;
publicstaticclassZeroTransform
[MenuItem("Edit/ZeroTransform%0")]
publicstaticvoidZeroIt()
if(Selection.activeGameObject!=null)
Transformt=Selection.activeGameObject.transform;
t.localPosition=Vector3.zero;
t.localRotation=Quaternion.identity;
t.localScale=Vector3.one;
publicstaticclassarrayExt
publicstaticintPlugRemoveAt<T>(thisT[]array,intindex,intlength)
if(index>=length)
returnlength;
intnewLength=length-1;
if(index<newLength)
array[index]=array[newLength];
returnnewLength;
publicstaticintShiftRemoveAt<T>(thisT[]array,intindex,intlength)
if(index>=length)
returnlength;
intnewLength=length-1;
if(index<newLength)
intstart=index+1;
for(inti=start;i<length;i++)
array[i-1]=array[i];
returnnewLength;
publicstaticintPlugRemove<T>(thisT[]array,Tthing,intlength)
for(inti=0;i<length;i++)
if(array[i].Equals(thing))
returnarray.PlugRemoveAt(i,length);
returnlength;
publicstaticintShiftRemove<T>(thisT[]array,Tthing,intlength)
for(inti=0;i<length;i++)
if(array[i].Equals(thing))
returnarray.ShiftRemoveAt(i,length);
returnlength;
publicstaticintAdd<T>(thisT[]array,Tthing,intlength)
if(length>=array.Length)
returnlength;
array[length]=thing;
returnlength+1;
publicstaticboolContains<T>(thisT[]array,Tthing,intlength)
for(inti=0;i<length;i++)
if(array[i].Equals(thing))
returntrue;
returnfalse;
publicstaticvoidReplace<T>(thisT[]array,Ta,Tb,intlength)
for(inti=0;i<length;i++)
if(array[i].Equals(a))
array[i]=b;
return;
publicstaticintMaxStringLength(thisstring[]list)
intlongest=0;
for(inti=0;i<list.Length;i++)
longest=Mathf.Max(longest,list[i].Length);
returnlongest;
publicstaticstringLog(thisint[]list)
stringvalue="";
intcount=list.Length,max=count-1;
for(inti=0;i<count;i++)
value+=list[i]+(i<max?"|":"");
returnvalue;
publicstaticstringLog(thisfloat[]list)
stringvalue="";
intcount=list.Length,max=count-1;
for(inti=0;i<count;i++)
value+=list[i]+(i<max?"|":"");
returnvalue;
publicstaticstringLog(thisColor[]list)
intcount=list.Length;
stringline="";
for(inti=0;i<count;i++)
line+="<color="+list[i].ToHex()+"></color>";
returnline;
publicstaticstringLog(thisColor32[]array)
intcount=array.Length;
stringline="";
for(inti=0;i<count;i++)
line+="<color="+array[i].ToHex()+"></color>";
returnline;
publicstaticT[]Copy<T>(thisT[]array)
intcount=array.Length;
T[]copyArray=newT[count];
for(inti=0;i<count;i++)
copyArray[i]=array[i];
returncopyArray;
publicstaticT[]Randomize<T>(thisT[]array)
intcount=array.Length;
for(inti=0;i<count;i++)
Tvalue=array[i];
intswitchWith=Random.Range(0,count);
array[i]=array[switchWith];
array[switchWith]=value;
returnarray;
publicstaticvoidRandomizeRange(thisint[]array,intlength)
for(inti=0;i<length;i++)
array[i]=i;
for(inti=0;i<length;i++)
intother=Random.Range(0,length);
intotherValue=array[other];
intvalue=array[i];
array[other]=value;
array[i]=otherValue;
publicstaticvoidRandomizeRange(thisint[]array,System.Randomrandom,intlength)
/*for(inti=0;i<length;i++)
array[i]=i;
*/
for(inti=0;i<length;i++)
intother=random.Range(0,length);
intotherValue=array[other];
intvalue=array[i];
array[other]=value;
array[i]=otherValue;
publicstaticvoidClear<T>(thisT[]array)
Array.Clear(array,0,array.Length);
publicstaticvoidCopyFrom<T>(thisT[]array,T[]other)
intcount=Mathf.Min(array.Length,other.Length);
for(inti=0;i<count;i++)
array[i]=other[i];
publicstaticclassboolExt
publicstaticboolKeySwitch(thisboolvalue,KeyCodekey,booldown=true)
return(down?Input.GetKeyDown(key):Input.GetKeyUp(key))?!value:value;
publicstaticintSignInt(thisboolvalue,intiValue)
returnvalue?iValue:-iValue;
publicstaticfloatSignFloat(thisboolvalue,floatfValue)
returnvalue?fValue:-fValue;
publicstaticclassbyteArrayExt
publicstaticbyte[]Jumble(thisbyte[]array)
intcount=array.Length;
for(inti=0;i<count;i++)
intother=(i+i)%count;
byteownByte=array[i];
byteswapByte=array[other];
array[i]=swapByte;
array[other]=ownByte;
returnarray;
publicstaticbyte[]UnJumble(thisbyte[]array)
intcount=array.Length;
intstart=count-1;
for(inti=start;i>-1;i--)
intother=(i+i)%count;
byteownByte=array[i];
byteswapByte=array[other];
array[i]=swapByte;
array[other]=ownByte;
returnarray;
publicstaticclassbyteExt
privatestaticbyteSet(thisbyteaByte,intpos,boolset)
if(set)
return(byte)(aByte|(1<<pos));
return(byte)(aByte&~(1<<pos));
publicstaticbyteSet(thisbyteaByte,boolvalueA,boolvalueB=false,boolvalueC=false,boolvalueD=false,boolvalueE=false,boolvalueF=false,boolvalueG=false,boolvalueH=false)
returnaByte.Set(0,valueA).
Set(1,valueB).
Set(2,valueC).
Set(3,valueD).
Set(4,valueE).
Set(5,valueF).
Set(6,valueG).
Set(7,valueH);
publicstaticboolGet(thisbyteaByte,intpos)
return(aByte&(1<<pos))!=0;
publicstaticclasscolorExt
publicstaticColorA(thisColorcolor,floatalpha)
returnnewColor(color.r,color.g,color.b,alpha);
publicstaticColorMulti(thisColorcolor,floatmulti)
returnnewColor(color.r*multi,color.g*multi,color.b*multi,color.a);
publicstaticstringToHex(thisColorcolor)
return"#"+ColorUtility.ToHtmlStringRGB(color);
publicstaticstringToHex(thisColor32color32)
return"#"+color32.r.ToString("X2")+color32.g.ToString("X2")+color32.b.ToString("X2");
privatestaticboolHasRGB(thisList<Color>list,Colorvalue)
intcount=list.Count;
for(inti=0;i<count;i++)
if(list[i].SameRGB(value,5))
returntrue;
returnfalse;
privatestaticboolSameRGB(thisColora,Colorb,intrange)
returnMathf.RoundToInt(a.r*255).CloserThan(Mathf.RoundToInt(b.r*255),range)&&
Mathf.RoundToInt(a.g*255).CloserThan(Mathf.RoundToInt(b.g*255),range)&&
Mathf.RoundToInt(a.b*255).CloserThan(Mathf.RoundToInt(b.b*255),range);
publicstaticvoidAddIfUniqueRGB(thisList<Color>list,Colorvalue)
if(!list.HasRGB(value))
list.Add(value);
publicstaticColorGamutTest(thisColorcolor,floatrT)
Vector2p1=Rot.Z(rT)*Vector2.up;
Vector2p2=Rot.Z(rT+120)*Vector2.up;
Vector2p3=Rot.Z(rT+240)*Vector2.up;
Linea=newLine(p1,p2);
Lineb=newLine(p2,p3);
Linec=newLine(p3,p1);
returncolor.ToHLS().MapGamut(a,b,c);
publicstaticColor32Multi(thisColor32color,Color32other)
Colora=color;
Colorb=other;
returnnewColor(a.r*b.r,a.g*b.g,a.b*b.b,a.a*b.a);
publicstaticColor32SetA(thisColor32color,bytea)
returnnewColor(color.r,color.g,color.b,a);
publicstaticfloatDist(thisColorcolor,Colorother)
returnMathf.Abs(color.r-other.r)+
Mathf.Abs(color.g-other.g)+
Mathf.Abs(color.b-other.b);
/*publicstaticfloatCheckDist(thisColorcolor,Colorother)
returnMathf.Sqrt(Mathf.Pow(color.r-other.r,2)+
Mathf.Pow(color.g-other.g,2)+
Mathf.Pow(color.b-other.b,2));
/*publicstaticfloatCheckDist(thisColorcolor,Colorother)
floaty1=.299f*color.r+.587f*color.g+.114f*color.b;
floaty2=.299f*other.r+.587f*other.g+.114f*other.b;
floatpB1=.168736f*color.r-.331264f*color.g+.5f*color.b;
floatpB2=.168736f*other.r-.331264f*other.g+.5f*other.b;
floatpR1=.5f*color.r-.418688f*color.g-.081312f*color.b;
floatpR2=.5f*other.r-.418688f*other.g-.081312f*other.b;
returnMathf.Sqrt(1.4f*Mathf.Pow(y1-y2,2)+.8f*Mathf.Sqrt(pB1-pB2)+.8f*Mathf.Sqrt(pR1-pR2));
publicstaticintClosestColorIndex(thisColorcolor,List<Color>list)
intbestIndex=0;
floatbestDist=float.MaxValue;
for(inti=0;i<list.Count;i++)
ColornewColor=list[i];
floatdist=newColor.Dist(color);
if(dist<bestDist)
bestDist=dist;
bestIndex=i;
returnbestIndex;
publicstaticfloatClosestColorDist(thisColorcolor,List<Color>list)
floatbestDist=float.MaxValue;
for(inti=0;i<list.Count;i++)
ColornewColor=list[i];
floatdist=newColor.Dist(color);
if(dist<bestDist)
bestDist=dist;
returnbestDist;
publicstaticintClosestColorIndex(thisColorcolor,Color[]array)
intbestIndex=0;
floatbestDist=float.MaxValue;
for(inti=0;i<array.Length;i++)
ColornewColor=array[i];
floatdist=newColor.Dist(color);
if(dist<bestDist)
bestDist=dist;
bestIndex=i;
returnbestIndex;
publicstaticfloatClosestColorDist(thisColorcolor,Color[]array)
floatbestDist=float.MaxValue;
for(inti=0;i<array.Length;i++)
ColornewColor=array[i];
floatdist=newColor.Dist(color);
if(dist<bestDist)
bestDist=dist;
returnbestDist;
publicstaticColorPerlinColor(thisColorcolor,floatx,floaty,floatmin=0)
floatmulti=1-min;
returnnewColor(min+Mathf.PerlinNoise(x*522.7f+46,y*865.312f+1653)*multi,
min+Mathf.PerlinNoise(x*6622.17f+846,y*865.312f+31153)*multi,
min+Mathf.PerlinNoise(x*2722.557f+2246,y*865.312f+99553)*multi,1);
publicstaticclassfloatExt
publicstaticfloatSignAdd(thisfloatvalue,floataddAmount)
returnvalue+Mathf.Sign(value)*addAmount;
publicstaticfloatAxis(thisfloatvalue,stringaxis,floatmulti)
returnvalue+Time.deltaTime*multi*Input.GetAxis(axis);
publicstaticfloatClamp(thisfloatvalue,floatmin=0,floatmax=1)
returnMathf.Clamp(value,min,max);
publicstaticfloatInvLerp(thisfloatvalue,floatmin,floatmax)
return(value-min)/(max-min);
publicstaticfloatRoundFrac(thisfloatvalue,floatfraction)
returnMathf.Round(value*(1/fraction))*fraction;
publicstaticfloatNaNChk(thisfloatvalue,floatdefaultValue=0)
returnfloat.IsNaN(value)?defaultValue:value;
publicstaticfloatEuler180(thisfloatvalue)
returnvalue>180?-(360-value):value;
publicstaticfloatWrap(thisfloatvalue,floatmin,floatmax)
value-=min;
floatlength=max-min;
returnvalue-Mathf.Floor(value/length)*length+min;
publicstaticfloatKey(thisfloatvalue,KeyCodekey,floatmulti)
returnInput.GetKey(key)?value+Time.deltaTime*multi:value;
publicstaticfloatKeySet(thisfloatvalue,KeyCodekey,floatnewValue,booldown=true)
return(down?Input.GetKeyDown(key):Input.GetKeyUp(key))?newValue:value;
publicstaticintIntSign(thisfloatvalue)
returnvalue>=0?1:-1;
publicstaticclassf
publicdelegateboolFloatCompare(floatvalueA,floatvalueB);
publicstaticreadonlyFloatCompareSame=Mathf.Approximately;
publicstaticclassgameobjectExt
publicstaticGameObjectSetName(thisGameObjectgameObject,stringname)
gameObject.name=name;
returngameObject;
publicstaticGameObjectSetPos(thisGameObjectgameObject,Vector3pos,boollocal=false)
if(local)
gameObject.transform.localPosition=pos;
else
gameObject.transform.position=pos;
returngameObject;
publicstaticGameObjectSetRot(thisGameObjectgameObject,Quaternionrot,boollocal=false)
if(local)
gameObject.transform.localRotation=rot;
else
gameObject.transform.rotation=rot;
returngameObject;
publicstaticGameObjectSetScale(thisGameObjectgameObject,floatx,floaty,floatz)
gameObject.transform.localScale=newVector3(x,y,z);
returngameObject;
publicstaticGameObjectSetParent(thisGameObjectgameObject,Transformparent,boolsetToZero=false)
gameObject.transform.SetParent(parent,!setToZero);
returngameObject;
publicstaticGameObjectSetLayerToAll(thisGameObjectgameObject,LayerMasklayermask)
gameObject.layer=layermask;
Transformtransform=gameObject.transform;
intcount=transform.childCount;
for(inti=0;i<count;i++)
SetLayerToAll(transform.GetChild(i).gameObject,layermask);
returngameObject;
publicstaticGameObjectCopyAndParent(thisGameObjectgameObject,boolonlyInEditor=false)
GameObjectnewGO=Object.Instantiate(gameObject);
if(!onlyInEditor||Application.isEditor)
newGO.transform.SetParent(gameObject.transform.parent);
returnnewGO;
publicstaticclassHashSetInit
publicstaticHashSet<int>Get(intcapacity)
HashSet<int>hashy=newHashSet<int>(Enumerable.Range(0,capacity).ToList());
hashy.Clear();
returnhashy;
publicstaticclassLinkedListInit
publicstaticLinkedList<int>Get(intcapacity)
LinkedList<int>linky=newLinkedList<int>();
for(inti=0;i<capacity;i++)
linky.AddLast(i);
linky.Clear();
returnlinky;
publicstaticclassintExt
staticintExt()
numStrings=newstring[maxStrings];
for(inti=0;i<maxStrings;i++)
numStrings[i]=i.ToString();
privateconstintmaxStrings=10000;
privatestaticreadonlystring[]numStrings;
publicstaticstringPrepString(thisintvalue)
returnvalue<maxStrings-1&&value>-1?numStrings[value]:value.ToString();
publicstaticstringPrepString(thisbytevalue)
returnvalue<maxStrings-1&&value>-1?numStrings[value]:value.ToString();
publicstaticstringRoundString(thisfloatvalue)
returnPrepString(Mathf.RoundToInt(value));
publicstaticintRepeat(thisintvalue,intmax)
return(int)Mathf.Repeat(value,max);
while(value<0)
value+=max;
returnvalue%max;
publicstaticintIndexUp(thisintindex,intlength)
if(index<length-1)
returnindex+1;
return0;
publicstaticintIndexDown(thisintindex,intlength)
if(index>0)
returnindex-1;
returnlength-1;
publicstaticboolCloserThan(thisinta,intb,intrange)
returnMathf.Abs(a-b)<=range;
publicstaticintNextPowerOfTwo(thisintvalue)
if(value==0)
return0;
intpower=1;
while(power<value)
power*=2;
returnpower;
publicstaticclasslistExt
publicstaticTGetAdd<T>(thisList<T>list,Tthing)
list.Add(thing);
returnthing;
publicstaticTGetRemoveAt<T>(thisList<T>list,intindex)
Tthing=list[index];
list.RemoveAt(index);
returnthing;
publicstaticTGetRemoveLast<T>(thisList<T>list)
intindex=list.Count-1;
Tthing=list[index];
list.RemoveAt(index);
returnthing;
publicstaticintMaxStringLength(thisList<string>list)
intlongest=0;
for(inti=0;i<list.Count;i++)
longest=Mathf.Max(longest,list[i].Length);
returnlongest;
publicstaticboolAddUnique<T>(thisList<T>list,Tthing)
if(!list.Contains(thing))
list.Add(thing);
returntrue;
returnfalse;
publicstaticstringLog(thisList<int>list)
stringvalue="";
intcount=list.Count,max=count-1;
for(inti=0;i<count;i++)
value+=list[i]+(i<max?"|":"");
returnvalue;
publicstaticstringLog(thisList<float>list)
stringvalue="";
intcount=list.Count,max=count-1;
for(inti=0;i<count;i++)
value+=list[i]+(i<max?"|":"");
returnvalue;
publicstaticstringLog(thisList<Color>list)
intcount=list.Count;
stringline="";
for(inti=0;i<count;i++)
line+="<color="+list[i].ToHex()+"></color>";
returnline;
publicstaticstringLog(thisList<Color32>list)
intcount=list.Count;
stringline="";
for(inti=0;i<count;i++)
line+="<color="+list[i].ToHex()+"></color>";
returnline;
publicstaticvoidCopyFrom<T>(thisList<T>list,List<T>other)
intcount=other.Count;
list.Clear();
for(inti=0;i<count;i++)
list.Add(other[i]);
publicstaticList<T>Randomize<T>(thisList<T>list)
intcount=list.Count;
for(inti=0;i<count;i++)
Tvalue=list[i];
intswitchWith=Random.Range(0,count);
list[i]=list[switchWith];
list[switchWith]=value;
returnlist;
publicstaticclassMeshExt
publicstaticMeshGetCombinedMesh(GameObjectgameObject)
returnGetMergedMesh(gameObject.GetComponentsInChildren<MeshFilter>(),gameObject.transform);
publicstaticMeshGetMergedMesh(MeshFilter[]meshFilters,Transformroot)
Vector3pivot=root.position;
List<Vector3>vertices=newList<Vector3>();
List<Vector3>normals=newList<Vector3>();
List<int>triangles=newList<int>();
List<Color32>colors=newList<Color32>();
for(inti=0;i<meshFilters.Length;i++)
Meshmesh=meshFilters[i].sharedMesh;
Transformtransform=meshFilters[i].transform;
Vector3[]verts=mesh.vertices;
Vector3[]norms=mesh.normals;
int[]tris=mesh.triangles;
Color32[]col=GetOrCreateMeshColors(mesh,false);
intoffset=vertices.Count;
for(intv=0;v<verts.Length;v++)
vertices.Add(root.InverseTransformPoint(transform.TransformPoint(verts[v])-pivot));
normals.Add(root.InverseTransformDirection(transform.TransformDirection(norms[v])));
for(intt=0;t<tris.Length;t++)
triangles.Add(offset+tris[t]);
Materialmat=transform.GetComponent<MeshRenderer>().sharedMaterial;
if(mat.name=="MainMat")
for(intc=0;c<col.Length;c++)
colors.Add(col[c]);
MeshcombinedMesh=newMesh();
combinedMesh.SetVertices(vertices);
combinedMesh.SetNormals(normals);
combinedMesh.SetTriangles(triangles,0);
if(colors.Count>0)
combinedMesh.SetColors(colors);
combinedMesh.RecalculateBounds();
returncombinedMesh;
privatestaticColor32[]GetOrCreateMeshColors(Meshmesh,boolimportedMesh)
Color32[]colors=mesh.colors32;
if(colors.Length>0)
if(importedMesh)
for(inti=0;i<colors.Length;i++)
colors[i]=newColor32(0,0,0,colors[i].r);
else
colors=newColor32[mesh.vertices.Length];
for(inti=0;i<colors.Length;i++)
colors[i]=newColor32(0,0,0,255);
returncolors;
publicstaticclassplacementExt
publicstaticPlacementZeroZ(thisPlacementp)
returnnewPlacement(p.pos.SetZ(0),p.rot);
publicstaticclassrandomExt
publicstaticfloatRange(thisSystem.Randomrand,floatmin,floatmax)
returnmin+(max-min)*((float)rand.Next()/int.MaxValue);
publicstaticintRange(thisSystem.Randomrand,intmin,intmax)
returnMathf.FloorToInt(min+(max-min)*((float)rand.Next()/int.MaxValue));
publicstaticboolChance(thisSystem.Randomrand,intchance,intmax)
returnrand.Range(0,max)<chance;
publicstaticclassrendererExt
publicstaticvoidSimplify(thisMeshRendererrenderer,booldisableShadows=true)
if(disableShadows)
renderer.shadowCastingMode=ShadowCastingMode.Off;
renderer.receiveShadows=false;
renderer.lightProbeUsage=LightProbeUsage.Off;
renderer.reflectionProbeUsage=ReflectionProbeUsage.Off;
renderer.motionVectorGenerationMode=MotionVectorGenerationMode.ForceNoMotion;
publicstaticvoidSimplify(thisSkinnedMeshRendererrenderer,booldisableShadows=true)
if(disableShadows)
renderer.shadowCastingMode=ShadowCastingMode.Off;
renderer.receiveShadows=false;
renderer.lightProbeUsage=LightProbeUsage.Off;
renderer.reflectionProbeUsage=ReflectionProbeUsage.Off;
renderer.motionVectorGenerationMode=MotionVectorGenerationMode.ForceNoMotion;
renderer.skinnedMotionVectors=false;
renderer.updateWhenOffscreen=true;
publicstaticclassserializeExt
publicstaticvoidWrite(thisBinaryWriterwriter,Vector2vector)
writer.Write(vector.x);
writer.Write(vector.y);
publicstaticVector2ReadVector2(thisBinaryReaderreader)
returnnewVector2(reader.ReadSingle(),reader.ReadSingle());
publicstaticvoidWrite(thisBinaryWriterwriter,Sideside)
writer.Write((sbyte)side.Sign);
publicstaticSideReadSide(thisBinaryReaderreader)
returnnewSide(reader.ReadSByte());
publicstaticclassStreamWriterExt
publicstaticvoidSpace(thisStreamWriteroutfile,intemptyLines)
for(inti=0;i<emptyLines;i++)
outfile.WriteLine("");
publicstaticclassstringbuilderExt
publicstaticStringBuilderNewLine(thisStringBuilderbuilder)
builder.Append("\n");
returnbuilder;
/*publicstaticvoidAppend(thisStringBuilderbuilder)
builder.Append("\n");
publicstaticclasstimespanExt
publicstaticfloatGetSeconds(thisTimeSpantimeSpan)
return(float)timeSpan.TotalSeconds;
publicstaticclasstransformExt
publicstaticTransformGetChild(thisTransformtrans,stringname,boolcontainsIsEnough=false)
Transform[]children=trans.GetComponentsInChildren<Transform>();
for(inti=0;i<children.Length;i++)
if(containsIsEnough?children[i].name.Contains(name):children[i].name==name)
returnchildren[i];
returnnull;
publicstaticvoidSetPlacement(thisTransformtrans,Placementplacement)
trans.position=placement.pos;
trans.rotation=placement.rot;
publicstaticclassvector2Ext
publicstaticfloatAngle_Sign(thisVector2dir1,Vector2dir2)
returnVector3.Angle(dir1,dir2)*dir1.Side_Sign(dir2);
publicstaticintSide_Sign(thisVector2vector1,Vector2vector2)
returnLeftOrRight(vector1,vector2)<0?-1:1;
privatestaticfloatLeftOrRight(Vector2A,Vector2B)
return-A.x*B.y+A.y*B.x;
publicstaticVector2Rot90(thisVector2v,boolcounterClockwise=true)
returncounterClockwise?newVector2(-v.y,v.x):newVector2(v.y,-v.x);
publicstaticVector2Rot90(thisVector2v,boolcounterClockwise,floatscale)
returncounterClockwise?newVector2(-v.y*scale,v.x*scale):newVector2(v.y*scale,-v.x*scale);
publicstaticVector2Rot(thisVector2v,floatdegrees)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=v.x;
floatty=v.y;
returnnewVector2(cos*tx-sin*ty,sin*tx+cos*ty);
publicstaticVector2Rot(thisVector2v,floatdegrees,floatscale)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=v.x*scale;
floatty=v.y*scale;
returnnewVector2(cos*tx-sin*ty,sin*tx+cos*ty);
publicstaticVector2RotRad(thisVector2v,floatradians)
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=v.x;
floatty=v.y;
returnnewVector2(cos*tx-sin*ty,sin*tx+cos*ty);
publicstaticVector3V3(thisVector2v2,floatz=0)
returnnewVector3(v2.x,v2.y,z);
publicstaticfloatCross(thisVector2a,Vector2b)
returna.x*b.y-a.y*b.x;
publicstaticVector2Cross(thisVector2a,floats)
returnnewVector2(s*a.y,-s*a.x);
publicstaticVector2Cross(thisfloats,Vector2a)
returnnewVector2(-s*a.y,s*a.x);
publicstaticVector2RangeChecked(thisVector2vector,floatmin,floatmax)
floatx=Mathf.Clamp(vector.x,min,max);
floaty=Mathf.Clamp(vector.y,min,max);
floatcenter=(x+y)*.5f;
returnnewVector2(Mathf.Min(center,x),Mathf.Max(center,y));
publicstaticfloatRadAngle(thisVector2dirA,Vector2dirB)
floatradA=Mathf.Atan2(dirA.y,dirA.x);
floatradB=Mathf.Atan2(dirB.y,dirB.x);
floatdiff=radB-radA;
if(diff>0)
returndiff<Mathf.PI?diff:-(Mathf.PI*2-diff);
returndiff>-Mathf.PI?diff:Mathf.PI*2+diff;
publicstaticVector2AimPos(thisVector2a,Vector2b,floatdistance)
floatvX=b.x-a.x;
floatvY=b.y-a.y;
floatmulti=1f/Mathf.Sqrt(vX*vX+vY*vY)*distance;
returnnewVector2(a.x+vX*multi,a.y+vY*multi);
publicstaticVector2SetLength(thisVector2a,floatlength)
floatmulti=1f/Mathf.Sqrt(a.x*a.x+a.y*a.y)*length;
returnnewVector2(a.x*multi,a.y*multi);
publicstaticfloatToRadian(thisVector2vector)
vector=vector.normalized;
returnMathf.Atan2(vector.y,vector.x).Wrap(0,2*Mathf.PI);
publicstaticVector2ToRadDir(thisfloatradian)
returnnewVector2(Mathf.Cos(radian),Mathf.Sin(radian));
publicstaticboolSame(thisVector2a,Vector2b)
floatx=b.x-a.x,y=b.y-a.y;
returnx*x+y*y<.000001f;
publicstaticboolIsNaN(thisVector2vector)
returnfloat.IsNaN(vector.x)||float.IsNaN(vector.y);
publicstaticclassVector2IntExt
publicstaticVector2IntToDir(thisVector2Intvalue)
intabsX=Mathf.Abs(value.x);
intabsY=Mathf.Abs(value.y);
intx=absX>absY?(int)Mathf.Sign(value.x):0;
inty=absX<absY?(int)Mathf.Sign(value.y):0;
returnnewVector2Int(x,y);
publicstaticVector2IntClamp(thisVector2Intvalue,intmax)
returnnewVector2Int(Mathf.Min(value.x,max),Mathf.Min(value.y,max));
publicstaticVector2IntAdd(thisVector2Intvalue,intx,inty)
returnnewVector2Int(value.x+x,value.y+y);
publicstaticVector2IntMin(thisVector2Intvalue,Vector2Intother)
returnnewVector2Int(Mathf.Min(value.x,other.x),Mathf.Min(value.y,other.y));
publicstaticVector2IntMax(thisVector2Intvalue,Vector2Intother)
returnnewVector2Int(Mathf.Max(value.x,other.x),Mathf.Max(value.y,other.y));
publicstaticVector2IntVector2IntFloor(thisVector2value)
returnnewVector2Int(Mathf.FloorToInt(value.x),Mathf.FloorToInt(value.y));
publicstaticVector2IntNormalized(thisVector2Intvalue)
returnnewVector2Int(Mathf.Clamp(value.x,-1,1),Mathf.Clamp(value.y,-1,1));
publicstaticVector2IntReverse(thisVector2Intvalue)
returnnewVector2Int(-value.x,-value.y);
publicstaticclassvector3Ext
publicstaticVector3MultiBy(thisVector3vector1,Vector3vector2)
returnnewVector3(vector1.x*vector2.x,vector1.y*vector2.y,vector1.z*vector2.z);
publicstaticVector3Scale(thisVector3vector,floatx=1,floaty=1,floatz=1)
returnnewVector3(vector.x*x,vector.y*y,vector.z*z);
publicstaticfloatLeftOrRight(Vector3A,Vector3B)
return-A.x*B.y+A.y*B.x;
publicstaticVector2V2(thisVector3v3)
returnnewVector2(v3.x,v3.y);
publicstaticVector2V2UseZ(thisVector3v3)
returnnewVector2(v3.x,v3.z);
publicstaticVector3Pow(thisVector3vector,floatpower)
returnnewVector3(Mathf.Pow(vector.x,power),Mathf.Pow(vector.y,power),Mathf.Pow(vector.z,power));
publicstaticVector3SetX(thisVector3vector,floatvalue)
returnnewVector3(value,vector.y,vector.z);
publicstaticVector3SetY(thisVector3vector,floatvalue)
returnnewVector3(vector.x,value,vector.z);
publicstaticVector3SetZ(thisVector3vector,floatvalue)
returnnewVector3(vector.x,vector.y,value);
publicstaticVector3AddX(thisVector3vector,floatvalue)
returnnewVector3(vector.x+value,vector.y,vector.z);
publicstaticVector3AddY(thisVector3vector,floatvalue)
returnnewVector3(vector.x,vector.y+value,vector.z);
publicstaticVector3AddZ(thisVector3vector,floatvalue)
returnnewVector3(vector.x,vector.y,vector.z+value);
publicstaticVector3FlipX(thisVector3vector)
returnnewVector3(-vector.x,vector.y,vector.z);
publicstaticVector3FlipY(thisVector3vector)
returnnewVector3(vector.x,-vector.y,vector.z);
publicstaticVector3FlipZ(thisVector3vector)
returnnewVector3(vector.x,vector.y,-vector.z);
publicstaticVector3MultiX(thisVector3vector,floatmulti)
returnnewVector3(vector.x*multi,vector.y,vector.z);
publicstaticVector3MultiY(thisVector3vector,floatmulti)
returnnewVector3(vector.x,vector.y*multi,vector.z);
publicstaticVector3MultiZ(thisVector3vector,floatmulti)
returnnewVector3(vector.x,vector.y,vector.z*multi);
publicstaticVector3MultiXY(thisVector3vector,floatmulti)
returnnewVector3(vector.x*multi,vector.y*multi,vector.z);
publicstaticVector3MultiXZ(thisVector3vector,floatmulti)
returnnewVector3(vector.x*multi,vector.y,vector.z*multi);
publicstaticVector3MultiYZ(thisVector3vector,floatmulti)
returnnewVector3(vector.x,vector.y*multi,vector.z*multi);
publicstaticboolCloseish(thisVector3a,Vector3b)
return(a-b).sqrMagnitude<.01f;
publicstaticVector3RotZ(thisVector3v,floatdegrees)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=v.x;
floatty=v.y;
returnnewVector3(cos*tx-sin*ty,sin*tx+cos*ty,v.z);
publicstaticVector3RotZ(thisVector3v,floatdegrees,floatmulti)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=v.x*multi;
floatty=v.y*multi;
returnnewVector3(cos*tx-sin*ty,sin*tx+cos*ty,v.z*multi);
publicstaticVector3RotY(thisVector3v,floatdegrees)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=-v.x;
floatty=-v.z;
returnnewVector3(cos*tx-sin*ty,v.y,sin*tx+cos*ty);
publicstaticVector3RotY(thisVector3v,floatdegrees,floatmulti)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=-v.x*multi;
floatty=-v.z*multi;
returnnewVector3(cos*tx-sin*ty,v.y*multi,sin*tx+cos*ty);
publicstaticVector3RotX(thisVector3v,floatdegrees)
floatradians=degrees*Mathf.Deg2Rad;
floatsin=Mathf.Sin(radians);
floatcos=Mathf.Cos(radians);
floattx=-v.z;
floatty=v.y;
returnnewVector3(v.x,sin*tx+cos*ty,-(cos*tx-sin*ty));
publicstaticvoidPrefsSave(thisVector3vector,stringname)
PlayerPrefs.SetFloat(name+"X",vector.x);
PlayerPrefs.SetFloat(name+"Y",vector.y);
PlayerPrefs.SetFloat(name+"Z",vector.z);
publicstaticVector3PrefsLoad(thisstringname)
returnnewVector3(PlayerPrefs.GetFloat(name+"X"),PlayerPrefs.GetFloat(name+"Y"),PlayerPrefs.GetFloat(name+"Z"));
publicstaticboolIsNaN(thisVector3vector)
returnfloat.IsNaN(vector.x)||float.IsNaN(vector.y)||float.IsNaN(vector.z);
publicclassEdgeMaster:Singleton<EdgeMaster>
publicGameObjectedgeA,edgeB,backA,backB,fill;
[Space(10)]
publicfloatfrontWidth;
publicfloatbackWidth;
privateMeshRendererfillRenderer,edgeRendererA,edgeRendererB,backRendererA,backRendererB;
privateboolfront,edgeVisible,backVisible;
privateintxEdgeStep,xBackStep,xFillStep;
privatestaticboolisActive=true;
privatevoidStart()
edgeRendererA=edgeA.GetComponent<MeshRenderer>();
edgeRendererB=edgeB.GetComponent<MeshRenderer>();
edgeA.transform.rotation=Quaternion.Euler(0,180,0);
backRendererA=backA.GetComponent<MeshRenderer>();
backRendererB=backB.GetComponent<MeshRenderer>();
backA.transform.rotation=Quaternion.Euler(0,180,0);
fillRenderer=fill.GetComponent<MeshRenderer>();
privatevoidLateUpdate()
if(!GameManager.Running||!isActive)
return;
boolcamFront=GameCam.CurrentSide.front;
booldifferentSide=camFront!=front;
front=camFront;
booledgeShouldBeVisible=GameCam.CurrentPos.y<110;
if(edgeShouldBeVisible!=edgeVisible)
edgeVisible=edgeShouldBeVisible;
edgeRendererA.enabled=edgeVisible;
edgeRendererB.enabled=edgeVisible;
fillRenderer.enabled=edgeVisible;
boolbackShouldBeVisible=GameCam.CurrentPos.y<250;
if(backShouldBeVisible!=backVisible)
backVisible=backShouldBeVisible;
backRendererA.enabled=backVisible;
backRendererB.enabled=backVisible;
floatcPos=GameCam.CurrentPos.x;
floatfocus=GameCam.frustum.focusPoint.x;
floatfrontX=cPos+(focus-cPos)*(ScreenControll.Landscape?8:3);
intcamXEdgeStep=Mathf.RoundToInt(frontX/frontWidth);
if(edgeVisible&&(differentSide||xEdgeStep!=camXEdgeStep))
EdgeUpdate(camXEdgeStep);
floatbackX=cPos+(focus-cPos)*(ScreenControll.Landscape?8:3)*2.5f;
intcamXBackStep=Mathf.RoundToInt(backX/backWidth);
if(backVisible&&(differentSide||xBackStep!=camXBackStep))
BackUpdate(camXBackStep);
privatevoidEdgeUpdate(intxStepPos)
xEdgeStep=xStepPos;
if(front)
edgeA.transform.position=newVector3(xEdgeStep*frontWidth,0,-Level.WallDepth);
else
edgeB.transform.position=newVector3(xEdgeStep*frontWidth,0,Level.WallDepth);
fill.transform.position=newVector3(xEdgeStep*frontWidth,0);
privatevoidBackUpdate(intxStepPos)
xBackStep=xStepPos;
if(front)
backA.transform.position=newVector3(xBackStep*backWidth,0,Level.WallDepth);
else
backB.transform.position=newVector3(xBackStep*backWidth,0,-Level.WallDepth);
publicstaticvoidSetActive(boolactive)
if(isActive!=active)
isActive=active;
Inst.fillRenderer.enabled=isActive;
Inst.edgeRendererA.enabled=isActive;
Inst.edgeRendererB.enabled=isActive;
Inst.backRendererA.enabled=isActive;
Inst.backRendererB.enabled=isActive;
if(isActive)
Inst.xEdgeStep=int.MinValue;
Inst.xBackStep=int.MinValue;
Inst.xFillStep=int.MinValue;
privatestaticMeshRepeatMesh(MeshsourceMesh,intcount,floatwidth)
Vector3[]sourceV=sourceMesh.vertices;
Vector3[]sourceN=sourceMesh.normals;
Color32[]sourceC=sourceMesh.colors32;
int[]sourceT=sourceMesh.triangles;
List<Vector3>verts=newList<Vector3>();
List<Vector3>norms=newList<Vector3>();
List<Color32>cols=newList<Color32>();
List<int>tris=newList<int>();
floatxOffset=(count-1f)*-.5f*width;
for(inti=0;i<count;i++)
Vector3offset=newVector3(xOffset+i*width,0,0);
for(inte=0;e<sourceV.Length;e++)
verts.Add(sourceV[e]+offset);
norms.Add(sourceN[e]);
cols.Add(sourceC[e]);
inttOffset=sourceV.Length*i;
for(inte=0;e<sourceT.Length;e++)
tris.Add(sourceT[e]+tOffset);
Meshmesh=newMesh();
mesh.SetVertices(verts);
mesh.SetTriangles(tris,0);
mesh.SetNormals(norms);
mesh.SetColors(cols);
mesh.RecalculateBounds();
returnmesh;
publicclassWallHole:MonoBehaviour
privateboolfront;
privateVector3pos;
privatevoidOnEnable()
pos=transform.position;
UpdateHole();
privatevoidUpdateHole()
transform.position=pos.SetZ(front?-Level.WallDepth:Level.WallDepth);
transform.rotation=Rot.Y(front?180:0);
privatevoidLateUpdate()
if(GameCam.CurrentSide.front!=front)
front=!front;
UpdateHole();
[CreateAssetMenu]
publicclassSceneLightLerp:ScriptableObject
[System.Serializable]
publicclassSettingsLerp
privatestatic_SceneLightingblendLighting;
publicstatic_SceneLightingBlendLighting
get
if(blendLighting==null)
blendLighting=Resources.Load<_SceneLighting>("Light/Blend");
returnblendLighting;
publicVector2range;
public_SceneLightinga,b;
[Space(10)]
publicintpow;
publicboolinversePow;
publicboolGetBlend(floatlerp)
if(lerp>=range.x&&lerp<=range.y)
lerp=Mathf.InverseLerp(range.x,range.y,lerp);
if(inversePow)
lerp=1-Mth.IntPow(1-lerp,pow);
else
lerp=Mth.IntPow(lerp,pow);
BlendLighting.SetBlendBetween(a,b,lerp);
returntrue;
returnfalse;
publicSettingsLerp[]lerps;
publicvoidSetLerpedLighting(floatlerp)
for(inti=0;i<lerps.Length;i++)
if(lerps[i].GetBlend(lerp))
LightingSet.SetSceneLighting(SettingsLerp.BlendLighting);
return;
publicvoidSetLerpedLighting(floatlerp,QuaternionsunRot)
for(inti=0;i<lerps.Length;i++)
if(lerps[i].GetBlend(lerp))
SettingsLerp.BlendLighting.SetRot(sunRot);
LightingSet.SetSceneLighting(SettingsLerp.BlendLighting);
LightingSet.SetSunRot(sunRot);
return;
[CanEditMultipleObjects]
[CustomEditor(typeof(_SceneLighting))]
publicclassSceneLightingEditor:Editor
publicoverridevoidOnInspectorGUI()
_SceneLightingmyTarget=(_SceneLighting)target;
if(GUILayout.Button("OverridefromScene"))
myTarget.OverrideFromScene();
EditorUtility.SetDirty(myTarget);
EditorGUILayout.Space();
DrawDefaultInspector();
EditorGUILayout.Space();
if(GUILayout.Button("SetToScene"))
myTarget.SetToScene();
EditorUtility.SetDirty(myTarget);
[CreateAssetMenuAttribute(menuName="Scriptable/SceneLighting")]
publicclass_SceneLighting:ScriptableObject
publicVector2sunAngle;
publicColorsunColor;
publicfloatsunIntensity;
[Space(10)]
publicColorskyColor;
publicColorambientColor;
publicColorfogColor;
[Space(10)]
[Range(0,1)]
publicfloatshadowBrightness;
[Range(0,1)]
publicfloatshadowVisibility=1;
publicvoidOverrideFromScene()
LightingSet.GetSceneLight(this);
publicvoidSetToScene()
LightingSet.SetSceneLighting(this);
publicvoidSetBlendBetween(_SceneLightinga,_SceneLightingb,floatlerp)
sunColor=Color.Lerp(a.sunColor,b.sunColor,lerp);
sunIntensity=Mathf.Lerp(a.sunIntensity,b.sunIntensity,lerp);
skyColor=Color.Lerp(a.skyColor,b.skyColor,lerp);
ambientColor=Color.Lerp(a.ambientColor,b.ambientColor,lerp);
fogColor=Color.Lerp(a.fogColor,b.fogColor,lerp);
shadowBrightness=Mathf.Lerp(a.shadowBrightness,b.shadowBrightness,lerp);
shadowVisibility=Mathf.Lerp(a.shadowVisibility,b.shadowVisibility,lerp);
sunAngle=Vector2.Lerp(a.sunAngle,b.sunAngle,lerp);
publicvoidSetRot(Quaternionrot)
sunAngle=rot.eulerAngles;
[CreateAssetMenu(menuName="Scriptable/SoundPack")]
publicclass_SoundPack:ScriptableObject
publicAudioClip[]musicClips;
[Space(10)]
publicAudioClip[]ambientClips;
[Space(10)]
publicAudioClip[]uiClips;
[Space(10)]
publicAudioClip[]reactorClips;
[Space(10)]
publicAudioClip[]soundClips;
publicclassOwnBounds:Singleton<OwnBounds>
/*publicreadonlyList<ClipBounds>clipBounds=newList<ClipBounds>(1000);
publicreadonlyClipBoundPoolpool=newClipBoundPool(1000);
publicboolshowBounds;
privatevoidUpdate()
if(!GameManager.Running)
return;
floatrewindTime=GTime.Now-GTime.RewindTime;
Clipclip=Spinner.CurrentFocusClip;
while(true)
Clipbefore=clip.before;
if(before!=null&&before.startTime>=rewindTime)
clip=before;
else
break;
Clipbefore=clip.before;
if(before!=null)
clip=before;
while(clip!=null)
clip.GetClipBounds(pool);
pool.AddToList(clipBounds);
clip=clip.after;
if(clip!=null&&clip.startTime>GTime.Now)
clip=null;
if(showBounds)
for(inti=0;i<clipBounds.Count;i++)
ClipBoundscB=clipBounds[i];
if(cB.endTime>=rewindTime&&cB.startTime<=GTime.Now)
Colorc;
switch(cB.type)
default:c=COLOR.red.tomato;break;
caseClipType.Swing:c=COLOR.green.lime;break;
caseClipType.Spawn:c=COLOR.yellow.fresh;break;
caseClipType.Bump:c=COLOR.purple.orchid;break;
if(i==clipBounds.Count-1||clipBounds[i+1].startTime>GTime.Now)
c=Color.Lerp(Color.white,c,.5f);
floatlerp=1-Mathf.InverseLerp(rewindTime,GTime.Now,cB.endTime);
floatfade=(1-Mth.IntPow(lerp,14))*(1-Mth.IntPow(lerp,2));
cB.bounds.Draw().SetColor(c.A(fade)).SetDepth(cB.side.Float(Z.W05)).Fill(.1f*fade);
publicfloatmin{get;set;}
publicfloatmax{get;set;}*/
/*
publicclassReplayFun:MonoBehaviour
publicstaticstringState;
publicReplayGettergetter;
[Space(10)]
publicboolshowBounds;
privateReplayGetter.StatecurrentState=ReplayGetter.State.Sleeping;
privatevoidOnEnable()
GameManager.onGameStart+=GameManagerOnOnGameStart;
privatevoidOnDisable()
GameManager.onGameStart-=GameManagerOnOnGameStart;
privatevoidGameManagerOnOnGameStart()
if(currentState==ReplayGetter.State.Playing)
getter.Disable();
privatevoidStart()
State=currentState.ToString().Replace("_","");
StartCoroutine(Database.GetScoreCount());
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.F))
getter.GetReplay(this);
ReplayGetter.StatenewState=getter.state;
if(newState!=currentState)
currentState=newState;
State=currentState.ToString().Replace("_","");
if(currentState==ReplayGetter.State.Playing)
getter.PlayUpdate();
if(showBounds&&currentState==ReplayGetter.State.Got_Bounds)
for(inti=0;i<getter.clipBounds.Count;i++)
ClipBoundscB=getter.clipBounds[i];
Colorc;
switch(cB.type)
default:c=COLOR.red.tomato;break;
caseClipType.Swing:c=COLOR.green.lime;break;
caseClipType.Spawn:c=COLOR.yellow.fresh;break;
caseClipType.Bump:c=COLOR.purple.orchid;break;
cB.bounds.Draw().SetColor(c).SetDepth(cB.side.Float(Z.W05)).Fill(.1f);
*/
[Serializable]
publicclassReplayGetter
/*publicByteReplayreplay;
publicreadonlyClipBoundPoolpool=newClipBoundPool(1000);
publicBinaryReaderreader;
publicreadonlyList<ClipBounds>clipBounds=newList<ClipBounds>(1000);
publicenumState{Sleeping,Getting_Replay,Got_Replay,Getting_Bounds,Got_Bounds,Playing}
publicStatestate;
[Space(10)]
publicbyte[]replayBytes;
privateintbyteCount;
privatereadonlyList<int>goodBounds=newList<int>();
publicconstintspinnerID=1;
publicvoidGetReplay(MonoBehaviourmB)
if(state==State.Playing)
Disable();
state=State.Getting_Replay;
mB.StartCoroutine(ReplaySaveLoad.GetReplayBytes(SetBytes));
publicvoidSetBytes(byte[]byteArray)
state=State.Got_Replay;
replayBytes=byteArray;
DeserializeBounds();
Spawn();
privatevoidDeserializeBounds()
Profiler.BeginSample("DeserializingBounds");
state=State.Getting_Bounds;
reader=newBinaryReader(m);
ByteReplayreplay=ByteReplays.GetFree;
replay.ParseBytes(reader);
ClipswingClip=null;
for(inti=0;i<replay.clipCount;i++)
sbytetypeAndSide=reader.ReadSByte();
ClipTypeclipType=(ClipType)Mathf.Abs(typeAndSide);
Sideside=newSide(typeAndSide<0);
byteCount=(int)reader.BaseStream.Position;
Clipclip=Clip.DeserializeBounds(this,clipType,side);
byteCount=(int)reader.BaseStream.Position;
if(clipType==ClipType.Jump)
if(swingClip!=null)
swingClip.duration=clip.startTime-swingClip.startTime;
swingClip.GetClipBounds(pool);
swingClip=null;
Jumpjump=(Jump)clip;
switch(jump.next)
caseClipType.Swing:
swingClip=Clip.Get_Clip_Swing(jump);
break;
caseClipType.Bump:
ClipbumpClip=Clip.Get_Bump(jump);
bumpClip.GetClipBounds(pool);
break;
state=State.Got_Bounds;
Profiler.EndSample();
publicvoidSpawn()
Profiler.BeginSample("Spawning");
goodBounds.Clear();
floatreplayEnd=clipBounds[clipBounds.Count-1].startTime-20;
for(inti=0;i<clipBounds.Count;i++)
if(clipBounds[i].startTime<replayEnd&&clipBounds[i].side==GameCam.CurrentSide&&
(clipBounds[i].bounds.Intersects(GameCam.frustum.frontBounds)||
clipBounds[i].bounds.Intersects(GameCam.frustum.backBounds)))
goodBounds.Add(i);
if(goodBounds.Count==0)
state=State.Sleeping;
Profiler.EndSample();
return;
intpick=0;
floatclosest=float.MaxValue;
Vector2camCenter=(GameCam.frustum.frontBounds.Center+GameCam.frustum.backBounds.Center)*.5f;
for(inti=0;i<goodBounds.Count;i++)
Vector2center=clipBounds[goodBounds[i]].bounds.Center;
floatdist=(center-camCenter).sqrMagnitude;
if(dist<closest)
closest=dist;
pick=i;
intstartBound=goodBounds[pick];
floatstartTime=clipBounds[startBound].startTime;
floatshift=0;
while(startTime+shift<GTime.Now)
shift+=GTime.LoopTime;
while(startTime+shift>GTime.Now)
shift-=GTime.LoopTime;
Tape.Get(spinnerID).Clear();
Spinner.Get(spinnerID).Enable(replay.charName,replay.costume,Brain.Player);
Tape.AddReplay(spinnerID,ReplaySaveLoad.DeserializeReplay(spinnerID,replayBytes));
Tape.Get(spinnerID).SetTimeShift(shift);
state=State.Playing;
Profiler.EndSample();
publicvoidPlayUpdate()
ClipcurrentClip=Tape.Get(spinnerID).GetClip(GTime.Now);
if(currentClip==null||currentClip.Type==0)
Disable();
publicvoidDisable()
Spinner.Get(spinnerID).Disable();
Tape.Get(spinnerID).Clear();
Boundary.Clear(spinnerID);
state=State.Sleeping;
[Serializable]
publicclassClipBounds:PoolObject
publicconstfloatSearchStep=1f,Forever=10000,ForwardLook=((int)(GTime.RewindTime/SearchStep)+1)*SearchStep;
publicintstartByte;
publicfloatstartTime,endTime;
publicClipTypetype;
publicSideside;
publicBounds2Dbounds=newBounds2D();
publicClipBoundsSet(floatstartTime,floatendTime,ClipTypetype,Sideside)
this.startTime=startTime;
this.endTime=endTime;
this.type=type;
this.side=side;
returnthis;
publicClipBoundsSet(intstartByte)
this.startByte=startByte;
returnthis;
publicClipBoundsSetStartByte(intstartByte)
this.startByte=startByte;
returnthis;
publicboolActiveAt(floattime)
returnendTime>startTime?startTime<=time&&endTime>time:startTime<=time;
publicboolIntersects(ClipBoundsother)
returnside==other.side&&startTime<=other.endTime&&other.startTime<=endTime&&bounds.Intersects(other.bounds);
publicvoidDraw(floatalpha)
bounds.Draw().SetColor(type.Color().A(alpha)).SetDepth(Mathf.Abs(Z.W05)*side.Sign).Fill(alpha*.25f);
/*[Serializable]
publicclassClipBoundPool
publicClipBoundPool(intcapacity)
pool=newPool<ClipBounds>(()=>newClipBounds(),capacity);
newBounds=newList<ClipBounds>(capacity);
publicreadonlyPool<ClipBounds>pool;
publicreadonlyList<ClipBounds>newBounds;
publicfloatmin{privateset;get;}
publicfloatmax{privateset;get;}
publicvoidSetup(floatmin,floatmax)
this.min=min;
this.max=max;
newBounds.Clear();
publicClipBoundsGet
get
ClipBoundscB=pool.GetFree();
newBounds.Add(cB);
returncB;
publicvoidReturn(ClipBoundsbounds)
pool.Return(bounds);
publicintAddToList(List<ClipBounds>list)
intcount=newBounds.Count;
for(inti=0;i<count;i++)
list.Add(newBounds[i]);
returncount;
/*
publicclassEditorFrame:Singleton<EditorFrame>
publicInspectorHeaderheaderA=newInspectorHeader("PressF12forSpinnerFollow");
publicInspectorHeaderheaderB=newInspectorHeader("PressforZoomChange");
privateintZoomLevel
get{returnPlayerPrefs.GetInt("EditorFrame");}
set{PlayerPrefs.SetInt("EditorFrame",value);}
privatestaticVector3zoomLevels=newVector3(4,10,24);
privatestaticTransformFollowThis{get{returnSpinner.Focus.Transform;}}
privatestaticboolfocused;
privateboolframeCharacter;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.F12))
frameCharacter=!frameCharacter;
if(!frameCharacter)
return;
if(Input.GetKeyDown(KeyCode.F11))
ZoomLevel=(ZoomLevel+1)%3;
if(FollowThis==null||!focused)
return;
constfloatfollowSpeed=4;
transform.position=Vector3.Lerp(transform.position,FollowThis.position,Time.deltaTime*followSpeed);
floatscale=CurrentZoom;
transform.localScale=newVector3(scale,scale,scale);
GameObjectbefore=UnityEditor.Selection.activeGameObject;
UnityEditor.Selection.activeGameObject=gameObject;
SceneView.lastActiveSceneView.FrameSelected();
UnityEditor.Selection.activeGameObject=before;
privatevoidOnApplicationFocus(boolfocus)
focused=focus;
privatefloatCurrentZoom
get
switch(ZoomLevel)
default:return0;
case0:returnzoomLevels.x;
case1:returnzoomLevels.y;
case2:returnzoomLevels.z;
*/
publicclassBounceLight:Shadow
publicColorcolor;
publicfloatmulti;
protectedoverridevoidUpdateTransform()
UpdateBounceColor();
_transform.rotation=LightingSet.BounceRot;
publicvoidSetColor(Colorcolor)
this.color=color;
UpdateBounceColor();
privatevoidUpdateBounceColor()
floatfactor=multi*(front?1:.5f);
spriteRenderer.color=newColor(color.r*LightingSet.SunColor.r*factor,
color.g*LightingSet.SunColor.g*factor,
color.b*LightingSet.SunColor.b*factor,0);
publicclassCastShadow:Shadow
[Space(10)]
publicActoractor;
publicfloatscale=1;
protectedoverridevoidUpdateTransform()
Vector3shadowDir=LightingSet.ShadowDir;
Vector3tipOffset=actor.TipOffset;
floatvectorMulti=Mathf.Abs(tipOffset.z/Mathf.Abs(shadowDir.z));
Vector2offset=newVector2(shadowDir.x*vectorMulti-tipOffset.x,shadowDir.y*vectorMulti-tipOffset.y);
_transform.rotation=VectorRot(offset);
constfloatmulti=1f/(256f/20);
_transform.localScale=newVector3(scale*.95f,offset.magnitude*multi*scale,scale);
publicclassCoinShadow:Shadow
[Space(10)]
publicfloatscale=1;
publicTransformactor;
privateVector3oldShadowDir,offset;
protectedoverridevoidUpdateTransform()
Vector3shadowDir=LightingSet.ShadowDir;
if(oldShadowDir!=shadowDir)
Vector3tipOffset=Vector3.forward*Level.PlaneOffset;
floatvectorMulti=Mathf.Abs(tipOffset.z/Mathf.Abs(shadowDir.z));
offset=newVector2(shadowDir.x*vectorMulti-tipOffset.x,shadowDir.y*vectorMulti-tipOffset.y);
oldShadowDir=shadowDir;
_transform.localPosition=offset*.8f;
_transform.rotation=VectorRot(offset);
Vector3pos=actor.position;
floatanimOffset=pos.x*2+pos.y*2;
floatsqueeze=GTime.Now*GTime.LoopMulti*32+animOffset*4/360*4;
floatsqueezeFactor=Mathf.SmoothStep(1f,.7f,Mathf.Pow(Mathf.PingPong(squeeze,1),1.5f));
floatxDot=Mathf.SmoothStep(0,1,Mathf.Abs((_transform.rotation*V2.right).x));
constfloatmulti=1f/(128f/20);
_transform.localScale=newVector3(scale*Mathf.Lerp(1,squeezeFactor,xDot),
(scale+offset.magnitude*multi*scale)*Mathf.Lerp(squeezeFactor,1,xDot),
scale);
publicclassContactShadow:Shadow
protectedoverridevoidUpdateTransform(){}
publicclassNewContactShadow:Shadow
protectedoverridevoidUpdateTransform(){}
protectedoverridevoidSetLayerAndSprite()
gameObject.layer=front?Layers.ShadowA:Layers.ShadowB;
publicclassNewSpinnerShadow:MonoBehaviour
publicMeshFiltermF;
privateMeshmesh;
privateVector3size;
privateboolcast;
privatereadonlyList<Vector2>uvs=newList<Vector2>{V2.zero,V2.zero,V2.zero,V2.zero};
privatereadonlyList<Vector2>uvs1=newList<Vector2>{V2.zero,V2.zero,V2.zero,V2.zero};
privatereadonlyList<Vector2>uvs2=newList<Vector2>{V2.zero,V2.zero,V2.zero,V2.zero};
privatereadonlyList<Color32>colors=newList<Color32>{Color.white,Color.white,Color.white,Color.white};
privatebooluseOffset;
privatevoidAwake()
mF.mesh=mesh=newMesh();
mesh.SetVertices(newList<Vector3>{newVector2(.5f,-.5f),newVector2(-.5f,-.5f),newVector2(.5f,.5f),newVector2(-.5f,.5f)});
mesh.SetTriangles(new[]{0,1,2,2,1,3},0);
mesh.SetUVs(0,uvs);
mesh.SetUVs(1,uvs1);
mesh.SetUVs(2,uvs2);
mesh.bounds=newBounds(V3.zero,newVector3(1,1,0));
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.O))
useOffset=!useOffset;
publicvoidUpdateTransform(Vector2pos,floatbend,floatturn,floatangle,Vector3squash)
if(cast)
Vector3shadowDir=LightingSet.ShadowDir;
Vector3tipOffset=Vector3.forward*Level.PlaneOffset;
floatvectorMulti=Mathf.Abs(tipOffset.z/Mathf.Abs(shadowDir.z));
Vector2offset=newVector2(shadowDir.x*vectorMulti-tipOffset.x,shadowDir.y*vectorMulti-tipOffset.y);
pos+=offset+(useOffset?newVector2(4,0):V2.zero);
transform.position=pos;
transform.localScale=V3.one*(size.y*squash.y+16);
for(inti=0;i<4;i++)uvs[i]=pos;
mesh.SetUVs(0,uvs);
floatradius=1/(Mathf.Sign(bend)*Mathf.Max(.01f,Mathf.Abs(bend)))/2/Mth.*size.y;
Vector2radii=newVector2(radius,angle);
for(inti=0;i<4;i++)uvs1[i]=radii;
mesh.SetUVs(1,uvs1);
floatthickLerp=Mth.SmoothPP(size.x*squash.x,size.z*squash.z,Mathf.Repeat(turn,1)*4)*.25f;
Vector2hT=newVector2(size.y*squash.y*.5f,thickLerp);
for(inti=0;i<4;i++)uvs2[i]=hT;
mesh.SetUVs(2,uvs2);
publicvoidSetup(boolcast,Vector3size)
this.cast=cast;
constbytemaxVis=106;
Color32pickVis=newColor32((byte)(cast?maxVis:0),(byte)(cast?0:maxVis),0,0);
for(inti=0;i<4;i++)colors[i]=pickVis;
mesh.SetColors(colors);
this.size=size;
publicclassProbeShadow:Shadow
[Space(10)]
publicfloatscale=1;
privateVector3oldShadowDir;
protectedoverridevoidUpdateTransform()
Vector3shadowDir=LightingSet.ShadowDir;
if(oldShadowDir!=shadowDir)
oldShadowDir=shadowDir;
Vector3tipOffset=Vector3.forward*Level.PlaneOffset;
floatvectorMulti=Mathf.Abs(tipOffset.z/Mathf.Abs(shadowDir.z));
Vector2offset=newVector2(shadowDir.x*vectorMulti-tipOffset.x,shadowDir.y*vectorMulti-tipOffset.y);
_transform.localPosition=offset*.8f;
_transform.rotation=VectorRot(offset);
constfloatmulti=1f/(128f/20);
_transform.localScale=newVector3(scale,scale+offset.magnitude*multi*scale,scale);
publicabstractclassShadow:MonoBehaviour
publicSpriteRendererspriteRenderer;
publicSprite[]sprites;
publicboolisLight;
protectedboolfront=true;
protectedTransform_transform;
privatevoidAwake()
_transform=transform;
SetLayerAndSprite();
publicvoidSetSide(boolfront)
if(this.front!=front)
this.front=front;
SetLayerAndSprite();
protectedvirtualvoidSetLayerAndSprite()
if(sprites.Length>0)
spriteRenderer.sprite=sprites[front?0:1];
gameObject.layer=isLight?front?Layers.LightA:Layers.LightB:
front?Layers.ShadowA:Layers.ShadowB;
publicvoidShadowUpdate(boolupdateTransform)
if(front==GameCam.CurrentSide.front&&updateTransform)
UpdateTransform();
protectedabstractvoidUpdateTransform();
protectedstaticQuaternionVectorRot(Vector2vector)
returnRot.Z(Mathf.Atan2(vector.x,vector.y)*-Mathf.Rad2Deg);
publicclassSpinnerContact:SpinnerShadow
protectedoverridevoidUpdateTransform()
Clipclip=spinner.currentClip;
if(clip==null)
return;
Vector2offset=(clip.GetSide(GTime.Now).front?-1:1)*Level.PlaneOffset*LightingSet.SunXFactor/MapCam.mapSizeA*5;
Placementplacement=clip.BasicPlacement(GTime.Now,true);
_transform.position=placement.pos.V2()+offset;
_transform.rotation=placement.rot;
publicoverridevoidSetup(Vector3size)
wideFactor=size.x/size.z;
constfloatmulti=1.75f;
_transform.localScale=this.size=newVector3(.5f/.5f*multi,2.56466f/size.y*multi,1);
publicclassSpinnerShadow:Shadow
[Space(10)]
publicSpinnerspinner;
protectedVector3size;
protectedfloatwideFactor;
protectedoverridevoidUpdateTransform()
Clipclip=spinner.currentClip;
if(clip==null)
return;
Placementplacement=clip.BasicPlacement(GTime.Now,true);
Vector3toWall=LightingSet.ShadowDir*((Level.PlaneOffset+clip.spinner.GetZShift(GTime.Now))*(front?1:-1)/LightingSet.ShadowDir.z);
_transform.position=newVector2(placement.pos.x+toWall.x,placement.pos.y+toWall.y);
_transform.rotation=placement.rot;
publicvirtualvoidSetup(Vector3size)
wideFactor=size.x/size.z;
_transform.localScale=this.size=newVector3(1,2.56466f/size.y,1);
publicvoidManualUpdate(boolfront,floatturn,Vector3squash)
constfloatturnMulti=1f/360;
floatlerp=Mathf.PingPong(Mathf.Repeat(turn*turnMulti,1)*4,1);
floatwideness=Mathf.Lerp(wideFactor,1,lerp);
_transform.localScale=Vector3.Lerp(size,size.MultiBy(squash),.5f).MultiX(wideness);
SetSide(front);
ShadowUpdate(true);
publicclassSpinnerSpineShadow:MonoBehaviour
[Switch("Char/ShadowMesh")]privatestaticboolshowShadowMesh=false;
publicSpritesprite;
publicMeshFilterfilter;
publicMeshRenderermeshRenderer;
privateMeshmesh;
privatereadonlyint[]map=newint[meshPointCount];
privatereadonlyVector3[]offsets=newVector3[meshPointCount];
privatereadonlyList<Vector3>verts=newList<Vector3>();
privatereadonlyList<Vector2>uvs=newList<Vector2>();
privateList<int>triangles;
privatefloatcurrentHeight;
privateconstintpointCount=70;
privatereadonlyVector3[]castPoints=newVector3[pointCount];
privatereadonlyQuaternion[]contactRot=newQuaternion[pointCount];
privateconstintcolumns=50;
privateconstintmeshPointCount=(pointCount+2)*columns;
privatevoidAwake()
meshRenderer.SetPropertyBlock(LightManager.PropBlock);
mesh=newMesh();
filter.mesh=mesh;
verts.Clear();
uvs.Clear();
List<Vector3>normals=newList<Vector3>(meshPointCount);
List<Color32>colors=newList<Color32>(meshPointCount);
for(inti=0;i<meshPointCount;i++)
verts.Add(V3.zero);
uvs.Add(V2.zero);
normals.Add(V3.back);
colors.Add(newColor32(255,0,0,0));
triangles=newList<int>();
for(inti=0;i<meshPointCount-columns;i+=columns)
for(inte=0;e<columns-1;e++)
triangles.Add(i+e);
triangles.Add(i+e+1);
triangles.Add(i+e+columns);
triangles.Add(i+e+columns+1);
triangles.Add(i+e+columns);
triangles.Add(i+e+1);
mesh.SetVertices(verts);
mesh.SetNormals(normals);
mesh.SetTriangles(triangles,0);
mesh.SetColors(colors);
mesh.bounds=newBounds(V3.zero,V3.one*100000);
for(inti=0;i<meshPointCount;i+=columns)
intmapIndex=(int)Mathf.Clamp((float)i/columns-1,0,pointCount-1);
for(inte=0;e<columns;e++)
map[i+e]=mapIndex;
publicvoidPosePoints(RigPoserposer)
if(!f.Same(poser.height,currentHeight))
CalcSpriteSizes(poser.height);
Transformparent=poser.transform;
floatsign=Mathf.Sign(poser.transform.position.z);
Vector3shadowDir=LightingSet.ShadowDir;
floatzOffset=Mathf.Abs(parent.position.z)-Level.WallDepth;
Vector3castShift=shadowDir*(zOffset*-sign/shadowDir.z);
floatheight=poser.height*poser.squashScale.y;
floatstep=height/(pointCount-1);
for(inti=0;i<pointCount;i++)
Placementplc=poser.GetBendPlacement(newVector3(0,-height*.5f+step*i,0));
castPoints[i]=castShift+parent.TransformPoint(plc.pos);
contactRot[i]=Quaternion.FromToRotation(V3.up,(parent.rotation*plc.rot*V3.up).SetZ(0).normalized);
for(inti=0;i<meshPointCount;i++)
verts[i]=castPoints[map[i]]+contactRot[map[i]]*offsets[i];
mesh.SetVertices(verts);
if(!showShadowMesh)
return;
floatz=(Level.WallDepth+.025f)*sign;
DRAW.Line(castPoints).SetColor(COLOR.red.tomato).SetDepth(z);
ColorcA=COLOR.green.spring.A(.5f);
ColorcB=COLOR.yellow.fresh.A(.5f);
for(inti=0;i<triangles.Count;i+=3)
Colorc=Color.Lerp(cA,cB,(float)i/triangles.Count);
DRAW.Vector(verts[triangles[i]],verts[triangles[i+1]]-verts[triangles[i]]).SetDepth(z).SetColor(c);
DRAW.Vector(verts[triangles[i+1]],verts[triangles[i+2]]-verts[triangles[i+1]]).SetDepth(z).SetColor(c);
DRAW.Vector(verts[triangles[i+2]],verts[triangles[i]]-verts[triangles[i+2]]).SetDepth(z).SetColor(c);
privatevoidCalcSpriteSizes(floatheight)
currentHeight=height;
floatminU=float.MaxValue,minV=float.MaxValue,maxU=float.MinValue,maxV=float.MinValue;
for(inti=0;i<sprite.uv.Length;i++)
minU=Mathf.Min(minU,sprite.uv[i].x);
minV=Mathf.Min(minV,sprite.uv[i].y);
maxU=Mathf.Max(maxU,sprite.uv[i].x);
maxV=Mathf.Max(maxV,sprite.uv[i].y);
floatmarginX=sprite.textureRect.width/sprite.pixelsPerUnit*.5f;
floatspriteY=sprite.textureRect.height/sprite.pixelsPerUnit*(2.56466f/height);
floatmarginY=(spriteY-height)*.5f;
for(inti=0;i<columns;i++)
inttopIndex=meshPointCount-columns+i;
floatxLerp=(float)i/(columns-1);
floatxOffset=Mathf.Lerp(marginX,-marginX,xLerp);
offsets[i]=newVector3(xOffset,-marginY,0);
offsets[topIndex]=newVector3(xOffset,marginY,0);
floatu=Mathf.Lerp(maxU,minU,xLerp);
uvs[i]=newVector2(u,minV);
uvs[topIndex]=newVector2(u,maxV);
/*{
offsets[0]=newVector3(marginX,-marginY,0);
offsets[1]=newVector3(-marginX,-marginY,0);
offsets[meshPointCount-2]=newVector3(marginX,marginY,0);
offsets[meshPointCount-1]=newVector3(-marginX,marginY,0);
uvs[0]=newVector2(maxU,minV);
uvs[1]=newVector2(minU,minV);
uvs[meshPointCount-2]=newVector2(maxU,maxV);
uvs[meshPointCount-1]=newVector2(minU,maxV);
floatstep=(spriteY-marginY*2)/(pointCount-1);
floatlerpMulti=1f/spriteY;
for(inti=0;i<pointCount;i++)
for(inte=0;e<columns;e++)
intindex=columns+i*columns+e;
floatxLerp=(float)e/(columns-1);
floatyLerp=(marginY+i*step)*lerpMulti;
offsets[index]=newVector3(Mathf.Lerp(marginX,-marginX,xLerp),0,0);
uvs[index]=newVector2(Mathf.Lerp(maxU,minU,xLerp),Mathf.Lerp(minV,maxV,yLerp));
/*{
offsets[2+i*2]=newVector3(marginX,0,0);
offsets[3+i*2]=newVector3(-marginX,0,0);
floatv=Mathf.Lerp(minV,maxV,);
uvs[2+i*2]=newVector2(maxU,v);
uvs[3+i*2]=newVector2(minU,v);
mesh.SetUVs(0,uvs);
publicclassMapCam:MonoBehaviour
publicCameracam;
publicRenderTexturemapTex;
publicboolmapA;
publicLayerMask[]masks;
[HideInInspector]
publicboolactive;
privatestaticVector2mapCenterA,mapCenterB;
publicstaticfloatmapSizeA;
privatestaticfloatmapSizeB;
privatestaticreadonlyintMapA=Shader.PropertyToID("MapA"),
MapB=Shader.PropertyToID("MapB");
publicvoidSetActive(boolactive)
this.active=active;
Shader.SetGlobalTexture(mapA?"ShadowTex":"LightTex",active?mapTex:null);
cam.enabled=active;
privatevoidLateUpdate()
if(!GameManager.Running||!active)
return;
Vector2center=mapA?mapCenterA:mapCenterB;
floatsize=mapA?mapSizeA:mapSizeB;
Vector3pos=newVector3(Mathf.Round(center.x),Mathf.Round(center.y),-10);
transform.position=pos;
cam.orthographicSize=size;
Shader.SetGlobalVector(mapA?MapA:MapB,newVector4(pos.x-size,pos.y-size,.5f/size,size));
cam.cullingMask=masks[GameCam.CurrentSide==Side.Front?0:1];
publicstaticvoidUpdateMapQuads(Bounds2Dshadow,Bounds2Dlight)
mapCenterA=shadow.Center;
mapSizeA=shadow.MaxSide*.5f+.5f;
mapCenterB=light.Center;
mapSizeB=light.MaxSide*.5f+.5f;
publicstaticvoidMapOutlineDRAW()
DRAW.Rectangle(mapCenterA,V2.one*mapSizeA*2).SetColor(COLOR.yellow.fresh).SetDepth(Z.W10);
DRAW.Rectangle(mapCenterB,V2.one*mapSizeB*2).SetColor(COLOR.orange.coral).SetDepth(Z.W10);
publicclassWallPatcher:MonoBehaviour
publicGameObjecthalfA,halfB,shadow;
privatebool[]frontChecks,backChecks;
privatevoidUpdate()
if(GameManager.Running)
floatt=Time.realtimeSinceStartup;
Vector2Intmin,max;
Level.Generator.GetDimensions(outmin,outmax);
for(inty=min.y;y<max.y;y++)
for(intx=min.x;x<max.x;x++)
CellWalls(Level.Generator.GetCellAt(newVector2Int(x,y)),newVector3(x*Level.CellSize,y*Level.CellSize));
Debug.Log(Time.realtimeSinceStartup-t);
enabled=false;
privatevoidCellWalls(Cellcell,Vector3min)
constintsteps=5,arrayLength=steps*steps;
constfloatstep=15f/steps,halfStep=step*.5f;
if(frontChecks==null)
frontChecks=newbool[arrayLength];
if(backChecks==null)
backChecks=newbool[arrayLength];
for(inty=0;y<steps;y++)
for(intx=0;x<steps;x++)
Vector3pos=min+newVector3(x*step+halfStep,y*step+halfStep);
Bounds2Db=newBounds2D(pos).Pad(halfStep+.025f);
intfrontHit=cell.front.Hit(b);
intbackHit=cell.back.Hit(b);
intindex=y*steps+x;
frontChecks[index]=frontHit>0||backHit==2;
backChecks[index]=backHit>0||frontHit==2;
if(frontChecks[index])
InstantiateHere(halfA,pos);
if(backChecks[index])
InstantiateHere(halfB,pos);
if(frontChecks[index]||backChecks[index])
InstantiateHere(shadow,pos);
/*intmaxXWalls=0;
for(inty=0;y<steps;y++)
intcounter=0;
for(intx=0;x<steps;x++)
if()
privatevoidInstantiateHere(GameObjectprefab,Vector3pos)
Transformtrans=Instantiate(prefab).transform;
trans.SetParent(transform);
trans.position=pos;
publicclassLerpTests:MonoBehaviour
publicTransformlinear,test;
[Range(0,1)]
publicfloataccel;
[Space][Range(0,1)]publicfloatlerp;
privatevoidUpdate()
lerp=Mathf.PingPong(Time.realtimeSinceStartup*.5f,1);
floatclampedLerp=Mathf.Clamp01((lerp-.1f)*(1f/.8f));
floattestLerp=GetAccelLerp(clampedLerp,accel);
constfloatmin=-8,max=8;
linear.position=newVector3(Mathf.Lerp(min,max,clampedLerp),1.5f);
test.position=newVector3(Mathf.Lerp(min,max,testLerp),-1.5f);
constfloatsize=8;
DRAW.Rectangle(Vector3.zero,Vector2.one*size).SetColor(Color.cyan.A(.4f));
DRAW.Shapeshape=DRAW.Shape.Get(100);
for(inti=0;i<100;i++)
floatsampleLerp=i/99f;
shape.Set(i,newVector3(sampleLerp-.5f,GetAccelLerp(sampleLerp,accel)-.5f)*size);
shape.SetColor(COLOR.red.tomato);
DRAW.Circle(newVector3(-.5f+clampedLerp,-.5f+testLerp)*size,.1f,100).SetColor(COLOR.red.tomato).Fill(1,true);
privatestaticfloatGetAccelLerp(floatlerp,floataccel)
if(lerp>0)
if(lerp<1)
Vector2mid=Vector2.one*.5f;
floatradius=.5f*accel;
Vector2c1=Vector2.up*radius;
floatdx=c1.x-mid.x;
floatdy=c1.y-mid.y;
floatD_squared=dx*dx+dy*dy;
floatL=Mathf.Sqrt(D_squared-radius*radius);
Vector2pA=accel<1?Contact(c1,radius,mid,L):mid;
if(lerp<=pA.x)
return-(Mathf.Sqrt(1-Mathf.Pow(lerp/radius,2))*radius-radius);
if(lerp<=1-pA.x)
returnMathf.Lerp(pA.y,1-pA.y,(lerp-pA.x)*(1f/(1-pA.x-pA.x)));
return1+(Mathf.Sqrt(1-Mathf.Pow((1-lerp)/radius,2))*radius-radius);
return1;
return0;
privatestaticVector2Contact(Vector2c1,floatr1,Vector2c2,floatr2)
floatdist=Vector2.Distance(c1,c2);
floata=(r1*r1-r2*r2+dist*dist)/(2*dist);
floath=Mathf.Sqrt(r1*r1-a*a);
Vector2c=c1+a*(c2-c1)/dist;
returnnewVector2(c.x+h*(c2.y-c1.y)/dist,c.y-h*(c2.x-c1.x)/dist);
publicclassRectRotation:MonoBehaviour
publicfloatspeed;
privatefloatangle;
privatevoidUpdate()
angle+=Time.deltaTime*speed;
Transformt=transform;
t.rotation=Rot.Y(angle);
Vector3s=t.localScale;
t.localPosition=V3.right*Mathf.Lerp(s.x,s.z,Mathf.Abs(Mathf.Sin(angle/360*2*Mathf.PI)))*.5f;
publicclassFittingRectangle:MonoBehaviour
publicfloatwidth;
publicfloatheight;
privatefloatangle;
privatevoidOnEnable()
DRAW.Enabled=true;
privatevoidUpdate()
DRAW.Rectangle(V3.zero,newVector2(width,height)).SetColor(COLOR.red.firebrick);
angle=Mathf.Lerp(angle,angle+Input.GetAxis("Horizontal")*-15,Time.deltaTime*10);
DRAW.Rectangle(V3.zero,Rectangle.FitRotationSize(newVector2(width,height),angle),angle).SetColor(COLOR.yellow.fresh).Fill();
publicclassArCamMovementTest:MonoBehaviour
privatevoidUpdate()
transform.localEulerAngles=newVector3(0,Mth.SmoothPP(Time.realtimeSinceStartup)*45);
publicclassMapToARCam:MonoBehaviour
publicCameraarCam;
publicTransformarCenter;
publicTransformarWallBounds;
[Space(10)]
publicCamerarealCam;
publicTransformgameWallBounds;
privatevoidLateUpdate()
realCam.fieldOfView=arCam.fieldOfView;
floatmulti=gameWallBounds.localScale.x/arWallBounds.localScale.x;
Vector3pos=arCenter.InverseTransformPoint(arCam.transform.position)*multi;
Vector3forward=arCenter.InverseTransformDirection(arCam.transform.forward);
Vector3up=arCenter.InverseTransformDirection(arCam.transform.up);
realCam.transform.position=pos-Vector3.forward*Level.WallDepth;
realCam.transform.rotation=Quaternion.LookRotation(forward,up);
publicclassBary:MonoBehaviour
publicVector2v1,v2,v3;
privatevoidAwake()
Cursor.visible=false;
privatevoidUpdate()
DRAW.Circle(v1,.1f,20).SetColor(Color.red).Fill(1,true);
DRAW.Circle(v2,.1f,20).SetColor(Color.green).Fill(1,true);
DRAW.Circle(v3,.1f,20).SetColor(Color.blue).Fill(1,true);
Vector2p=Camera.main.ScreenToWorldPoint(Input.mousePosition);
Vector3w=Tri.BaryWeight(v1,v2,v3,p);
if(w.x>=0&&w.y>=0&&w.z>=0)
Colormix=Color.red*w.x+Color.green*w.y+Color.blue*w.z;
DRAW.Circle(p,.1f,20).SetColor(mix).Fill(1,true);
else
DRAW.Circle(p,.1f,20).SetColor(Color.white).Fill(1,true);
publicclassSampleFloor:MonoBehaviour
privateclassTriColor
privatereadonlyVector2v1,v2,v3;
privatereadonlyColorc1,c2,c3;
publicTriColor(Vector2v1,Vector2v2,Vector2v3,Colorc1,Colorc2,Colorc3)
this.v1=v1;
this.v2=v2;
this.v3=v3;
this.c1=c1;
this.c2=c2;
this.c3=c3;
publicboolPickedColor(Vector2p,Materialmaterial)
Vector3w=Tri.BaryWeight(v1,v2,v3,p);
if(w.x>=0&&w.y>=0&&w.z>=0)
Colorc=c1*w.x+c2*w.y+c3*w.z;
material.color=c;
returntrue;
returnfalse;
privateTriColor[]triColors;
publicTransformsphere;
publicMaterialmaterial;
privatevoidStart()
Meshmesh=GetComponent<MeshFilter>().mesh;
Vector3[]verts=mesh.vertices;
Color[]colors=mesh.colors;
int[]tris=mesh.triangles;
List<TriColor>tC=newList<TriColor>();
for(inti=0;i<tris.Length;i+=3)
tC.Add(newTriColor(transform.TransformPoint(verts[tris[i]]).V2UseZ(),
transform.TransformPoint(verts[tris[i+1]]).V2UseZ(),
transform.TransformPoint(verts[tris[i+2]]).V2UseZ(),
colors[tris[i]],colors[tris[i+1]],colors[tris[i+2]]));
triColors=tC.ToArray();
privatevoidUpdate()
Vector2p=sphere.position.V2UseZ();
for(inti=0;i<triColors.Length;i++)
if(triColors[i].PickedColor(p,material))
return;
material.color=Color.gray;
publicclassBenchmarkKing:MonoBehaviour
publicTextuiText;
privatevoidUpdate()
if(false)
Vector2v=newVector2(46f,8644f);
Vector2result;
constfloatstep=.25456f;
constintsteps=1000000;
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Quaternion.AngleAxis(step*i,Vector3.forward)*v;
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=v.Rot(step*i);
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();
if(false)
Quaternionresult;
constfloatstep=.25456f;
constintsteps=1000000;
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Quaternion.AngleAxis(step*i,Vector3.forward);
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Rot.Z(step*i);
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();
if(false)
floatresult;
constfloatstep=.25456f;
constintsteps=1000000;
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Mathf.SmoothStep(0,1,Mathf.PingPong(i*step,1));
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Mth.SmoothPP(0,1,i*step);
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();
if(false)
floatresult;
constfloatstep=.25456f;
constintsteps=100000;
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Mathf.Pow(step,Random.Range(2,31));
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=Mth.IntPow(step,Random.Range(2,31));
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();
if(false)
Vector2result;
constfloatstep=.25456f;
constintsteps=100000;
Vector2source=newVector2(.35f,.345f);
Vector2point=newVector2(100,45f);
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=source+(point-source).normalized*i;
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<steps;i++)
result=source.AimPos(point,i);
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();
if(true)
/*IEnumerable<elementType>values=Enum.GetValues(typeof(elementType)).Cast<elementType>();
List<elementType>allTypes=newList<elementType>();
foreach(elementTypeelementTypeinvalues)
allTypes.Add(elementType);
elementType[]types=allTypes.ToArray();
intcount=types.Length;
floatt1=Time.realtimeSinceStartup;
for(inti=0;i<100000;i++)
(types[i%count]).Matches(info.IsItem);
t1=Time.realtimeSinceStartup-t1;
floatt2=Time.realtimeSinceStartup;
for(inti=0;i<100000;i++)
Mask.IsItem.Fits(types[i%count]);
t2=Time.realtimeSinceStartup-t2;
uiText.text=t1.ToString()+"\n"+t2.ToString();*/
publicclassWrapArray<T>
privatereadonlyT[]array;
privatereadonlyintarrayLength;
privateintmin,max;
privateintfirst{get{returnmin%arrayLength;}}
privateintlast{get{return(max-1)%arrayLength;}}
privateintlength{get{returnmax-min;}}
publicWrapArray(intarrayLength)
this.arrayLength=arrayLength;
array=newT[arrayLength];
publicclassPowTest:MonoBehaviour
publicfloatvalue;
publicfloatpower;
[Space(10)]
publicfloatdefaultResult;
publicfloatdefaultTime;
[Space(10)]
publicfloatmyResult;
publicfloatmyTime;
privatevoidUpdate()
/*if(Input.GetKeyDown(KeyCode.Space))
defaultTime=0;
for(inti=0;i<1000000;i++)
floatt=Time.realtimeSinceStartup;
defaultResult=Mathf.Pow(value,power);
defaultTime+=Time.realtimeSinceStartup-t;
myTime=0;
for(inti=0;i<1000000;i++)
floatt=Time.realtimeSinceStartup;
myResult=GMath.Pow(value,power);
myTime+=Time.realtimeSinceStartup-t;
publicclassRotCompare:MonoBehaviour
publicTransforma,b;
privatefloatangle;
privatevoidUpdate()
angle-=Time.deltaTime*90;
a.rotation=Quaternion.AngleAxis(angle,Vector3.right);
b.rotation=Rot.X(angle);
publicclassBendLine:MonoBehaviour
[Range(-1,1)]
publicfloatcircleBend;
[Range(0,1)]
publicfloatpivot;
[Space(10)]
publicfloatlineLength;
privateconstintsegments=100;
publicvoidAwake()
DRAW.Enabled=true;
DRAW.EditorDraw=true;
privatevoidUpdate()
Vector2lineStart=V2.down*lineLength*.5f;
Vector2lineEnd=V2.up*lineLength*.5f;
DRAW.Line(segments,i=>GetPosOnCircle(lineStart,lineEnd,(float)i/(segments-1),circleBend,pivot)).SetColor(COLOR.red.tomato);
DRAW.Vector(V2.down*lineLength*.25f+V2.left*lineLength*.25f,V2.up*lineLength*.5f).SetColor(Color.cyan);
privatestaticVector2GetPosOnCircle(Vector2lineStart,Vector2lineEnd,floatlineLerp,floatcircleLerp,floatpivot)
if(f.Same(circleLerp,0))
returnVector3.Lerp(lineStart,lineEnd,lineLerp);
floatlength=(lineEnd-lineStart).magnitude;
floatradius=1/circleLerp/2/Mth.*length;
Vector2center=newVector2((lineStart.x+lineEnd.x)/2+radius,lineStart.y+length*(1-pivot));
floatsegment=circleLerp*(1-lineLerp-pivot)*Mth.*2;
returncenter+newVector2(Mathf.Cos(Mth.+segment),Mathf.Sin(Mth.+segment))*radius;
publicclassChordBend:Singleton<ChordBend>
[Range(0,1)]
publicfloatsquash;
[Space(10)]
publicfloatlineLength;
[Space(10)][Range(0,1)]publicfloatmaxSquash;
publicboolright;
privateVector3[]segmentPoints=newVector3[5];
publicvoidAwake()
DRAW.Enabled=true;
DRAW.EditorDraw=true;
privatevoidUpdate()
squash=(Mathf.Sin(Time.realtimeSinceStartup*4)*.5f+.5f)*.998f*maxSquash+.001f;
floatangle=Time.realtimeSinceStartup*10;
floatsquashedLength=lineLength*(1-squash);
Vector3lineStart=V2.down.Rot(angle,squashedLength*.5f);
Vector3lineEnd=V2.up.Rot(angle,squashedLength*.5f);
DRAW.Vector(lineStart,lineEnd-lineStart).SetColor(Color.cyan);
DRAW.Circle(lineStart,.02f).SetColor(Color.cyan);
DRAW.Circle(lineEnd,.02f).SetColor(Color.cyan);
if(f.Same(squash,0))
return;
Bend(lineStart,lineEnd,lineLength,right,refsegmentPoints);
for(inti=0;i<segmentPoints.Length-1;i++)
DRAW.Vector(segmentPoints[i],segmentPoints[i+1]-segmentPoints[i]).
SetColor(Color.Lerp(COLOR.yellow.fresh,COLOR.purple.maroon,(float)i/(segmentPoints.Length-1)));
privatestaticvoidBend(Vector3root,Vector3tip,floatlineLength,boolrightSide,refVector3[]points)
floatsquashedLength=Vector3.Distance(root,tip);
floatsign=rightSide?1:-1;
if(squashedLength>=lineLength)
Vector3dir=(tip-root).normalized;
for(inti=0;i<points.Length;i++)
points[i]=root+dir*lineLength*((float)i/(points.Length-1));
return;
floatbend=1-squashedLength/lineLength;
floatradius=Mth.Chord.GetRadius(squashedLength,lineLength);
floatsegmentAngle=360f*bend/(points.Length-1);
for(inti=0;i<points.Length;i++)
points[i]=GetPointOnCircle(segmentAngle*i,sign,radius);
Vector3pointDir=(points[points.Length-1]-points[0]).normalized;
Quaternionrot=Quaternion.FromToRotation(pointDir,V3.up);
for(inti=0;i<points.Length;i++)
points[i]=rot*points[i];
floatfactor=squashedLength/Vector3.Distance(points[points.Length-1],points[0]);
for(inti=0;i<points.Length;i++)
points[i]=points[i].Scale(y:factor);
Vector3lineDir=(tip-root).normalized;
rot=Quaternion.FromToRotation(V3.up,lineDir);
for(inti=0;i<points.Length;i++)
points[i]=rot*points[i];
Vector3offset=root-points[0];
for(inti=0;i<points.Length;i++)
points[i]+=offset;
privatestaticVector3GetPointOnCircle(floatangle,floatsign,floatradius)
returnnewVector3(radius*-sign,0,0).RotZ(angle*-sign);
publicclassSegmentBend:MonoBehaviour{
[Range(0,1)]
publicfloatsquash;
[Space(10)]
publicfloatlineLength;
publicintsegmentCount;
privateVector3[]segmentPoints;
privateintcount;
publicvoidOnEnable()
DRAW.Enabled=true;
DRAW.EditorDraw=true;
privatevoidUpdate()
floatsquashedLength=lineLength*(1-squash);
Vector3lineStart=V2.down*squashedLength*.5f;
Vector3lineEnd=V2.up*squashedLength*.5f;
DRAW.Vector(lineStart,lineEnd-lineStart).SetColor(Color.cyan);
if(count!=segmentCount)
count=segmentCount;
segmentPoints=newVector3[segmentCount+1];
if(segmentCount==0)
return;
floatangle=Mathf.Lerp(0,360f,squash);
floatsegmentAngle=angle/segmentCount;
floatsegmentLength=lineLength/segmentCount;
Debug.Log(segmentAngle);
segmentPoints[0]=lineStart;
for(inti=1;i<segmentPoints.Length;i++)
segmentPoints[i]=segmentPoints[i-1]+V2.down.Rot(i*segmentAngle,segmentLength).V3();
Vector3pointDir=(segmentPoints[segmentPoints.Length-1]-segmentPoints[0]).normalized;
Vector3lineDir=(lineEnd-lineStart).normalized;
Quaternionrot=Quaternion.FromToRotation(pointDir,lineDir);
for(inti=0;i<segmentPoints.Length;i++)
segmentPoints[i]=rot*segmentPoints[i];
Vector3offset=lineStart-segmentPoints[0];
for(inti=0;i<segmentPoints.Length;i++)
segmentPoints[i]+=offset;
for(inti=0;i<segmentCount;i++)
DRAW.Vector(segmentPoints[i],segmentPoints[i+1]-segmentPoints[i]).SetColor(Color.yellow);
publicclassCapsuleRadius:MonoBehaviour
publicCircleAllignallign;
privatevoidUpdate()
transform.localScale=newVector3(allign.animRadius*2,transform.localScale.y,allign.animRadius*2);
publicclassCircleAllign:MonoBehaviour
[Range(.75f,5f)]publicfloatradius;
[Space(10)]publicfloat[]lineLengths;
publicintlineNumber;
[Range(0,1)]publicfloatoffsetOnCircle;
privateconstintnumberOfPoints=100;
publicboolfit;
publicbooldraw;
publicboolmove;
[Space(10)]publicfloatspeed;
publicfloatanimRadius;
privatevoidOnEnable()
if(draw)
DRAW.Enabled=DRAW.EditorDraw=true;
animRadius=radius;
privatevoidUpdate()
animRadius=Mathf.Lerp(animRadius,radius,Time.deltaTime*8);
if(move)
offsetOnCircle+=(Time.deltaTime/(Mathf.PI*2*radius))*speed;
floatuseRadius=animRadius;
if(draw)
DRAW.Line(numberOfPoints,i=>V3.up.RotZ(360f/(numberOfPoints-1)*i,useRadius)).SetColor(COLOR.red.tomato.A(.1f));
Vector3pointA=V3.up.RotZ(360f*offsetOnCircle,useRadius);
floatdegree=0;
for(inti=0;i<lineNumber;i++)
if(draw)
DRAW.Circle(pointA,.07f).SetColor(COLOR.blue.cornflower);
floatsegmentLength=lineLengths[i%lineLengths.Length];
floatarcLength=2*Mathf.Asin(segmentLength/2/useRadius);
degree+=arcLength*Mathf.Rad2Deg;
Vector3pointB=V3.up.RotZ(360f*offsetOnCircle+degree,useRadius);
if(draw)
DRAW.Circle(pointB,.03f).SetColor(COLOR.green.spring);
if(draw)
DRAW.Vector(pointA,pointB-pointA).SetColor(COLOR.orange.coral);
pointA=pointB;
publicVector3[]GetPointsOnCircle(intnumber,floatsegmentLength,floatextraRadius,floatstartoffset=0,floatshift=0)
floatoff=offsetOnCircle+shift;
floatr=animRadius+extraRadius;
floatdegree=GetAngleForCirclePoint(startoffset,r);
Vector3pointA=V3.up.RotZ(360f*off+degree,r);
Vector3[]returnPoints=newVector3[number];
returnPoints[0]=pointA;
for(inti=0;i<number;i++)
returnPoints[i]=pointA;
degree+=GetAngleForCirclePoint(segmentLength,r);
pointA=Rot.Z(360f*off+degree)*V3.up*r;
returnreturnPoints;
publicstaticfloatGetAngleForCirclePoint(floatoffsetAlongCircle,floatradius)
return2*Mathf.Asin(offsetAlongCircle/2/radius)*Mathf.Rad2Deg;
publicclassCircleIntersection:MonoBehaviour
publicfloatoffset;
publicfloatsegmentLength;
publicfloatcircleDistance;
publicfloatcircleRadius;
publicfloatangle;
publicboolleft;
publicboolmax;
privateconstintnumberOfPoints=100;
privatevoidAwake()
DRAW.Enabled=DRAW.EditorDraw=true;
/*privatestaticintFindCircleCircleIntersections(Vector2m1,floatr1,Vector2m2,floatr2)
floatdist=Vector2.Distance(m1,m2);
if(dist>r1+r2||dist<Mathf.Abs(r1-r2))
return0;
floata=(Mathf.Pow(r1,2)-Mathf.Pow(r2,2)+Mathf.Pow(dist,2))/(2*dist);
floath=Mathf.Sqrt(r1*r2-a*a);
Vector2c=m1+a*(m2-m1)/dist;
Vector2p1=newVector2(c.x+h*(m2.y-m1.y)/dist,c.y-h*(m2.x-m1.x)/dist);
Vector2p2=newVector2(c.x-h*(m2.y-m1.y)/dist,c.y+h*(m2.x-m1.x)/dist);
return2;
publicstaticVector2GetPointAlongPath(Vector2startPoint,Vector2up,floatsegmentLength,floatcircleDistance,floatcircleRadius,boolleft,boolmax)
Vector2circleMidPoint=startPoint+up*circleDistance+up.Rot90(left)*circleRadius;
Vector2lineBetween=circleMidPoint-startPoint;
Vector2lineDir=lineBetween.normalized;
floatdistance=lineBetween.magnitude;
DRAW.Vector(startPoint,up*circleDistance).SetColor(COLOR.grey.mid);
DRAW.Line(numberOfPoints,i=>circleMidPoint.V3()+V3.up.RotZ(360f/(numberOfPoints-1)*i,circleRadius)).SetColor(COLOR.grey.mid);
if(max)
segmentLength=distance+circleRadius;
if(segmentLength<=circleDistance)
returnstartPoint+up*segmentLength;
floatbetween=(Mth.IntPow(segmentLength,2)-Mth.IntPow(circleRadius,2)+Mth.IntPow(distance,2))/(2*distance);
floatoffset=Mathf.Sqrt(Mth.IntPow(segmentLength,2)-Mth.IntPow(between,2));
returnstartPoint+lineDir*between+lineDir.Rot90(!left)*offset;
privatevoidUpdate()
circleDistance=Mth.SmoothPP(6,0,Time.realtimeSinceStartup*.2f);
circleRadius=Mth.SmoothPP(2.45f,2.25f,Time.realtimeSinceStartup*2f);
Vector2up=V2.up.Rot(angle);
Vector2startPos=up*offset;
Vector2point=GetPointAlongPath(startPos,up,segmentLength,circleDistance-offset,circleRadius,left,max);
DRAW.Vector(startPos,point-startPos).SetColor(COLOR.green.lime).SetDepth(-1);
publicclassJointsOnChain:MonoBehaviour
publicTransform[]joints;
publicCircleAllignallign;
privateQuaternion[]defaultRotations;
[Space(10)]publicfloatspeed;
privatevoidAwake()
defaultRotations=newQuaternion[joints.Length];
for(inti=0;i<defaultRotations.Length;i++)
defaultRotations[i]=joints[i].rotation;
privatevoidUpdate()
floatangle=Time.realtimeSinceStartup*speed;
floatdistance=Mathf.Lerp(2,4,Mathf.Abs(Mathf.Sin(angle/360*2*Mathf.PI)))*.5f;
Vector3[]points=allign.GetPointsOnCircle(joints.Length,1,distance);
for(inti=0;i<joints.Length;i++)
joints[i].position=points[i];
QuaternionrotA=i<joints.Length-1?Quaternion.FromToRotation(Vector3.up,points[i+1]-points[i])
:Quaternion.FromToRotation(Vector3.up,points[i]-points[i-1]);
QuaternionrotB=Rot.Y(angle);
joints[i].rotation=rotA*rotB*defaultRotations[i];
publicclassbouncy:MonoBehaviour
privateintimpactNumber;
publicVector2Position;
publicvoidOnEnable()
Position=transform.position;
publicvoidImpact(Vector2impactV)
impactNumber++;
StartCoroutine(SwingAnim(impactV));
privateIEnumeratorSwingAnim(Vector2impactV)
intiNumber=impactNumber;
floatimpactV_M=impactV.magnitude;
floatduration=impactV_M*.05f;
floatinterval=impactV_M*.4f;
Vector2amplitude=impactV*.02f;
floatt=0;
while(iNumber==impactNumber&&t<duration)
t+=Time.deltaTime*collisiontest.SlowMoFactor;
Vector2swing=Mth.SmoothPP(t*interval+.5f)*amplitude;
floatdampLerp=t/duration;
transform.position=Position+Vector2.Lerp(swing,V2.zero,dampLerp);
yieldreturnnull;
[System.Serializable]
publicclassTrajectoryInfo
publicVector2startPos;
publicfloatstartAngle;
[Space(5)]
publicVector2motionVector;
publicfloatspin;
[Space(5)]
publicfloattime;
publicclasscollisiontest:Singleton<collisiontest>{
publicVector2initialMotionVector;
publicfloatinitialSpin;
[Space(10)]
[Header("FlyState")]
publicTrajectoryInfotrajectory;
privateFlyPathflyPath;
[Space(10)]
[Range(0,1)]
publicfloatslowMo;
publicstaticfloatSlowMoFactor{get{returnInst.slowMo;}}
[Space(10)]
[Range(0,1)]
publicfloatbouncy;
[Space(10)]
publicTransformspinner;
publicbouncy[]bouncys;
publicfloatInertia;
privateVector2initialPosition;
privatefloatinitialAngle;
privateVector2rectangleScale;
privateboolgo;
privatereadonlyQuadplayerQuad=newQuad();
privateconstfloatmass=10;
privatefloatinertia{get{returnInertia;}}//(mass/12f)*(.6f*.6f+2f*2f);
privateVector2stickVelocity;
privatefloatstickMass;
privateinthitCount;
privateintround;
privatevoidStart()
stickVelocity=Vector2.zero;
stickMass=100000;
initialPosition=spinner.position;
rectangleScale=spinner.localScale;
initialAngle=spinner.eulerAngles.z;
DRAW.Enabled=DRAW.EditorDraw=true;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
go=!go;
if(go)
round=(round+1)%3;
hitCount=0;
trajectory.time=0;
trajectory.startAngle=initialAngle;
trajectory.startPos=initialPosition;
trajectory.motionVector=initialMotionVector;
trajectory.spin=initialSpin;
flyPath=newFlyPath(initialPosition,initialMotionVector);
if(!go)
return;
trajectory.time+=Time.deltaTime*slowMo;
spinner.position=flyPath.GetPos(trajectory.time);
spinner.eulerAngles=newVector3(0,0,trajectory.startAngle+GPhysics.Get_SpinAngle_Deg(trajectory.spin,trajectory.time));
SetPlayerQuad(trajectory.time);
for(inti=0;i<bouncys.Length;i++)
if(!bouncys[i].gameObject.activeInHierarchy)
continue;
Circlecircle=newCircle(bouncys[i].Position,.5f);
if(!playerQuad.Intersects(circle))
continue;
Collision(bouncys[i]);
break;
privatevoidSetPlayerQuad(floatt)
Vector2pos=flyPath.GetPos(t);
floatangle=trajectory.startAngle+GPhysics.Get_SpinAngle_Deg(trajectory.spin,t);
playerQuad.SetRect(pos,rectangleScale,angle);
privatestringColorString
get
switch(round)
default:return"red";
case0:return"lime";
case1:return"orange";
case2:return"yellow";
privateboolCollisionOccured(floatt,Vector2bouncyPos)
SetPlayerQuad(t);
Circlecircle=newCircle(bouncyPos,.5f);
returnplayerQuad.Intersects(circle);
privatevoidCollision(bouncybouncy)
hitCount++;
if(hitCount==1)
Debug.Log("<color="+ColorString+">"+hitCount+"_HITBouncy"+bouncy.name+"</color>");
floatstepLength=Time.deltaTime*2;
floatimpactTime=trajectory.time;
Vector2bouncyPos=bouncy.Position;
for(inti=0;i<30;i++)
stepLength*=.5f;
if(CollisionOccured(impactTime,bouncyPos))
impactTime-=stepLength;
else
impactTime+=stepLength;
if(stepLength<0.0000001f)
Debug.Log(i);
break;
impactTime+=stepLength;
trajectory.time-=impactTime;
trajectory.startAngle=trajectory.startAngle+GPhysics.Get_SpinAngle_Deg(trajectory.spin,impactTime);
floatcurrentRadSpin=GPhysics.Get_SpinSpeed_After(trajectory.spin,impactTime)*GPhysics.SpinMulti*Mathf.Deg2Rad;
Vector2charPos=flyPath.GetPos(impactTime);
Vector2charVelocity=flyPath.GetMV(impactTime);
Vector2charRadiusVector=Tri.HitPoint-charPos;
Vector2charAngularVelocity=currentRadSpin.Cross(charRadiusVector);
Vector2charVelAtContact=charVelocity+charAngularVelocity;
Vector2stickPos=bouncy.Position;
Vector2stickVel=stickVelocity;
Vector2stickRadiusVector=Tri.HitPoint-stickPos;
Vector2stickAngularVelocity=(0f/*stickSpin*/).Cross(stickRadiusVector);
Vector2stickVelAtContact=stickVel+stickAngularVelocity;
Vector2relativeVelocity=charVelAtContact-stickVelAtContact;
floatvelAlongNormal=Vector2.Dot(relativeVelocity,Tri.HitNormalInverse);
floathitDirCross=charRadiusVector.Cross(Tri.HitNormalInverse);
floate=this.bouncy;
floatimpulse=-(1.0f+e)*velAlongNormal/
(
1.0f/mass+1.0f/stickMass
+Mth.IntPow(hitDirCross,2)/inertia
/*+Mathf.Pow(Extensions.CrossProduct(stickRadiusVector,Tri.HitNormalInverse),2)/inertia*///Stickinertiaisinfinite
);
Vector2impulseV=Tri.HitNormalInverse*impulse;
trajectory.motionVector=charVelocity+impulseV/mass;
trajectory.spin=(currentRadSpin+hitDirCross/inertia*impulse)*Mathf.Rad2Deg/GPhysics.SpinMulti;
trajectory.startPos=charPos;
bouncy.Impact(relativeVelocity);
if(hitCount==1)
Debug.Log("Time:"+impactTime);
Debug.Log("CharPosx:"+charPos.x+"y:"+charPos.y);
Debug.Log("CharAngle:"+trajectory.startAngle);
Debug.Log("ImpactVx:"+relativeVelocity.x+"y:"+relativeVelocity.y);
Debug.Log("SpinSpeed:"+currentRadSpin);
Debug.Log("NewMotionx:"+trajectory.motionVector.x+"y:"+trajectory.motionVector.y);
Debug.Log("NewSpinSpeed:"+trajectory.spin);
publicclassColorMap:MonoBehaviour
publicPaletteSourcesource;
publicColorcolor;
privateinteditPick,currentEditPick;
privateinteditMapping,savedMapping;
privatevoidStart()
if(source.mapping.Length==0)
source.mapping=newint[source.oldColors.Length];
for(inti=0;i<source.oldColors.Length;i++)
ColoroldColor=source.oldColors[i];
floatbestDist=float.MaxValue;
intpick=0;
for(inte=0;e<source.newColors.Length;e++)
ColornewColor=source.newColors[e];
floatdist=newColor.Dist(oldColor);
if(dist<bestDist)
bestDist=dist;
pick=e;
source.mapping[i]=pick;
currentEditPick=-1;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.UpArrow))
editPick=(editPick+1).Repeat(source.oldColors.Length);
if(Input.GetKeyDown(KeyCode.DownArrow))
editPick=(editPick-1).Repeat(source.oldColors.Length);
if(currentEditPick!=editPick)
currentEditPick=editPick;
editMapping=savedMapping=source.mapping[currentEditPick];
color=source.newColors[savedMapping];
floatbestDist=float.MaxValue;
editMapping=0;
for(inte=0;e<source.newColors.Length;e++)
ColornewColor=source.newColors[e];
floatdist=newColor.Dist(color);
if(dist<bestDist)
bestDist=dist;
editMapping=e;
if(Input.GetKeyDown(KeyCode.Space))
savedMapping=editMapping;
source.mapping[editPick]=savedMapping;
DRAW.Rectangle(Vector3.right*-1,Vector2.one*2).SetColor(source.oldColors[currentEditPick]).Fill(1,true);
DRAW.Rectangle(Vector3.right*1,Vector2.one*2).SetColor(source.newColors[editMapping]).Fill(1,true);
publicclassFindBestPalette:MonoBehaviour
publicintbestHueSteps=0,bestSaturationSteps=0;
publicfloatbestMinTint,bestMaxTint;
publicfloatbestDist;
publicfloat[]bestHueOffsets;
publicNewColorGengen;
[Space]
publicinttests;
publicintcurrentHue,currentSat;
[Space]publicTextMeshProtmp;
publicbooljustInit;
privatevoidStart()
UpdateGen();
if(!justInit)
StartCoroutine(YieldSearch());
privatevoidUpdateGen()
gen.hueSteps=bestHueSteps;
gen.satSteps=bestSaturationSteps;
gen.hueOffsets=newfloat[bestHueOffsets.Length];
gen.tintMin=bestMinTint;
gen.tintMax=bestMaxTint;
for(inti=0;i<bestHueSteps;i++)
gen.hueOffsets[i]=bestHueOffsets[i];
gen.Init();
PaletteSource.Get.hues=NewColorGen.colors;
EditorUtility.SetDirty(PaletteSource.Get);
List<string>lines=newList<string>();
lines.Add(bestHueSteps.ToString());
lines.Add(bestSaturationSteps.ToString());
stringarray="";
for(inti=0;i<bestHueSteps;i++)
array+=bestHueOffsets[i].ToString(CultureInfo.InvariantCulture)+"";
lines.Add(array);
DesktopTxt.Write("ColorGenValues",lines.ToArray(),".spn");
privateIEnumeratorYieldSearch()
float[]hueOffsets=newfloat[60];
Color[]old=NewColorGen.HoudiniUsed();
List<Color>used=newList<Color>(),not=newList<Color>();
for(inti=0;i<old.Length;i++)
Colorcolor=old[i];
floatnonGreyness=Mathf.Abs(color.r-color.g)+Mathf.Abs(color.r-color.b);
if(nonGreyness<.2f)
not.Add(color);
continue;
used.Add(color);
Debug.Log("Used:"+used.Log());
Debug.Log("Not:"+not.Log());
while(true)
tests=0;
inttest=0;
for(inthueTest=16;hueTest<50;hueTest++)//16
for(intsatTest=3;satTest<15;satTest++)
for(inthueOff=0;hueOff<10000;hueOff++)
for(inti=0;i<hueTest;i++)
hueOffsets[i]=Random.Range(-.5f,.5f);
floattotalDist=0;
Color[]newColors=NewColorGen.GeneratCrazy(hueTest,satTest,hueOffsets);
for(inti=0;i<used.Count;i++)
totalDist+=used[i].ClosestColorDist(newColors);
if(bestDist>=totalDist)
bestDist=totalDist;
bestHueSteps=hueTest;
bestSaturationSteps=satTest;
for(inti=0;i<hueTest;i++)
bestHueOffsets[i]=hueOffsets[i];
UpdateGen();
newColors=NewColorGen.GeneratCrazy(bestHueSteps,bestSaturationSteps,bestHueOffsets);
Dictionary<int,int>valueRemap=newDictionary<int,int>();
for(inti=0;i<used.Count;i++)
valueRemap.Add(i,used[i].ClosestColorIndex(newColors));
foreach(KeyValuePair<int,int>VARIABLEinvalueRemap)
Debug.Log(VARIABLE.Key.ToString().PadLeft(4)+""+FancyString.Block.B_Color(used[VARIABLE.Key])+
FancyString.Block.B_Color(newColors[VARIABLE.Value])+""+VARIABLE.Value.ToString().PadLeft(4));
test++;
tests++;
if(test==100)
yieldreturnnull;
tmp.text="H:"+hueTest+"S:"+satTest+"\nT:"+tests.ToString();
test=0;
currentHue=hueTest;
currentSat=satTest;
publicstructHLS
publicreadonlyfloath,l,s,a;
publicHLS(floath,floatl,floats,floata=1)
this.h=h;
this.l=l;
this.s=s;
this.a=a;
publicHLS(floathue)
h=hue;
l=.5f;
s=1;
a=1;
publicVector2HueDir{get{returnRot.Z(h*360)*Vector2.up;}}
publicstaticColorGet(floathue)
returnnewHLS(Mathf.Repeat(hue,1),.5f,1);
publicstaticimplicitoperatorColor(HLShls)
floath=hls.h;
floatluminance=hls.l;
floatsaturation=hls.s;
if(Mathf.Approximately(saturation,0))
returnnewColor(luminance,luminance,luminance,hls.a);
floatp2=luminance<=.5f?luminance*(1+saturation):luminance+saturation-luminance*saturation;
floatp1=2*luminance-p2;
constfloatfraction=1f/3;
returnnewColor(QqhToRgb(p1,p2,h+fraction),QqhToRgb(p1,p2,h),QqhToRgb(p1,p2,h-fraction),hls.a);
publicstaticimplicitoperatorColor32(HLShls)
floath=hls.h;
floatluminance=hls.l;
floatsaturation=hls.s;
if(Mathf.Approximately(saturation,0))
returnnewColor(luminance,luminance,luminance,hls.a);
floatp2=luminance<=.5f?luminance*(1+saturation):luminance+saturation-luminance*saturation;
floatp1=2*luminance-p2;
constfloatfraction=1f/3;
returnnewColor(QqhToRgb(p1,p2,h+fraction),QqhToRgb(p1,p2,h),QqhToRgb(p1,p2,h-fraction),hls.a);
privatestaticfloatQqhToRgb(floatq1,floatq2,floathue)
hue=Mathf.Repeat(hue,1);
if(hue<1f/6)
returnq1+(q2-q1)*hue*6;
if(hue<.5f)
returnq2;
constfloatmultiB=1f/6*4;
if(hue<multiB)
returnq1+(q2-q1)*(multiB-hue)*6;
returnq1;
publicstaticclassHLSext
publicstaticHLSToHLS(thisColorcolor)
floatr=color.r,g=color.g,b=color.b;
floatmax=Mathf.Max(Mathf.Max(r,g),b);
floatmin=Mathf.Min(Mathf.Min(r,g),b);
floatdiff=max-min;
floatluminance=(max+min)*.5f;
if(Mathf.Abs(diff)<0.00001)
returnnewHLS(0,luminance,0,color.a);
floatsaturation=luminance<=.5?diff/(max+min):diff/(2-max-min);
floathue;
floatdistMulti=1f/diff;
floatr_dist=(max-r)*distMulti;
floatg_dist=(max-g)*distMulti;
floatb_dist=(max-b)*distMulti;
if(Mathf.Approximately(r,max))
hue=b_dist-g_dist;
else
hue=g>b?2+r_dist-b_dist:4+g_dist-r_dist;
constfloatmulti=1f/6;
hue=Mathf.Repeat(hue*multi,1);
returnnewHLS(hue,luminance,saturation,color.a);
publicstaticHLSShiftHue(thisHLScolor,floatshift)
returnnewHLS(Mathf.Repeat(color.h+shift,1),color.l,color.s,color.a);
publicstaticHLSSetLuminace(thisHLScolor,floatvalue)
returnnewHLS(color.h,value,color.s,color.a);
publicstaticHLSSetSaturation(thisHLScolor,floatvalue)
returnnewHLS(color.h,color.l,value,color.a);
publicstaticHLSMapGamut(thisHLShls,Linea,Lineb,Linec)
Linedir=newLine(Vector2.zero,hls.HueDir);
Vector2hitPoint;
if(dir.Contact(a,outhitPoint)||dir.Contact(b,outhitPoint)||dir.Contact(c,outhitPoint))
returnnewHLS(hls.h,hls.l,hitPoint.magnitude,hls.a);
returnhls;
publicstaticHLSHueSlerp(thisHLShls,HLSother,floatlerp)
floatangle=hls.HueDir.Angle_Sign(other.HueDir)/360;
floatcurve=1-Mathf.Pow(Mathf.Abs(angle*2),2);
curve=Mathf.SmoothStep(0,1,1-Mathf.Abs(angle*2));
returnnewHLS(Mathf.Repeat(hls.h-angle*lerp,1),hls.l,hls.s,hls.a);
publicstaticHLSSetA(thisHLShls,floata)
returnnewHLS(hls.h,hls.l,hls.s,a);
publicclassLightColorTest:Singleton<LightColorTest>
publicColorcolorA;
[Range(0,1)]
publicfloatcolorALerp,colorALuminance,colorASaturation;
[Space(20)]
publicColorcolorB;
[Range(0,1)]
publicfloatcolorBLerp,colorBLuminance,colorBSaturation;
privatestaticreadonlyintSunDir=Shader.PropertyToID("SunDir");
privatestaticreadonlyintColorA=Shader.PropertyToID("ColorA");
privatestaticreadonlyintColorB=Shader.PropertyToID("ColorB");
privatevoidUpdate()
Shader.SetGlobalVector(SunDir,transform.up);
publicstaticvoidUpdateMe(LightColorTestObjectthing)
thing.mR.material.SetColor(ColorA,Color.Lerp(thing.color,Inst.colorA,Inst.colorALerp).ToHLS().SetLuminace(Inst.colorALuminance).SetSaturation(Inst.colorASaturation));
thing.mR.material.SetColor(ColorB,Color.Lerp(thing.color,Inst.colorB,Inst.colorBLerp).ToHLS().SetLuminace(Inst.colorBLuminance).SetSaturation(Inst.colorBSaturation));
return;
thing.mR.material.SetColor(ColorA,thing.color.ToHLS().HueSlerp(Inst.colorA.ToHLS(),Inst.colorALerp).SetLuminace(Inst.colorALuminance).SetSaturation(Inst.colorASaturation));
thing.mR.material.SetColor(ColorB,thing.color.ToHLS().HueSlerp(Inst.colorB.ToHLS(),Inst.colorBLerp).SetLuminace(Inst.colorBLuminance).SetSaturation(Inst.colorBSaturation));
publicclassLightColorTestObject:MonoBehaviour
publicColorcolor;
publicMeshRenderermR;
privatevoidOnEnable()
UpdateColor();
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
UpdateColor();
LightColorTest.UpdateMe(this);
privatevoidUpdateColor()
constfloatyShift=1f/18;
color=newColor(1,0,0,1).ToHLS().ShiftHue(Random.Range(0,18)*yShift);
publicclassNewColorGen:MonoBehaviour
publicinthueSteps,satSteps;
privateinttintSteps;
publicfloathueOffset;
[Space]
publicfloattintMin;
publicfloattintMax,satMin;
[Space]
publicint[]shiftMap;
[Space]
publicColorcheckColor;
[Space]publicfloat[]hueOffsets;
publicboolautoStart;
publicboolshowUsedColors;
privateconstintcount=1024;
privateMeshRenderermR,hueMR,a,b;
privateTexture2Dtex,hueTex;
publicstaticreadonlyColor[]colors=newColor[count];
privateColor[]hueColors;
privateinthuePick;
privatestaticreadonlyintColor=Shader.PropertyToID("_Color");
privateColor[]palette;
privateint[]paletteIDs;
privatebool[]used;
privatevoidAwake()
Transformt=transform;
hueMR=t.GetChild(0).GetComponent<MeshRenderer>();
a=t.GetChild(1).GetComponent<MeshRenderer>();
b=t.GetChild(2).GetComponent<MeshRenderer>();
hueMR.transform.SetParent(null);
a.transform.SetParent(null);
b.transform.SetParent(null);
palette=HoudiniUsed();//Resources.Load<Palette>("Palette").colors;
paletteIDs=newint[palette.Length];
mR=GetComponent<MeshRenderer>();
if(!autoStart)
return;
Init();
publicvoidInit()
tintSteps=Mathf.FloorToInt(Mathf.Floor((float)count/hueSteps)/satSteps);
floatscale=hueMR.transform.localScale.x;
hueMR.transform.localScale=newVector3(scale,scale*((float)satSteps/tintSteps),scale);
hueColors=newColor[satSteps*tintSteps];
if(count==1024)
tex=newTexture2D(32,32){filterMode=FilterMode.Point};
else
if(count==2048)
tex=newTexture2D(32,64){filterMode=FilterMode.Point};
scale=transform.localScale.x;
transform.localScale=newVector3(scale*.5f,scale,scale);
else
tex=newTexture2D(64,64){filterMode=FilterMode.Point};
mR.material.mainTexture=tex;
hueTex=newTexture2D(tintSteps,satSteps){filterMode=FilterMode.Point};
hueMR.material.mainTexture=hueTex;
used=newbool[tintSteps*satSteps];
TexUpdate();
privatevoidTexUpdate()
tex.SetPixels(GeneratCrazy(hueSteps,satSteps,hueOffsets));
tex.Apply();
UpdateHueTex();
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
TexUpdate();
if(Input.GetKeyDown(KeyCode.RightArrow))
huePick=(int)Mathf.Repeat(huePick+1,hueSteps);
UpdateHueTex();
if(Input.GetKeyDown(KeyCode.LeftArrow))
huePick=(int)Mathf.Repeat(huePick-1,hueSteps);
UpdateHueTex();
if(Input.GetKeyDown(KeyCode.D))
showUsedColors=!showUsedColors;
UpdateHueTex();
a.material.SetColor(Color,checkColor);
b.material.SetColor(Color,colors[checkColor.ClosestColorIndex(colors)]);
privatevoidUpdateHueTex()
if(!hueMR.gameObject.activeInHierarchy)
return;
for(inti=0;i<palette.Length;i++)
paletteIDs[i]=palette[i].ClosestColorIndex(colors);
for(inti=0;i<used.Length;i++)
used[i]=false;
for(inthue=0;hue<hueSteps;hue++)
intcolorIndex=0;
for(intsaturation=0;saturation<satSteps;saturation++)
for(inttint=0;tint<tintSteps;tint++)
intcolorID=hue*satSteps*tintSteps+saturation*tintSteps+tint;
for(inti=0;i<palette.Length;i++)
if(paletteIDs[i]==colorID)
used[colorIndex]=true;
break;
colorIndex++;
intindex=0;
for(intsaturation=0;saturation<satSteps;saturation++)
for(inttint=0;tint<tintSteps;tint++)
intcolorID=huePick*satSteps*tintSteps+saturation*tintSteps+tint;
/*boolusedColor=false;
for(inti=0;i<palette.Length;i++)
if(paletteIDs[i]==colorID)
hueColors[index++]=colors[colorID];
usedColor=true;
break;
if(!usedColor)
hueColors[index++]=colors[colorID].Multi(.25f);*/
if(showUsedColors)
hueColors[index]=colors[colorID].Multi(used[index]?1:.25f);
index++;
else
hueColors[index++]=colors[colorID];
hueTex.SetPixels(hueColors);
hueTex.Apply();
publicstaticColor[]GeneratCrazy(inthSteps,intsSteps,float[]hueOffsets,booladdOldColors=false)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=1f/saturationSteps;
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=1f/(tintColors+1);
floattintOffset=tintShift*2f;
tintShift=1f/(tintColors+3.5f);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=count-totalHueColors;
if(addOldColors)
greyColors-=PaletteSource.Get.oldColors.Length;
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift+hueOffsets[hue]*hueShift;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=saturationShift+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue=tintOffset+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
if(addOldColors)
for(inti=0;i<PaletteSource.Get.oldColors.Length;i++)
colors[index++]=PaletteSource.Get.oldColors[i];
returncolors;
publicstaticColor[]HoudiniUsed(boolgetAll=false)
string[]colorLines=DesktopTxt.Read("oldhoudinicolors",".spn");
List<Color>oldColors=newList<Color>();
for(inti=0;i<colorLines.Length;i++)
stringline=colorLines[i].Replace("","").Replace("{","").Replace("}","");
string[]parts=line.Split(',');
oldColors.Add(newColor(float.Parse(parts[0]),float.Parse(parts[1]),float.Parse(parts[2]),1));
if(getAll)
returnoldColors.ToArray();
string[]idLines=DesktopTxt.Read("houdiniused",".spn");
List<int>colorIDs=newList<int>();
for(inti=0;i<idLines.Length;i++)
if(!idLines[i].Contains("/"))
colorIDs.AddUnique(int.Parse(idLines[i]));
List<Color>usedColors=newList<Color>();
for(inti=0;i<colorIDs.Count;i++)
usedColors.Add(oldColors[colorIDs[i]]);
Debug.Log(usedColors.Log());
returnusedColors.ToArray();
publicstaticColor[]Generate(inthSteps,intsSteps)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=1f/(saturationSteps);
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=1f/(tintColors+1);
floattintOffset=tintShift*2f;
tintShift=1f/(tintColors+3.5f);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=count-totalHueColors;
Debug.Log("Tint:"+tintColors+"-Hue:"+totalHueColors+"-Grey:"+greyColors);
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=saturationShift+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue=tintOffset+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
returncolors;
publicstaticColor[]GenerateNew(inthSteps,intsSteps,floathueOffset)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=1f/(saturationSteps);
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=1f/(tintColors+1);
floattintOffset=tintShift*2f;
tintShift=1f/(tintColors+3.5f);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=count-totalHueColors;
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift+hueOffset*hueOffset;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=saturationShift+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue=tintOffset+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
returncolors;
publicstaticColor[]GeneratCrazy2(inthSteps,intsSteps,float[]hueOffsets,floattintMin,floattintMax)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=1f/(saturationSteps);
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=(tintMax-tintMin)/(tintColors+1);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=count-totalHueColors;
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift+hueOffsets[hue]*hueShift;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=saturationShift+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue=tintMin+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
returncolors;
publicstaticColor[]GenerateClamped(floatsatMin,floatsatMax,floattintMin,floattintMax,inthSteps,intsSteps,booldebug=false,int[]shiftMap=null)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=(satMax-satMin)/(saturationSteps-1);
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=(tintMax-tintMin)/(tintColors-1);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=Mathf.Min(32,count-totalHueColors);
boolusesShiftMap=shiftMap!=null&&tintColors==shiftMap.Length;
if(debug)
Debug.Log("Tint:"+tintColors+"-Hue:"+totalHueColors+"-Grey:"+greyColors);
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=satMin+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue;
if(usesShiftMap)
tintValue=tintMin+tint*tintShift+tintShift*shiftMap[tint];
else
tintValue=tintMin+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
while(index<count)
colors[index++]=newColor(0,0,0,1);
returncolors;
publicstaticColor[]GenerateClampedShift(floatsatMin,floatsatMax,floattintMin,floattintMax,inthSteps,intsSteps,float[]hueShifts)
inthueSteps=hSteps;
intsaturationSteps=sSteps;
floathueShift=1f/hueSteps;
floatsaturationShift=(satMax-satMin)/(saturationSteps-1);
inthueColors=Mathf.FloorToInt((float)count/hueSteps);
inttintColors=Mathf.FloorToInt((float)hueColors/(saturationSteps));
floattintShift=(tintMax-tintMin)/(tintColors-1);
inttotalHueColors=tintColors*saturationSteps*hueSteps;
intgreyColors=Mathf.Min(32,count-totalHueColors);
intindex=0;
for(inthue=0;hue<hueSteps;hue++)
floathueValue=hue*hueShift;
for(intsat=0;sat<saturationSteps;sat++)
floatsaturationValue=satMin+sat*saturationShift;
for(inttint=0;tint<tintColors;tint++)
floattintValue=tintMin+tint*tintShift;
colors[index++]=newHLS(hueValue,tintValue,saturationValue);
floatgreyShift=1f/(greyColors-1);
for(intgrey=0;grey<greyColors;grey++)
floatgreyValue=grey*greyShift;
colors[index++]=newHLS(1,greyValue,0);
while(index<count)
colors[index++]=newColor(0,0,0,1);
returncolors;
publicclassShowUsedColorHues:MonoBehaviour
privatestaticreadonlyint[]notUsed={5,7,17,26,27,28,29};
privatestaticbool[]skip;
[Range(0,1)]
publicfloatmin,max;
privatevoidStart()
GeneratePaletteTex();
privatevoidOnValidate()
floatcenter=(max+min)*.5f;
min=Mathf.Max(0,Mathf.Min(min,center-.025f));
max=Mathf.Min(1,Mathf.Max(max,center+.025f));
if(Application.isPlaying)
GeneratePaletteTex();
privatevoidGeneratePaletteTex()
if(!Palette.Initialized)
Palette.Load();
if(skip==null)
skip=newbool[Palette.Colors.Length];
for(inti=0;i<notUsed.Length;i++)
skip[notUsed[i]]=true;
constintresolution=256;
HLSbaseColor=newHLS(1,.5f,1);
Color[]compareColors=newColor[resolution*3];
for(inti=0;i<resolution;i++)
compareColors[i]=baseColor.ShiftHue(i*(1f/resolution));
compareColors[i+resolution]=newColor(.05f,.05f,.05f,1);
compareColors[i+resolution*2]=baseColor.ShiftHue(Mathf.Floor(i*(1f/resolution)*16)/16);
for(inti=0;i<Palette.Colors.Length;i++)
if(!skip[i])
HLShls=Palette.Colors[i].ToHLS();
if(hls.s<min||hls.s>max)
continue;
floathueLerp=hls.h;
compareColors[Mathf.FloorToInt(hueLerp*resolution)+resolution]=Palette.Colors[i];
Texture2Dtex=newTexture2D(resolution,3)
filterMode=FilterMode.Point,
wrapMode=TextureWrapMode.Clamp
tex.SetPixels(compareColors);
tex.Apply();
GetComponent<MeshRenderer>().material.mainTexture=tex;
publicclassSliderMapping:MonoBehaviour{
publicTransforma,b,c;
[Space(10)]
publicfloatspeed;
[Space(10)]
publicfloatlength;
privatefloatr;
publicVector2remap;
privatevoidUpdate()
Vector3pointA=V3.left*length*.5f;
Vector3pointB=V3.right*length*.5f;
r+=Time.deltaTime*speed;
floataRange=Mth.SmoothPP(0,1,r);
floatbRange=Mth.DampedRange(aRange,remap.x,remap.y);
a.position=Vector3.Lerp(pointA,pointB,aRange)+V3.up*2;
b.position=Vector3.Lerp(pointA,pointB,bRange)+V3.down*2;
c.position=Vector3.Lerp(pointA,pointB,Ease.FF(Mathf.PingPong(r,1)))+V3.down*4;
publicclassEyeTest:MonoBehaviour
publicEye[]eyes;
[Space(10)]
publicVector2eyeSize;
publicVector2pupilSize;
[Space(10)]
publicfloattargetDistance;
privatefloatshock,focus;
privatestaticfloatblinkTime;
privatevoidAwake()
for(inti=0;i<2;i++)
eyes[i].Setup(transform);
privatevoidUpdate()
floatheadAngle=Mathf.Lerp(-180,180,Mathf.PerlinNoise(Time.realtimeSinceStartup*.05f,.24f));
floatheadAngle2=Mathf.Lerp(-3,3,Mathf.PerlinNoise(Time.realtimeSinceStartup*1.65f,.24f));
transform.rotation=Quaternion.AngleAxis(headAngle+headAngle2,Vector3.forward);
shock=Mathf.Clamp01(shock+(Input.GetMouseButton(1)?10:-10)*Time.deltaTime);
focus=Mathf.Clamp01(focus+(Input.GetMouseButton(2)?10:-10)*Time.deltaTime);
floatshakyTime=Time.realtimeSinceStartup*12;
Vector2animEyeSize=eyeSize*(1+shock*.15f)*(1-focus*Mth.SmoothPP(-.02f,.01f,shakyTime));
Vector2animPupilSize=pupilSize*(1-shock*.4f)*(1+focus*Mth.SmoothPP(.24f,.31f,shakyTime));
Vector3targetPos=Camera.main.ScreenToWorldPoint(Input.mousePosition).SetZ(targetDistance);
Vector3localTargetPos=transform.InverseTransformPoint(targetPos);
floatblink=GetBlink();
for(inti=0;i<2;i++)
eyes[i].LookAt(animEyeSize,animPupilSize,localTargetPos,blink);
privatestaticfloatGetBlink()
floatnow=Time.realtimeSinceStartup;
floatt=(now-blinkTime)*5;
if(t<0)
return1;
if(t>1)
blinkTime=now+Random.Range(.6f,3f);
return1;
returnMathf.Pow(1-Mathf.PingPong(t*2,1),2);
[System.Serializable]
publicclassEye
publicTransformeye,pupil;
publicVector3rootPos;
[Space(10)]
publicboolleft;
privateTransformhead;
privateconstfloatlookSqueeze=.04f,
topBlinkRatio=.98f;
publicvoidSetup(Transformhead)
this.head=head;
publicvoidLookAt(Vector2eyeSize,Vector2pupilSize,Vector3localTargetPos,floatblink)
constfloateyeDepth=3;
Vector3eyeCenter=rootPos+newVector3(0,0,eyeDepth);
Vector3dir=(localTargetPos-eyeCenter).normalized*eyeDepth;
Vector3pupilPos=rootPos+dir.SetZ(0);
floatpupilXLerp=Mathf.InverseLerp(-eyeSize.x*.5f+eyeCenter.x,eyeSize.x*.5f+eyeCenter.x,pupilPos.x);
floatpupilYLerp=Mathf.InverseLerp(-eyeSize.y*.5f+eyeCenter.y,eyeSize.y*.5f+eyeCenter.y,pupilPos.y);
floateyeSqueeze=blink*(.85f+pupilYLerp*.25f);
floatySize=eyeSize.y*(1+Mathf.Lerp(-lookSqueeze,lookSqueeze,!left?1-pupilXLerp:pupilXLerp));
floatyPos=ySize*-.5f*(1-eyeSqueeze)*topBlinkRatio+ySize*.5f*(1-eyeSqueeze)*(1-topBlinkRatio);
floatyScale=ySize*eyeSqueeze;
Vector2eyeP=eyeCenter+newVector3(0,yPos);
Vector2eyeS=newVector2(eyeSize.x,yScale);
eye.localPosition=rootPos+newVector3(0,yPos);
eye.localScale=newVector3(eyeS.x,eyeS.y,.2f);
pupilPos=newVector2(Mathf.Clamp(pupilPos.x-eyeP.x,eyeS.x*-.5f,eyeS.x*.5f),
Mathf.Clamp(pupilPos.y-eyeP.y,eyeS.y*-.5f,eyeS.y*.5f));
floatxMinSquish=Mathf.Max(0,-(pupilPos.x-pupilSize.x*.5f+eyeS.x*.5f));
floatxMaxSquish=Mathf.Max(0,pupilPos.x+pupilSize.x*.5f-eyeS.x*.5f);
floatyMinSquish=Mathf.Max(0,-(pupilPos.y-pupilSize.y*.5f+eyeS.y*.5f));
floatyMaxSquish=Mathf.Max(0,pupilPos.y+pupilSize.y*.5f-eyeS.y*.5f);
pupil.localPosition=eyeP.V3()+newVector3(pupilPos.x-xMaxSquish*.5f+xMinSquish*.5f,
pupilPos.y-yMaxSquish*.5f+yMinSquish*.5f,-.2f);
pupil.localScale=newVector3(pupilSize.x-xMaxSquish-xMinSquish,
pupilSize.y-yMaxSquish-yMinSquish,.2f);
privatevoidDebugLines(Vector3eyeCenter,Vector3dir,Vector3pupilPos)
DRAW.Vector(head.TransformPoint(eyeCenter),
head.TransformDirection(dir)).SetColor(Color.red);
DRAW.Circle(pupilPos,.2f,20).SetColor(Color.magenta).Fill(1);
publicclassForceAnim:MonoBehaviour
publicfloatstartValue,endValue,lastValue;
[Space]
publicfloatforce;
[Space]publicfloatdamp;
publicfloatmulti,multiB;
[Range(0,1)]
publicfloatstepTwo,testEnd;
[Space]
[Range(0,1)]
publicfloataccelMid;
publicfloattestLerp;
[Range(-1,1)]
publicfloatspeed;
privatereadonlyPendulumMotionpendulumA=newPendulumMotion();
privatereadonlyAccelMotionaccel=newAccelMotion();
privatevoidUpdate()
constfloatgraphSize=40;
Vector3right=Vector3.right*graphSize;
DRAW.Arrow(Vector3.zero,right,.25f);
DRAW.Arrow(Vector3.zero,Vector3.up*graphSize*.25f,.25f);
DRAW.Arrow(Vector3.zero,Vector3.up*graphSize*-.25f,.25f);
intmin=Mathf.CeilToInt(-graphSize*.25f)+1;
intmax=Mathf.FloorToInt(graphSize*.25f);
for(inti=min;i<max;i++)
DRAW.Vector(Vector3.up*i,Vector3.left*.5f);
pendulumA.Setup(startValue,force,endValue,multi,damp);
floatstartB=pendulumA.GetValue(stepTwo*graphSize);
floatoneForceB=pendulumA.GetForce(stepTwo*graphSize);
accel.Setup(startB,oneForceB,lastValue,(1f-stepTwo)*graphSize);
pendulumA.DrawRange(0,stepTwo*graphSize,Color.green);
accel.DrawRange(0,(1f-stepTwo)*graphSize,COLOR.purple.magenta,stepTwo*graphSize);
floatlerp=testEnd>stepTwo?testEnd-stepTwo:testEnd;
CoolMotionmotion=testEnd>stepTwo?accelasCoolMotion:pendulumA;
floatsin=motion.GetValue(lerp*graphSize);
Vector2checkPos=newVector2(testEnd*graphSize,sin);
Vector2checkSlope=motion.GetMVOne(lerp*graphSize).normalized;
DRAW.Vector(checkPos,checkSlope*50).SetColor(COLOR.blue.cornflower.A(.25f)).Fill(1);
Vector2turned=checkSlope.Rot90();
DRAW.Vector(checkPos+turned*-.5f,turned).SetColor(COLOR.blue.cornflower.A(.25f)).Fill(1);
testLerp=Mth.Repeat(0,1,testLerp+Time.deltaTime*.15f*speed);
DRAW.Vector(newVector3(testLerp*graphSize,-50f*graphSize),Vector3.up*100*graphSize).SetColor(COLOR.yellow.fresh.A(.25f));
floatanimX=graphSize*testLerp;
Vector2checkPos,checkSlope;
if(testLerp<testEnd)
floatlerp=testLerp>stepTwo?testLerp-stepTwo:testLerp;
CoolMotionmotion=testLerp>stepTwo?accelasCoolMotion:pendulumA;
floatsin=motion.GetValue(lerp*graphSize);
checkPos=newVector2(animX,sin);
checkSlope=motion.GetMVOne(lerp*graphSize);
else
floatlerp=testEnd>stepTwo?testEnd-stepTwo:testEnd;
CoolMotionmotion=testEnd>stepTwo?accelasCoolMotion:pendulumA;
floatsin=motion.GetValue(lerp*graphSize);
checkPos=newVector2(testEnd*graphSize,sin);
checkSlope=motion.GetMVOne(lerp*graphSize);
floatendLerp=testLerp-testEnd;
checkPos+=newVector2(endLerp*graphSize,checkSlope.y*endLerp*graphSize);
DRAW.Circle(checkPos,.2f,40).SetColor(COLOR.yellow.fresh).Fill(1,true);
DRAW.Arrow(checkPos,checkSlope,.25f).SetColor(COLOR.yellow.fresh).Fill(1);
DRAW.MultiCircle(newVector3(graphSize+2,checkPos.y),1.5f,3,.4f,7).SetColor(COLOR.yellow.fresh);
[System.Serializable]
publicclassPendulumMotion:CoolMotion
privatefloatsinScale,sinX,xOffset,slopeMulti,end;
publicvoidSetup(floatstartValue,floatstartForce,floatendValue,floatmulti,floatdamp)
this.endValue=endValue;
xOffset=startForce<0?Mathf.PI:0;
floatdir=startValue-endValue;
sinScale=Mathf.Abs(dir)+Mathf.Abs(startForce)*multi;
sinX=Mathf.Asin(dir*(1f/sinScale)*-1)*-Mathf.Sign(startForce);
end=damp>0?1f*sinScale/damp:float.MaxValue;
floatcosSlope=Mathf.Cos(sinX)*Mathf.Sign(startForce);
slopeMulti=cosSlope/startForce;
return;
floatfrequency=1f/sinScale/slopeMulti;
Debug.Log(frequency);
privatefloatGetAmplitude(floatx)
returnMathf.SmoothStep(0,1,1-Mathf.InverseLerp(0,end,x));
publicoverridefloatGetValue(floatx)
returnMathf.Sin(sinX+xOffset+x/sinScale/slopeMulti)*sinScale*GetAmplitude(x)
+endValue;
publicoverridefloatGetForce(floatx)
constfloatmul=1000f,frac=1f/mul;
return(GetValue(x+frac)-GetValue(x))*mul;
publicoverridevoidDrawRange(floatmin,floatmax,Colorcolor,floatoffset=0)
constintpointCount=1000;
DRAW.Shapeshape=DRAW.Shape.Get(pointCount);
for(inti=0;i<pointCount;i++)
floatlerp=i*(1f/(pointCount-1));
floatx=Mathf.Lerp(min,max,lerp);
shape.Set(i,newVector3(x+offset,GetValue(x))).SetColor(color);
floatgapLineLength=max-min;
intgaps=Mathf.FloorToInt(gapLineLength);
DRAW.GapVector(newVector3(min+offset,endValue),Vector3.right*gapLineLength,gaps).SetColor(COLOR.orange.coral);
[System.Serializable]
publicclassAccelMotion:CoolMotion
publicfloatstartValue,startForce,accel;
publicvoidSetup(floatstartValue,floatstartForce,floatendValue,floatduration)
this.startValue=startValue;
this.startForce=startForce;
this.endValue=endValue;
floatdisplacement=endValue-startValue;
accel=(2*displacement)/(duration*duration)-(2*startForce)/duration;
publicoverridefloatGetValue(floatx)
returnstartValue+startForce*x+.5f*accel*(x*x);
publicoverridefloatGetForce(floatx)
returnstartForce+accel*x;
[System.Serializable]
publicclassAccelStopMotion:CoolMotion
publicfloatstartValueA,
startForceA,
accelA,
startValueB,
startForceB,
accelB;
privatefloatmid;
publicvoidSetup(floatstartValue,floatstartForce,floatmidFraction,floatendValue,floatduration)
startValueA=startValue;
startForceA=startForce;
this.endValue=endValue;
mid=duration*midFraction;
startValueB=startValue+(endValue-startValue)*.5f;
floatdisplacement=startValueB-startValue;
floattime=mid;
accelA=(2*displacement)/(time*time)-(2*startForceA)/time;
startForceB=GetForce(mid);
floatdisplacement=endValue-startValueB;
floattime=duration-mid;
accelB=Mathf.Pow((2*Mathf.Abs(displacement))/(time*time),2)*-Mathf.Sign(startForceB);
publicoverridefloatGetValue(floatx)
if(x<=mid)
returnstartValueA+startForceA*x+.5f*accelA*(x*x);
x-=mid;
returnstartValueB+startForceB*x+.5f*accelB*(x*x);
publicoverridefloatGetForce(floatx)
if(x<=mid)
returnstartForceA+accelA*x;
x-=mid;
returnstartForceB+accelB*x;
publicabstractclassCoolMotion
protectedfloatendValue;
publicabstractfloatGetValue(floatx);
publicabstractfloatGetForce(floatx);
publicVector2GetMVOne(floatx)
returnnewVector2(1,GetForce(x));
publicvirtualvoidDrawRange(floatmin,floatmax,Colorcolor,floatoffset=0)
constintpointCount=1000;
DRAW.Shapeshape=DRAW.Shape.Get(pointCount);
for(inti=0;i<pointCount;i++)
floatlerp=i*(1f/(pointCount-1));
floatx=Mathf.Lerp(min,max,lerp);
shape.Set(i,newVector3(x+offset,GetValue(x))).SetColor(color);
floatgapLineLength=max-min;
intgaps=Mathf.FloorToInt(gapLineLength);
DRAW.GapVector(newVector3(min+offset,endValue),Vector3.right*gapLineLength,gaps).SetColor(COLOR.orange.coral);
publicclassFuckingCircleShit:MonoBehaviour
publicfloatradius;
publicintsegments;
publicfloatlimbLength;
[Range(0,1)]
publicfloatbendyness;
[Space(10)]
publicboolanim;
privatereadonlyVector3[]points=newVector3[100];
privatevoidOnEnable()
DRAW.Enabled=true;
privatevoidUpdate()
if(anim)
bendyness=Mth.SmoothPP(0,1,Time.realtimeSinceStartup*.4f);
floatlimb=limbLength/(segments-1);
floatlimbAngle=Mathf.Asin(limb*.5f/radius)*-Mathf.Rad2Deg*2;
Vector3chainPos=V3.zero;
for(inti=0;i<segments;i++)
floatsegmentAngle=(limbAngle*i-limbAngle*.5f)*bendyness;
QuaternionboneRot=Rot.Z(segmentAngle);
chainPos+=boneRot*V3.up.RotZ(segmentAngle,i>0?limb:0);
points[i]=chainPos;
Vector3rootTip=points[segments-1]-points[0];
floatrootAngle=Mathf.Asin(rootTip.magnitude*.5f/radius)*-Mathf.Rad2Deg*2;
Vector3aimPoint=V3.right*radius+V3.left.RotZ(rootAngle,radius);
QuaternionpartRot=Quaternion.FromToRotation(rootTip,aimPoint);
for(inti=0;i<segments;i++)
points[i]=partRot*points[i];
DRAW.Circle(V3.right*radius,radius,100).SetColor(Color.yellow);
for(inti=0;i<segments-1;i++)
Colorc=Color.Lerp(COLOR.blue.cornflower,COLOR.red.tomato,i/(segments-1f));
if(i<segments-2)
DRAW.DotVector(points[i],points[i+1]-points[i],.05f,.05f).SetColor(c).Fill(1);
else
DRAW.Arrow(points[i],points[i+1]-points[i],.2f).SetColor(c).Fill(1);
privatevoidOnValidate()
segments=Mathf.Max(2,segments);
limbLength=Mathf.Min(limbLength,radius*2);
radius=Mathf.Max(.1f,radius);
publicclassGeoTest:MonoBehaviour
privatefloatr;
privatevoidAwake()
r=Random.Range(0,400f);
privatevoidUpdate()
floatt=r+Time.realtimeSinceStartup;
Circlec1=newCircle(PerlinPos(t*.1f)*5,Mathf.Lerp(.1f,4,Mathf.PerlinNoise(t*.3f+6883f,.453f)));
Circlec2=newCircle(PerlinPos(t*.1f+463)*5,Mathf.Lerp(.1f,4,Mathf.PerlinNoise(t*.3f+583f,.453f)));
Colorc=c1.Contact(c2)?Color.red:Color.yellow;
c1.Draw(100).SetColor(c);
c2.Draw(100).SetColor(c);
Lineline=newLine(PerlinPos(t*.4f+6612)*4,PerlinPos(t*.4f+112.3f)*4);
ColorlineC=c1.Contact(line)||c2.Contact(line)?Color.magenta:Color.cyan;
line.Draw().SetColor(lineC);
Arcarc=newArc(PerlinPos(t*.4f+754)*2,
Mathf.Lerp(.1f,4,Mathf.PerlinNoise(t*.3f+583f,.453f)),
Mathf.Lerp(0,360,Mathf.PerlinNoise(t*.2f+23f,.453f)),
Mathf.Lerp(-1,1,Mathf.PerlinNoise(t*.43f+883f,.453f)));
arc.Draw(100).SetColor(Color.white);
privatestaticVector2PerlinPos(floatt)
returnnewVector2(Mathf.Lerp(-1,1,Mathf.PerlinNoise(t,.453f)),Mathf.Lerp(-1,1,Mathf.PerlinNoise(t+864,.453f)));
publicclassHeringboneWang:MonoBehaviour
privateconstintwidth=10;
publicclassBrick
publicVector2Intpos;
publicreadonlyboolhorizontal;
publicfloatlerp;
publicBrick(Vector2Intpos,boolhorizontal)
this.pos=pos;
this.horizontal=horizontal;
publicvoidDraw(BrickhoverBrick)
boolthisIsIt=this==hoverBrick;
lerp=Mathf.Lerp(lerp,thisIsIt?1:0,Time.deltaTime*(thisIsIt?16:6));
floatsize=1-lerp;
Vector2margin=newVector2(.45f,.45f)*size;
floatfill=.5f+lerp*.5f;
if(horizontal)
DRAW.Rectangle(pos+newVector2(.5f,0),newVector2(2,1)-margin).
SetColor(pos.y%2==0?COLOR.red.tomato:COLOR.yellow.fresh).Fill(fill,true);
else
DRAW.Rectangle(pos+newVector2(0,.5f),newVector2(1,2)-margin).
SetColor(pos.y%2==0?COLOR.turquois.aquamarine:COLOR.green.spring).Fill(fill,true);
privateList<Brick>bricks;
privateBrick[]brickGrid;
privatevoidAwake()
bricks=newList<Brick>();
brickGrid=newBrick[width*width];
Brickbrick=newBrick(newVector2Int(0,0),false);
bricks.Add(brick);
brickGrid[0]=brick;
brickGrid[width]=brick;
for(inty=0;y<width;y++)
for(intx=0;x<width;x++)
intindex=y*width+x;
Brickbrick=brickGrid[index];
if(brick!=null)
continue;
BrickleftBrick=x>0?brickGrid[index-1]:null;
if(leftBrick!=null)
if(leftBrick.horizontal)
brick=newBrick(newVector2Int(x,y),false);
if(y<width-1)
brickGrid[index+width]=brick;
elseif(leftBrick.pos.y==y)
brick=newBrick(newVector2Int(x,y-1),false);
if(y>0)
brickGrid[index-width]=brick;
else
brick=newBrick(newVector2Int(x,y),true);
if(x<width-1)
brickGrid[index+1]=brick;
bricks.Add(brick);
brickGrid[index]=brick;
continue;
BrickdownBrick=y>0?brickGrid[index-width]:null;
if(downBrick!=null)
if(!downBrick.horizontal)
brick=newBrick(newVector2Int(x,y),true);
if(x<width-1)
brickGrid[index+1]=brick;
elseif(downBrick.pos.x==x)
brick=newBrick(newVector2Int(x-1,y),true);
if(x>0)
brickGrid[index-1]=brick;
else
brick=newBrick(newVector2Int(x,y),false);
if(y<width-1)
brickGrid[index+width]=brick;
bricks.Add(brick);
brickGrid[index]=brick;
privatevoidUpdate()
Vector2hoverPos=Camera.main.ScreenPointToRay(Input.mousePosition).origin;
Vector2IntgridPos=newVector2Int(Mathf.RoundToInt(hoverPos.x),Mathf.RoundToInt(hoverPos.y));
BrickhoverBrick=null;
if(gridPos.x>=0&&gridPos.x<width&&
gridPos.y>=0&&gridPos.y<width)
hoverBrick=brickGrid[gridPos.y*width+gridPos.x];
for(inti=0;i<bricks.Count;i++)
bricks[i].Draw(hoverBrick);
publicclassBGPieceCounterUI:MonoBehaviour
privateTextMeshProUGUItext;
privateintmax;
privatevoidAwake()
text=GetComponent<TextMeshProUGUI>();
privatevoidUpdate()
if(GameManager.Running)
intcount=PlacerMeshes.GTF.ActiveCount;
max=Mathf.Max(max,count);
text.text=count.PrepString()+"|"+max;
publicclassBoolArrayTest:MonoBehaviour
privatebool[]v=newbool[1000000];
voidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
v.Clear();
/*for(inti=0;i<values.Length;i++)
values[i]=false;
publicpartialclassHouseGen
publicstructbyte4
publicbytea,b,c,d;
publicbyte4(bytea,byteb,bytec,byted)
this.a=a;
this.b=b;
this.c=c;
this.d=d;
publicbyte4(inta,intb,intc,intd)
this.a=(byte)a;
this.b=(byte)b;
this.c=(byte)c;
this.d=(byte)d;
[Serializable]
publicpartialstructCornerIDs
publicreadonlybytea,b,c,d;
publicreadonlyshortcornerValue;
publicCornerIDs(bytea,byteb,bytec,byted)
this.a=a;
this.b=b;
this.c=c;
this.d=d;
intaValue=a>0?1:0;
intbValue=b>0?1:0;
intcValue=c>0?1:0;
intdValue=d>0?1:0;
cornerValue=(short)(aValue*1000+bValue*100+cValue*10+dValue);
publicboolHasZoneChange
get
bytecompare=a!=0?a:b!=0?b:c!=0?c:d;
if(compare==0)
returnfalse;
returna!=0&&a!=compare||
b!=0&&b!=compare||
c!=0&&c!=compare||
d!=0&&d!=compare;
publicboolIsOnEdge{get{returna==0||b==0||c==0||d==0;}}
publicintArrayZone{get{return(a-1)/2;}}
publicbyteZone{get{returna!=0?a:b!=0?b:c!=0?c:d;}}
publicboolIsZoneCorner
get
returna!=b&&b==c&&c==d||
b!=c&&c==d&&d==a||
c!=d&&d==a&&a==b||
d!=a&&a==b&&b==c;
publicboolIsEdgeCorner
get
intcorners=(a!=0?1:0)+
(b!=0?1:0)+
(c!=0?1:0)+
(d!=0?1:0);
returncorners==1||corners==3;
publicboolAllTheSame{get{returna==b&&a==c&&a==d;}}
publicshortZoneCornerValue
get
byte4zones=ZoneCorners;
return(short)(zones.a*1000+zones.b*100+zones.c*10+zones.d);
publicbyte4ZoneCorners
get
bytebiggest=a>b?a:b;
biggest=biggest>c?biggest:c;
biggest=biggest>d?biggest:d;
returnnewbyte4(a==biggest?1:0,b==biggest?1:0,c==biggest?1:0,d==biggest?1:0);
publicboolFitsDir(CornerIDsid,Vector2Intdir,boolisAir)
switch(dir.y)
case-1:
switch(dir.x)
case-1:returnd!=0?d==id.a&&d==id.b&&d==id.c&&d==id.d:isAir;
case1:returnc!=0?c==id.a&&c==id.b&&c==id.c&&c==id.d:isAir;
case0:returnc==id.b&&d==id.a;
break;
case0:
switch(dir.x)
case-1:returna==id.b&&d==id.c;
case1:returnb==id.a&&c==id.d;
break;
case1:
switch(dir.x)
case-1:returna!=0?a==id.a&&a==id.b&&a==id.c&&a==id.d:isAir;
case1:returnb!=0?b==id.a&&b==id.b&&b==id.c&&b==id.d:isAir;
case0:returna==id.d&&b==id.c;
break;
returnfalse;
publicCornerIDsProjectDir(intdir=0)
switch(dir)
default:returnnewCornerIDs(a,b,b,a);//Up//
case1:returnnewCornerIDs(b,b,c,c);//Right//
case2:returnnewCornerIDs(d,c,c,d);//Down//
case3:returnnewCornerIDs(a,a,d,d);//Left//
publicCornerIDsFixSeams()
if(!HasZoneChange)
returnthis;
returnnewCornerIDs((byte)(a>0?1:0),(byte)(b>0?1:0),(byte)(c>0?1:0),(byte)(d>0?1:0));
publicstringLog()
return""+a+"|"+b+"|"+c+"|"+d;
publicstaticbooloperator==(CornerIDsone,CornerIDstwo)
returnone.a==two.a&&
one.b==two.b&&
one.c==two.c&&
one.d==two.d;
publicstaticbooloperator!=(CornerIDsone,CornerIDstwo)
return!(one==two);
[Serializable]
publicstructRectZone
publicBounds2Drect;
publicbytezone;
publicRectZone(Bounds2Drect,intzone)
this.rect=rect;
this.zone=(byte)zone;
publicintArrayZone{get{return(zone-1)/2;}}
[Serializable]
publicpartialstructPiece
publicVector2Intpos;
publicVector2Intsize;
publicCornerIDscornerIDs;
publicPieceTypetype;
publicintsqrArea;
publicintside;
publicPiece(Vector2Intpos,Vector2Intsize,CornerIDscornerIDs,PieceTypetype,intside)
this.pos=pos;
this.size=size;
this.cornerIDs=cornerIDs;
this.type=type;
sqrArea=size.x*size.y;
this.side=side;
publicPieceGrow(Vector2Intdir)
Vector2IntnewPos=pos.Add(Mathf.Min(dir.x,0),Mathf.Min(dir.y,0));
Vector2IntnewSize=size.Add(Mathf.Abs(dir.x),Mathf.Abs(dir.y));
returnnewPiece(newPos,newSize,cornerIDs,type,side);
publicPiece(Piecepiece,intside)
pos=piece.pos;
size=piece.size;
cornerIDs=piece.cornerIDs;
type=piece.type;
sqrArea=size.x*size.y;
this.side=side;
publicBounds2DGetBounds(HouseGengen)
returngen.CellAreaToBounds(pos,size);
publicboolContains(Vector2Intpoint)
returnpoint.x>=pos.x&&point.x<pos.x+size.x&&
point.y>=pos.y&&point.y<pos.y+size.y;
publicstringLog()
returncornerIDs.Log()+"-"+size+"-"+type;
publicenumPieceType:byte
Flat,
Detail,
Hole,
Window
[Flags]
publicenumCell
None=0,
House=1<<1,
FrontExtrude=1<<2,
BackExtrude=1<<3,
Corner=1<<4,
Edge=1<<5,
FrontSeam=1<<6,
BackSeam=1<<7,
SeamCorner=1<<8,
FrontSeamEdge=1<<9,
BackSeamEdge=1<<10,
FrontBlock=1<<11,
BackBlock=1<<12,
FrontWindow=1<<13,
BackWindow=1<<14,
Hole=1<<15,
Pillar=1<<16,
Seam=FrontSeam|BackSeam,
Extruded=FrontExtrude|BackExtrude,
Blocked=FrontBlock|BackBlock,
publicstaticclassCellHelp
publicstaticvoidSet(thisHouseGen.Cell[]array,HouseGen.Cellinfo,intindex)
array[index]|=info;
publicstaticboolIs(thisHouseGen.Cellvalue,HouseGen.Cellinfo)
return(value&info)==info;
publicstaticboolAny(thisHouseGen.Cellvalue,HouseGen.Cellinfo)
return(value&info)!=0;
publicclassHouseDataViewer:MonoBehaviour
publicHouseGen.CornerIDs[]cornerIDs;
privatereadonlyList<HouseGen.CornerIDs>usedCornerIDs=newList<HouseGen.CornerIDs>();
privateHouseGengen;
privatevoidAwake()
gen=GetComponent<HouseGen>();
if(gen==null)
enabled=false;
/*privatevoidLateUpdate()
usedCornerIDs.Clear();
HouseGen.CornerIDs[]cIDs=gen.frontIDs;
for(inti=0;i<cIDs.Length;i++)
if(cIDs[i].cornerCount>0)
usedCornerIDs.Add(cIDs[i]);
cornerIDs=usedCornerIDs.ToArray();
publicclassHouseDebugCam:MonoBehaviour
publicColora,b;
publicfloatpad;
[HideInInspector]publicboolback;
privateCameracam;
privateboolgrab;
privateVector2grabPos;
publicstaticBounds2DCamBounds;
publicfloatOrthoSize
get
returncam.orthographicSize;
privatevoidAwake()
cam=GetComponentInChildren<Camera>();
publicvoidUpdatePos()
if(!grab&&Input.GetKeyDown(KeyCode.Mouse0))
grab=true;
grabPos=Input.mousePosition;
if(grab&&Input.GetKeyUp(KeyCode.Mouse0))
grab=false;
if(grab)
Vector2grabPosNow=Input.mousePosition;
Vector3grabOffset=(grabPosNow-grabPos)/Screen.height*(cam.orthographicSize*2);
if(back)
grabOffset.x*=-1;
transform.position-=grabOffset;
grabPos=grabPosNow;
else
floatorthoSize=cam.orthographicSize;
cam.orthographicSize=Mathf.Clamp(orthoSize-Input.mouseScrollDelta.y*Time.deltaTime*orthoSize*3,20,1000);
UpdateBounds();
publicvoidSwitchSide()
back=!back;
transform.rotation=Quaternion.AngleAxis(back?180:0,Vector3.up);
cam.backgroundColor=back?b:a;
publicvoidFrameBuilding(Bounds2Dbounds)
bounds=bounds.Pad(pad);
transform.position=bounds.Center;
floataspect=cam.aspect;
floatverticalSize=bounds.Size.y*.5f;
floathorizontalSize=bounds.Size.x*.5f;
floataspectHorizontalSize=verticalSize*aspect;
cam.orthographicSize=Mathf.Max(verticalSize,verticalSize*(horizontalSize/aspectHorizontalSize));
grab=false;
publicvoidFrameHorizontal(Bounds2Dbounds)
bounds=bounds.Pad(pad);
transform.position=bounds.Center;
floataspect=cam.aspect;
floatverticalSize=bounds.Size.y*.5f;
floathorizontalSize=bounds.Size.x*.5f;
floataspectHorizontalSize=verticalSize*aspect;
cam.orthographicSize=verticalSize*(horizontalSize/aspectHorizontalSize);
grab=false;
publicvoidFrameVertical(Bounds2Dbounds)
bounds=bounds.Pad(pad);
transform.position=bounds.Center;
cam.orthographicSize=bounds.Size.y*.5f;
grab=false;
privatevoidUpdateBounds()
Vector2center=transform.position;
floatverticalSize=cam.orthographicSize*2;
floathorizontalSize=verticalSize*cam.aspect;
Vector2halfSize=newVector2(horizontalSize,verticalSize)*.5f;
CamBounds=newBounds2D(center-halfSize).Add(center+halfSize).Pad(pad);;
publicstaticboolIsVisible(Bounds2Dbounds)
returnCamBounds.Intersects(bounds);
publicclassHouseDraw:MonoBehaviour
publicbooldraw;
publicColorgridColor;
publicColorgridColor2;
[Space(10)]
publicTextMeshProUGUIui;
publicHouseDebugCamcam;
privatereadonlyStringBuilderuiBuilder=newStringBuilder(10000);
privateHouseGengen;
privateHouseRulesrules;
privateHouseOcclusionocclusion;
privateHousePiecePlacerpiecer;
privateHouseMeshermesher;
privatebool
drawRects=true,drawGrid=true,showBuilding=true,
showZones,showElements,showBlockedCells,showOcclusion,showSeams,showZoneSteps;
privateconstfloatcellSize=HouseGen.cellSize;
privateVector2center;
privatevoidAwake()
gen=GetComponent<HouseGen>();
rules=GetComponent<HouseRules>();
piecer=GetComponent<HousePiecePlacer>();
occlusion=GetComponent<HouseOcclusion>();
mesher=GetComponent<HouseMesher>();
publicvoidLateUpdate()
if(gen==null||!draw)
return;
drawGrid=drawGrid.KeySwitch(KeyCode.F1);
showBuilding=showBuilding.KeySwitch(KeyCode.F2);
drawRects=drawRects.KeySwitch(KeyCode.F3);
showZoneSteps=showZoneSteps.KeySwitch(KeyCode.F4);
showElements=showElements.KeySwitch(KeyCode.F5);
showBlockedCells=showBlockedCells.KeySwitch(KeyCode.F6);
showOcclusion=showOcclusion.KeySwitch(KeyCode.F7);
showSeams=showSeams.KeySwitch(KeyCode.F8);
showZones=showZones.KeySwitch(KeyCode.F9);
if(Input.GetKeyDown(KeyCode.Mouse2))
cam.SwitchSide();
if(Input.GetKeyDown(KeyCode.T))
cam.FrameBuilding(gen.houseBounds);
if(Input.GetKeyDown(KeyCode.Z))
cam.FrameHorizontal(gen.houseBounds);
if(Input.GetKeyDown(KeyCode.U))
cam.FrameVertical(gen.houseBounds);
if(center!=gen.houseBounds.Center)
center=gen.houseBounds.Center;
cam.FrameBuilding(gen.houseBounds);
cam.UpdatePos();
UI_Update();
boolfront=!cam.back;
floatside=cam.back?-1:1;
Colorgrid=cam.back?gridColor2:gridColor;
ColorcellColor=Color.Lerp(Color.black,grid,.3f);
if(cam.OrthoSize<70)
gen.DrawCornerIDs(!cam.back,showZoneSteps);
DRAW.Vector(Vector3.right*-1000,Vector3.right*2000).SetColor(Color.black);
if(showOcclusion)
occlusion.DrawBounds(side);
if(showBlockedCells)
rules.DrawElementCells(side);
if(drawRects)
gen.DrawRects(showBuilding,!cam.back,cam.OrthoSize>70&&cam.OrthoSize<140);
else
DrawPieces(piecer.fillPieces,cellColor,front,false);
DrawPieces(piecer.edgePieces,cellColor,front);
DrawPieces(piecer.cornerPieces,cellColor,front);
DrawPieces(piecer.seamPieces,cellColor,front,false);
DrawPieces(piecer.seamCornerPieces,cellColor,front,false);
if(showZones)
rules.DrawZones(side);
if(drawGrid)
DRAW.Grid(newVector3(0,gen.size.y*.5f),gen.size,gen.xCells+1,gen.yCells+1,HouseDebugCam.CamBounds).
SetColor(grid).SetDepth(2*side);
if(showSeams)
piecer.DrawSeams(side);
DrawPillars(cellColor,side);
if(showElements)
rules.DrawElements(side);
privatevoidUI_Update()
Colora=COLOR.red.tomato,b=COLOR.green.forest;
uiBuilder.Length=0;
uiBuilder.
AppendLine("F1:drawGrid".B_Switch(a,b,drawGrid)).
AppendLine("F2:showBuilding".B_Switch(a,b,showBuilding)).
AppendLine("F3:drawRects".B_Switch(a,b,drawRects)).
AppendLine("F4:showZoneSteps".B_Switch(a,b,showZoneSteps)).
AppendLine("F5:showElements".B_Switch(a,b,showElements)).
AppendLine("F6:showBlockedCells".B_Switch(a,b,showBlockedCells)).
AppendLine("F7:showOcclusion".B_Switch(a,b,showOcclusion)).
AppendLine("F8:showSeams".B_Switch(a,b,showSeams)).
AppendLine("F9:showZones".B_Switch(a,b,showZones)).
NewLine().
AppendLine("Generate:Minus".B_Color(Color.black)).
AppendLine("FrameCam:T".B_Color(Color.black)).
AppendLine("FrameCamH:Z".B_Color(Color.black)).
AppendLine("FrameCamV:U".B_Color(Color.black)).
AppendLine("SwitchSide:MB2".B_Color(Color.black));
ui.text=uiBuilder.ToString();
privatevoidDrawPieces(List<HouseGen.Piece>pieces,ColorcellColor,boolfront,boolcornerColors=true)
boolplaceMeshes=mesher!=null&&mesher.placeMeshes;
intpieceCount=pieces.Count;
for(inti=0;i<pieceCount;i++)
if(cornerColors)
pieces[i].DrawCornerColor(cellColor,front,gen,placeMeshes);
else
pieces[i].DrawSurfaceColor(cellColor,front,gen,placeMeshes);
privatevoidDrawPillars(ColorcellColor,floatside)
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
intindex=y*gen.xCells+x;
Vector2cellPos=gen.cellMin+newVector2(x*cellSize,y*cellSize);
Cellcell=gen.cells[index];
if(cell.Is(Cell.Pillar))
ColorpillarColor=y%2==0?Color.Lerp(cellColor,COLOR.blue.cornflower,.7f):Color.Lerp(cellColor,COLOR.turquois.seagreen,.5f);
if(!cell.Is(Cell.House))
DRAW.Rectangle(cellPos,newVector2(cellSize*.35f,cellSize)).SetColor(pillarColor).Fill(.5f,true).SetDepth(-2*side);
else
if(gen.frontIDs[index].cornerValue==1100)
DRAW.Rectangle(cellPos+newVector2(0,cellSize*-.25f),newVector2(cellSize,cellSize*.5f)).SetColor(pillarColor).Fill(.5f,true).SetDepth(-2*side);
else
DRAW.Rectangle(cellPos+newVector2(0,cellSize*+.25f),newVector2(cellSize,cellSize*.5f)).SetColor(pillarColor).Fill(.5f,true).SetDepth(-2*side);
publicpartialclassHouseGen
publicvoidDrawCornerIDs(boolfront,boolzoneSteps)
Colorc=Color.Lerp(Color.white,Color.black,.8f).A(.8f);
constfloatoffset=cellSize*-.2f;
CornerIDs[]corners=front?frontIDs:backIDs;
for(inty=0;y<yCells;y++)
for(intx=0;x<xCells;x++)
Vector2IntcellPos=newVector2Int(x,y);
intindex=CellPosToIndex(cellPos);
if(cells[index].Is(Cell.House))
Bounds2Db=IndexToCellBounds(index);
if(HouseDebugCam.IsVisible(b))
CornerIDscIDs=corners[index];
if(zoneSteps?cells[index].Is(front?Cell.FrontSeam:Cell.BackSeam):!cIDs.AllTheSame)
cIDs.DrawIDs(b.Pad(offset),c,zoneSteps);
publicpartialstructCornerIDs
publicvoidDrawIDs(Bounds2Dbounds,Colorcolor,boolshowZoneCornerValues=false)
if(showZoneCornerValues)
byte4zones=ZoneCorners;
DRAW.GUI_Text(zones.a.ToString(),bounds.TL,color);
DRAW.GUI_Text(zones.b.ToString(),bounds.TR,color);
DRAW.GUI_Text(zones.c.ToString(),bounds.BR,color);
DRAW.GUI_Text(zones.d.ToString(),bounds.BL,color);
return;
DRAW.GUI_Text(a.ToString(),bounds.TL,color);
DRAW.GUI_Text(b.ToString(),bounds.TR,color);
DRAW.GUI_Text(c.ToString(),bounds.BR,color);
DRAW.GUI_Text(d.ToString(),bounds.BL,color);
publicvoidDrawRects(boolshowBuilding,boolfront,boolzoneIds)
RectZone[]rectArr=showBuilding?useRectZones:allRectZones;
intcount=showBuilding?useRectCount:allRectCount;
for(inti=0;i<count;i++)
RectZonerectZone=rectArr[i];
if(!HouseDebugCam.IsVisible(rectZone.rect))
continue;
Vector2center=rectZone.rect.Center;
floata=.3f+Mathf.PingPong((center.x+center.y)*33.52113f,.7f);
intextrusionValue=useRectExtrusions[i];
boolbothSides=extrusionValue==3;
boolextruded=bothSides||(front?extrusionValue==1:extrusionValue==2);
floatpad=extruded?cellSize*-.25f:0;
Colorcolor=rules.GetZoneColor(rectZone.ArrayZone);
if(bothSides)
color=Color.Lerp(color,Color.white,Mathf.SmoothStep(0,.5f,Mathf.PingPong(Time.realtimeSinceStartup*10,1)));
rectZone.rect.Pad(pad).Draw().SetColor(color).Fill(a,true);
if(zoneIds)
DRAW.GUI_Text((rectZone.zone+(extruded?1:0)).PrepString(),rectZone.rect.Center);
/*if(showBuilding)
for(inti=0;i<padRectCount;i++)
RectZonerectZone=padRectZones[i];
if(!HouseDebugCam.IsVisible(rectZone.rect))
continue;
Vector2center=rectZone.rect.Center;
floata=.25f+Mathf.PingPong((center.x+center.y)*33.52113f,.25f);
rectZone.rect.Draw().SetColor(Color.black).Fill(a,true);
publicvoidDrawHouseCells(floatside)
for(inty=0;y<yCells;y++)
for(intx=0;x<xCells;x++)
Vector2IntcellPos=newVector2Int(x,y);
intindex=CellPosToIndex(cellPos);
if(cells[index].Is(Cell.House))
Bounds2Db=IndexToCellBounds(index);
if(HouseDebugCam.IsVisible(b))
b.Draw().SetColor(COLOR.blue.deepsky).Fill(.4f).SetDepth(side);
b.Draw().SetDepth(-1*side);
privateColorGetZoneColor(Vector2Intpos)
returnrules.GetZoneColor(frontIDs[CellPosToIndex(pos)].ArrayZone);
publicpartialstructPiece
privateColorCornerColor(ColorcellColor)
switch(cornerIDs.cornerValue)
default:returnColor.Lerp(cellColor,COLOR.green.spring,.7f);
case0110:
case1001:returnColor.Lerp(cellColor,COLOR.orange.coral,.7f);
case0011:
case1100:returnColor.Lerp(cellColor,COLOR.yellow.fresh,.7f);
case0111:
case1011:
case1101:
case1110:
case1000:
case0100:
case0010:
case0001:returnColor.Lerp(cellColor,COLOR.green.forest,.7f);
case1111:returnColor.Lerp(cellColor,COLOR.purple.maroon,.7f);
privateColorSurfaceColor(ColorcellColor,HouseGengen)
switch(type)
default:
casePieceType.Flat:returnColor.Lerp(cellColor,COLOR.grey.mid,.7f);
casePieceType.Detail:returnColor.Lerp(cellColor,gen.GetZoneColor(pos),.85f);
casePieceType.Hole:returnColor.Lerp(cellColor,Color.black,.7f);
casePieceType.Window:returnColor.Lerp(cellColor,COLOR.blue.cornflower,.7f);
publicvoidDrawCornerColor(ColorcellColor,boolfront,HouseGengen,booljustText=false)
DrawIt(CornerColor(cellColor),front,gen,justText);
publicvoidDrawSurfaceColor(ColorcellColor,boolfront,HouseGengen,booljustText=false)
DrawIt(SurfaceColor(cellColor,gen),front,gen,justText);
privatevoidDrawIt(Colorcolor,boolfront,HouseGengen,booljustText)
if(side!=0&&side!=(front?-1:1))
return;
floatdepth=front?2:-2;
Bounds2Db=GetBounds(gen);
if(!HouseDebugCam.IsVisible(b))
return;
Vector2center=b.Center;
if(size.x>1&&size.y>1)
DRAW.GUI_Text(sqrArea.PrepString(),center+Vector2.right*.25f,.75f);
if(justText)
return;
switch(type)
casePieceType.Hole:
Vector2s=(size-newVector2(.2f,.2f))*cellSize;
Vector2start=center+newVector2(s.x*-.5f,0);
DRAW.Shapeshape=DRAW.Shape.Get(20);
shape.Set(0,start);
shape.Set(1,center+newVector2(s.x*-.5f,s.y*.5f));
shape.Set(2,center+newVector2(s.x*.5f,s.y*.5f));
shape.Set(3,center+newVector2(s.x*.5f,s.y*-.5f));
shape.Set(4,center+newVector2(s.x*-.5f,s.y*-.5f));
shape.Set(5,start);
Vector2pointer=newVector2(Mathf.Min(s.x,s.y)*-.4f,0);
for(inti=0;i<13;i++)
shape.Set(6+i,(Vector3)center+Quaternion.AngleAxis(-30*i,Vector3.forward)*pointer);
shape.Set(19,start);
shape.SetColor(color).Fill(.5f,true).SetDepth(depth);
return;
switch(cornerIDs.cornerValue)
case0111:if(sqrArea==1)gotoNormal;
InwardEdge(center,0,color,depth);return;
case1011:if(sqrArea==1)gotoNormal;
InwardEdge(center,90,color,depth);return;
case1101:if(sqrArea==1)gotoNormal;
InwardEdge(center,180,color,depth);return;
case1110:if(sqrArea==1)gotoNormal;
InwardEdge(center,270,color,depth);return;
case1000:DrawOutwardsEdge(center,180,color,depth);return;
case0100:DrawOutwardsEdge(center,270,color,depth);return;
case0010:DrawOutwardsEdge(center,0,color,depth);return;
case0001:DrawOutwardsEdge(center,90,color,depth);return;
Normal:
b.Pad(.2f*-cellSize).Draw().SetColor(color).Fill(.5f,true).SetDepth(depth);
privatevoidDrawOutwardsEdge(Vector3center,floatangle,Colorcolor,floatdepth)
Quaternionrot=Quaternion.AngleAxis(-angle,Vector3.forward);
Vector2s=(size-newVector2(.4f,.4f))*cellSize;
Vector2start=center+rot*newVector2(s.x*.5f,s.y*.5f);
DRAW.Shapeshape=DRAW.Shape.Get(9);
shape.Set(0,start);
Vector3pin=center+rot*newVector2(s.x*.5f,s.y*-.5f);
shape.Set(1,pin);
Vector3curveStart=center+rot*newVector2(s.x*-.5f,s.y*-.5f);
shape.Set(2,curveStart);
Vector3dir=curveStart-pin;
shape.Set(3,pin+Quaternion.AngleAxis(-15,Vector3.forward)*dir);
shape.Set(4,pin+Quaternion.AngleAxis(-30,Vector3.forward)*dir);
shape.Set(5,pin+Quaternion.AngleAxis(-45,Vector3.forward)*dir);
shape.Set(6,pin+Quaternion.AngleAxis(-60,Vector3.forward)*dir);
shape.Set(7,pin+Quaternion.AngleAxis(-75,Vector3.forward)*dir);
shape.Set(8,start);
shape.SetColor(color).Fill(.5f,true).SetDepth(depth);
privatevoidInwardEdge(Vector3center,floatangle,Colorcolor,floatdepth)
Quaternionrot=Quaternion.AngleAxis(-angle,Vector3.forward);
Vector2s=(size-newVector2(.4f,.4f))*cellSize;
Vector2start=center+rot*newVector2(s.x*.5f,s.y*.5f);
DRAW.Shapeshape=DRAW.Shape.Get(11);
shape.Set(0,start);
shape.Set(1,center+rot*newVector2(s.x*.5f,s.y*-.5f));
Vector3curveStart=center+rot*newVector2(s.x*-.5f,s.y*-.5f);
shape.Set(2,curveStart);
Vector3pin=center+rot*newVector2(s.x*-.5f,s.y*.5f);
Vector3dir=(curveStart-pin).normalized*((size.x-1)*cellSize);
shape.Set(3,pin+dir);
shape.Set(4,pin+Quaternion.AngleAxis(15,Vector3.forward)*dir);
shape.Set(5,pin+Quaternion.AngleAxis(30,Vector3.forward)*dir);
shape.Set(6,pin+Quaternion.AngleAxis(45,Vector3.forward)*dir);
shape.Set(7,pin+Quaternion.AngleAxis(60,Vector3.forward)*dir);
shape.Set(8,pin+Quaternion.AngleAxis(75,Vector3.forward)*dir);
shape.Set(9,pin+Quaternion.AngleAxis(90,Vector3.forward)*dir);
shape.Set(10,start);
shape.SetColor(color).Fill(.5f,true).SetDepth(depth);
publicpartialclassHouseRules
publicvoidDrawElements(floatside)
Bounds2D[]elementArr=side<0?backElements:frontElements;
for(inti=0;i<elementArr.Length;i++)
Bounds2Db=elementArr[i];
if(HouseDebugCam.IsVisible(b))
b.Draw().Fill(.5f).SetDepth(-3*side);
publicvoidDrawElementCells(floatside)
Cellblocked=side<0?Cell.BackBlock:Cell.FrontBlock;
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
intindex=y*gen.xCells+x;
if(gen.cells[index].Is(blocked))
Bounds2Db=gen.IndexToCellBounds(index).Pad(cellSize*-.05f);
if(HouseDebugCam.IsVisible(b))
b.Draw().SetColor(COLOR.red.blood).SetDepth(-4*side);
publicvoidDrawZones(floatside)
intzoneCount=zonePoints.Length;
for(inti=0;i<zoneCount;i++)
ZonePointzP=zonePoints[i];
DRAW.Circle(zP.pos,Mathf.Sqrt(1f/zP.multi),100).SetColor(GetZoneColor(zP.zoneID)).Fill(.25f).SetDepth(-1*side);
publicColorGetZoneColor(intzoneID)
returnzones[zoneID].debugColor;
publicpartialclassHouseOcclusion
publicvoidDrawBounds(floatside)
for(inti=0;i<occludedBounds.Count;i++)
Bounds2Db=occludedBounds[i];
if(HouseDebugCam.IsVisible(b))
b.Draw().SetColor(Color.black).SetDepth(-5*side);
Colorc=Color.Lerp(COLOR.blue.navy,Color.white,.4f);
for(inti=0;i<notOccludedBounds.Count;i++)
Bounds2Db=notOccludedBounds[i];
if(HouseDebugCam.IsVisible(b))
b.Draw().SetColor(c).SetDepth(-5*side);
publicpartialclassHousePiecePlacer
privateconstfloatcellSize=HouseGen.cellSize;
publicvoidDrawSeams(floatside)
boolfront=side>0;
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
Vector2IntcellPos=newVector2Int(x,y);
intindex=gen.CellPosToIndex(cellPos);
Cellcell=gen.cells[index];
boolseam=cell.Is(Cell.Seam);
boolxSeam=false;//!extrudeSeams[index].AllTheSame;
if(!seam&&!xSeam)
continue;
Bounds2Db=gen.IndexToCellBounds(index);
if(!HouseDebugCam.IsVisible(b))
continue;
if(seam)
Colorc=cell.Is(Cell.SeamCorner)?COLOR.yellow.golden:COLOR.red.hot;
b.Draw().SetColor(c).Fill(.4f).SetDepth(side);
b.Draw().SetDepth(-1*side);
publicvoidDrawCornerDirection(floatside)
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
intindex=gen.CellPosToIndex(newVector2Int(x,y));
if(gen.cells[index].Is(Cell.Corner))
Vector2dir=gen.frontIDs[index].GrowDir();
DRAW.Arrow(gen.IndexToCellBounds(index).Center,dir*cellSize*.4f,cellSize*.2f).SetColor(COLOR.turquois.bright).Fill(1).SetDepth(side*-10);
publicvoidDrawEdgeDirection(floatside)
for(inti=0;i<edgePieces.Count;i++)
HouseGen.Piecep=edgePieces[i];
Vector2dir=edgePieces[i].cornerIDs.GrowDir();
DRAW.Arrow(p.GetBounds(gen).Center,dir*cellSize*1.4f,cellSize*.2f).SetColor(COLOR.turquois.bright).Fill(1).SetDepth(side*-10);
publicpartialclassHouseGen:Singleton<HouseGen>
publicVector2size;
[Space]
[Range(0,1000000)]
publicintseed;
publicboolrandomSeed;
[HideInInspector]publicintxCells,yCells,cellCount;
[HideInInspector]publicVector2cellMin,cell;
[HideInInspector]publicCornerIDs[]frontIDs,backIDs;
[HideInInspector]publicSystem.Randomrandom;
[HideInInspector]publicCell[]cells;
[HideInInspector]publicBounds2DhouseBounds;
[Header("RectInfo")]
[SerializeField]privateintallRectCount;
[SerializeField]privateintuseRectCount;
publicconstfloatcellSize=2.5f,
cellSizeMulti=1f/cellSize;
publicconstinttotalRects=100000;
privateHouseRulesrules;
privateHouseOcclusionocclusion;
privateHousePiecePlacerpiecer;
privateHouseMeshermesher;
privateList<RectZone>divideZones;
privateRectZone[]allRectZones,useRectZones;
privateint[]useRectExtrusions;
privatevoidAwake()
Palette.Load();
size=newVector2(Mathf.Round(size.x*cellSizeMulti)*cellSize,
Mathf.Round(size.y*cellSizeMulti)*cellSize);
xCells=Mathf.FloorToInt(size.x*cellSizeMulti)-1;
yCells=Mathf.FloorToInt(size.y*cellSizeMulti)-1;
cellCount=xCells*yCells;
cellMin=newVector2(size.x*-.5f+cellSize,cellSize-cellSize);
cell=newVector2(cellSize,cellSize);
frontIDs=newCornerIDs[cellCount];
backIDs=newCornerIDs[cellCount];
allRectZones=newRectZone[totalRects];
useRectZones=newRectZone[totalRects];
useRectExtrusions=newint[totalRects];
cells=newCell[cellCount];
divideZones=newList<RectZone>(totalRects);
rules=GetComponent<HouseRules>();
occlusion=GetComponent<HouseOcclusion>();
piecer=GetComponent<HousePiecePlacer>();
mesher=GetComponent<HouseMesher>();
rules.Init();
occlusion.Init();
piecer.Init();
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Minus))
Generate();
if(Input.GetKeyDown(KeyCode.Period))
randomSeed=!randomSeed;
publicstaticvoidGameStart()
if(Inst!=null&&Inst.gameObject.activeInHierarchy)
Inst.Generate();
publicstaticvoidGameLoad()
if(Inst!=null&&Inst.gameObject.activeInHierarchy&&Inst.mesher!=null)
Inst.mesher.meshes.Setup();
privatevoidGenerate()
StepOne();
StepTwo();
if(!Application.isMobilePlatform)
Debug.Log("--------------");
floatcombined=0;
Debug.Log(Timer.Log(Timer.Entry.CreateRects,refcombined));
Debug.Log(Timer.Log(Timer.Entry.DetectOccupiedCells,refcombined));
Debug.Log(Timer.Log(Timer.Entry.FindUsedCells,refcombined));
Debug.Log(Timer.Log(Timer.Entry.Piecer,refcombined));
Debug.Log(Timer.Log(Timer.Entry.Occlusion,refcombined));
Debug.Log(Timer.Log(Timer.Entry.TellLevelAboutOcclusion,refcombined));
Debug.Log(Timer.Log(Timer.Entry.MakePillars,refcombined));
Debug.Log("All:"+combined.ToString("F4")+"|FPS:"+Mathf.FloorToInt(1f/combined));
if(!Application.isEditor)
DesktopTxt.Write("GenSpeed",new[]{"All:"+combined.ToString("F4")+"|FPS:"+Mathf.FloorToInt(1f/combined)});
privatevoidStepOne()
CreateRects();
privatevoidStepTwo()
cells.Clear();
rules.DetectBlockedCells();
DetectOccupiedCells();
piecer.PieceItTogether();
occlusion.CalculateOcclusion();
MakePillars();
if(mesher!=null)
mesher.PlaceMeshes();
privatevoidCreateRects()
Timer.Start(Timer.Entry.CreateRects);
if(randomSeed)
seed=Random.Range(0,1000001);
random=newSystem.Random(seed);
rules.SetupZones();
allRectCount=0;
Bounds2DstartRect=newBounds2D(size*-.5f+Vector2.up*size.y*.5f).Add(size*.5f+Vector2.up*size.y*.5f).Pad(cellSize*-.5f);
divideZones.Add(rules.GetZone(startRect));
intcheckRects=1;
while(checkRects>0)
Vector2min,siz;
floatxMulti;
RectZonerectZone=divideZones.GetRemoveAt(random.Range(0,checkRects));
Bounds2Drect=rectZone.rect;
min=rect.BL;
siz=rect.Size;
checkRects--;
xMulti=rules.GetZone(rectZone.ArrayZone).xShift;
Bounds2Done,two;
if(siz.x*xMulti>siz.y)
floatblock=Mathf.Round(siz.x*random.Range(.2f,.8f)*cellSizeMulti)*cellSize;
Vector2s1=newVector2(block,siz.y);
Vector2s2=newVector2(siz.x-block,siz.y);
one=newBounds2D(min).Add(min+s1);
two=newBounds2D(min+newVector2(s1.x,0)).Add(min+newVector2(s1.x,0)+s2);
else
floatblock=Mathf.Round(siz.y*random.Range(.2f,.8f)*cellSizeMulti)*cellSize;
Vector2s1=newVector2(siz.x,block);
Vector2s2=newVector2(siz.x,siz.y-block);
one=newBounds2D(min).Add(min+s1);
two=newBounds2D(min+newVector2(0,s1.y)).Add(min+newVector2(0,s1.y)+s2);
for(inti=0;i<2;i++)
Bounds2Drect=i==0?one:two;
RectZonerectZone=rules.GetZone(rect);
floatareaThresh=rules.GetZone(rectZone.ArrayZone).minArea*1.3f;
if(rect.Area>=areaThresh)
divideZones.Add(rectZone);
checkRects++;
else
allRectZones[allRectCount++]=rectZone;
Timer.End(Timer.Entry.CreateRects);
privatevoidDetectOccupiedCells()
Timer.Start(Timer.Entry.DetectOccupiedCells);
useRectCount=0;
for(inti=0;i<allRectCount;i++)
RectZonerectZone=allRectZones[i];
Bounds2Drect=rectZone.rect;
if(rules.IntersectsPadElement(rect,rectZone.ArrayZone))
useRectZones[useRectCount++]=rectZone;
/*else
padRectZones[padRectCount++]=rectZone;*/
houseBounds=useRectZones[0].rect;
for(inti=1;i<useRectCount;i++)
houseBounds=houseBounds.Add(useRectZones[i].rect);
/*{
Bounds2DpadHouseBounds=houseBounds.Pad(cellSize*2);
intpadRects=0;
for(inti=0;i<padRectCount;i++)
RectZonerectZone=padRectZones[i];
Bounds2Drect=rectZone.rect;
if(padHouseBounds.Intersects(rect))
padRectZones[padRects++]=rectZone;
padRectCount=padRects;
intpadRects=0;
for(inti=0;i<padRectCount;i++)
RectZonerectZone=padRectZones[i];
Bounds2Drect=rectZone.rect;
for(inte=0;e<useRectCount;e++)
if(rect.Intersects(useRectZones[e].rect))
padRectZones[padRects++]=rectZone;
padRectCount=padRects;
frontIDs.Clear();
for(inti=0;i<useRectCount;i++)
RectZonerectZone=useRectZones[i];
Bounds2Drect=rectZone.rect;
Vector2Intmin,steps;
BoundsToCellArea(rect,outmin,outsteps);
bytezone=rectZone.zone;
for(inty=0;y<steps.y;y++)
for(intx=0;x<steps.x;x++)
Vector2IntrealPos=min.Add(x,y);
intindex=CellPosToIndex(realPos);
CornerIDscIDs=frontIDs[index];
bytea=x>0&&y<steps.y-1?zone:cIDs.a;
byteb=x<steps.x-1&&y<steps.y-1?zone:cIDs.b;
bytec=x<steps.x-1&&y>0?zone:cIDs.c;
byted=x>0&&y>0?zone:cIDs.d;
frontIDs[index]=newCornerIDs(a,b,c,d);
cells.Set(Cell.House,index);
for(intx=0;x<xCells;x++)
if(cells[x].Is(Cell.House))
frontIDs[x]=frontIDs[x].ProjectDir();
backIDs.CopyFrom(frontIDs);
for(inti=0;i<cellCount;i++)
if(cells[i].Is(Cell.House)&&frontIDs[i].HasZoneChange)
cells.Set(Cell.Seam,i);
useRectExtrusions.Clear();
for(inti=0;i<useRectCount;i++)
RectZonerectZone=useRectZones[i];
Vector2Intmin,steps;
BoundsToCellArea(rectZone.rect,outmin,outsteps);
PadRulespad=rules.GetZone(rectZone.ArrayZone).extrudePadRules;
Vector2IntpadSteps=steps+newVector2Int(pad.sides*2,pad.top+pad.bottom);
Vector2IntpadMin=min+newVector2Int(-pad.sides,-pad.bottom);
boolfront=true,back=true;
for(inty=0;y<padSteps.y;y++)
for(intx=0;x<padSteps.x;x++)
if(x<=pad.sides||x>=padSteps.x-1-pad.sides||
y<=pad.bottom||y>=padSteps.y-1-pad.top)
Vector2IntrealPos=padMin.Add(x,y);
if(!ValidCellPos(realPos))
front=false;
back=false;
gotoDoneChecking;
intindex=CellPosToIndex(realPos);
Cellc=cells[index];
if(c.Is(Cell.Seam))
front=false;
back=false;
gotoDoneChecking;
if(front&&c.Is(Cell.FrontBlock))
front=false;
if(back&&c.Is(Cell.BackBlock))
back=false;
if(!front&&!back)
gotoDoneChecking;
DoneChecking:
if(!front&&!back)
continue;
for(inty=0;y<steps.y;y++)
for(intx=0;x<steps.x;x++)
if(x==0||x==steps.x-1||
y==0||y==steps.y-1)
Vector2IntrealPos=min.Add(x,y);
if(realPos.y==0)
continue;
intindex=CellPosToIndex(realPos);
if(frontIDs[index].IsOnEdge)
gotoNotCool;
useRectExtrusions[i]=front&&back?3:front?1:2;
for(inty=0;y<steps.y;y++)
for(intx=0;x<steps.x;x++)
intindex=CellPosToIndex(min.Add(x,y));
if(front||back)
cells.Set(Cell.FrontExtrude,index);
CornerIDszones=frontIDs[index];
bytea=(byte)(zones.a+(x>0&&y<steps.y-1?1:0));
byteb=(byte)(zones.b+(x<steps.x-1&&y<steps.y-1?1:0));
bytec=(byte)(zones.c+(x<steps.x-1&&y>0?1:0));
byted=(byte)(zones.d+(x>0&&y>0?1:0));
frontIDs[index]=newCornerIDs(a,b,c,d);
if(back||front)
cells.Set(Cell.BackExtrude,index);
CornerIDszones=backIDs[index];
bytea=(byte)(zones.a+(x>0&&y<steps.y-1?1:0));
byteb=(byte)(zones.b+(x<steps.x-1&&y<steps.y-1?1:0));
bytec=(byte)(zones.c+(x<steps.x-1&&y>0?1:0));
byted=(byte)(zones.d+(x>0&&y>0?1:0));
backIDs[index]=newCornerIDs(a,b,c,d);
NotCool:;
for(intx=0;x<xCells;x++)
if(cells[x].Is(Cell.House))
frontIDs[x]=frontIDs[x].ProjectDir();
backIDs[x]=backIDs[x].ProjectDir();
for(inti=0;i<cellCount;i++)
if(cells[i].Is(Cell.House))
if(frontIDs[i].HasZoneChange)
cells.Set(Cell.FrontSeam,i);
if(backIDs[i].HasZoneChange)
cells.Set(Cell.BackSeam,i);
Timer.End(Timer.Entry.DetectOccupiedCells);
privatevoidMakePillars()
Timer.Start(Timer.Entry.MakePillars);
if(false)
for(inty=0;y<yCells;y++)
for(intx=0;x<xCells;x++)
if((x+y)%(y%3+3)!=0)
continue;
Vector2Intpos=newVector2Int(x,y);
intindex=CellPosToIndex(pos);
if(!cells[index].Is(Cell.House)||frontIDs[index].cornerValue!=1100)
continue;
intpillarLength=0;
while(true)
intcheckPillar=pillarLength+1;
Vector2IntcheckPos=pos.Add(0,-checkPillar);
if(!ValidCellPos(checkPos))
break;
intcheckIndex=CellPosToIndex(checkPos);
if(!cells[checkIndex].Is(Cell.House))
pillarLength++;
else
if(frontIDs[checkIndex].cornerValue!=0011)
pillarLength=0;
break;
if(pillarLength==0)
continue;
pillarLength+=2;
for(inti=0;i<pillarLength;i++)
Vector2IntcheckPos=pos.Add(0,-i);
if(ValidCellPos(checkPos))
cells.Set(Cell.Pillar,CellPosToIndex(checkPos));
Timer.End(Timer.Entry.MakePillars);
publicVector2IntIndexToCellPos(intindex)
returnnewVector2Int(index%xCells,index/xCells);
publicintCellPosToIndex(Vector2Intpos)
returnpos.y*xCells+pos.x;
publicboolValidCellPos(Vector2Intpos)
returnpos.x>=0&&pos.x<xCells&&pos.y>=0&&pos.y<yCells;
publicBounds2DIndexToCellBounds(intindex)
Vector2pos=cellMin+(Vector2)IndexToCellPos(index)*cellSize;
returnnewBounds2D(pos).Add(pos+cell);
publicvoidSetAreaBools(Vector2Introot,Vector2Intsize,bool[]bools,boolvalue)
for(inty=0;y<size.y;y++)
for(intx=0;x<size.x;x++)
bools[CellPosToIndex(root.Add(x,y))]=value;
publicvoidSetAreaCells(Vector2Introot,Vector2Intsize,CellcellInfo)
for(inty=0;y<size.y;y++)
for(intx=0;x<size.x;x++)
cells.Set(cellInfo,CellPosToIndex(root.Add(x,y)));
publicvoidBoundsToCellArea(Bounds2Drect,outVector2Intmin,outVector2Intsteps)
min=((rect.BL-cellMin)*cellSizeMulti).Vector2IntFloor();
Vector2Intmax=((rect.TR-cellMin)*cellSizeMulti).Vector2IntFloor();
steps=newVector2Int(max.x-min.x+1,max.y-min.y+1);
privateBounds2DCellAreaToBounds(Vector2Intpos,Vector2Intsize)
Vector2vSize=size;
Vector2c=cellMin+(pos+vSize*.5f)*cellSize;
Vector2s=vSize*cellSize;
returnnewBounds2D(c-s*.5f).Add(c+s*.5f);
namespaceHouse
publicstaticclassHouseHelp
privatestaticreadonlyDictionary<int,Vector2Int>cornerDirDict;
staticHouseHelp()
cornerDirDict=newDictionary<int,Vector2Int>
publicstaticVector2IntGrowDir(thisHouseGen.CornerIDsvalue)
returncornerDirDict[value.cornerValue];
publicstaticreadonlyVector2Int[]Dirs=
newVector2Int(0,1),
newVector2Int(1,1),
newVector2Int(1,0),
newVector2Int(1,-1),
newVector2Int(0,-1),
newVector2Int(-1,-1),
newVector2Int(-1,0),
newVector2Int(-1,1)
publicstaticVector2IntRandomAxisDir(System.Randomrandom)
returnDirs[random.Range(0,4)*2];
publicstaticintPieceID(thisHouseGen.CornerIDsvalue,boolfixIt=false)
if(fixIt)
value=value.FixSeams();
constintmaxZones=15,max=maxZones*2+1;
returnvalue.a*max*max*max+
value.b*max*max+
value.c*max+
value.d;
return(value.a!=0?value.a+1:0)*max*max*max+
(value.b!=0?value.b+1:0)*max*max+
(value.c!=0?value.c+1:0)*max+
(value.d!=0?value.d+1:0);
publicstaticintGetPieceID(inta,intb,intc,intd)
constintmaxZones=15;
constintmax=maxZones*2+1;
returna*max*max*max+
b*max*max+
c*max+
d;
publicclassHouseMesher:MonoBehaviour
publicboolplaceMeshes;
publicPlacerMeshesmeshes;
[HideInInspector]publicHouseGengen;
privateHousePiecePlacerpiecer;
privateconstfloatcellSize=HouseGen.cellSize;
privatereadonlyList<Piece>failedPieces=newList<Piece>();
privatereadonlyList<CornerIDs>failedCornerIds=newList<CornerIDs>();
privateintfailedPiecePick;
privatevoidAwake()
gen=GetComponent<HouseGen>();
piecer=GetComponent<HousePiecePlacer>();
publicvoidPlaceMeshes()
if(!placeMeshes)
return;
failedPieces.Clear();
failedPiecePick=0;
Level.ClearPieces();
PlacerMeshes.Clear(cellSize);
PlacePieces(piecer.fillPieces);
PlacePieces(piecer.cornerPieces);
PlacePieces(piecer.edgePieces);
PlacePieces(piecer.seamCornerPieces);
PlacePieces(piecer.seamPieces);
intfailedCount=failedPieces.Count;
if(failedCount>0)
Debug.LogFormat("Couldn'tmesh{0}Pieces!".B_Red(),failedCount);
failedCornerIds.Clear();
for(inti=0;i<failedCount;i++)
CornerIDscIDs=failedPieces[i].cornerIDs;
if(!failedCornerIds.Contains(cIDs))
failedCornerIds.Add(cIDs);
Debug.Log(cIDs.Log().B_Orange());
PlacerMeshes.Report();
privatevoidPlacePieces(List<Piece>pieces)
intfillCount=pieces.Count;
for(inti=0;i<fillCount;i++)
Piecepiece=pieces[i];
boolfoundPiece=true;
PlacerMeshes.Place(piece,gen,piece.side,reffoundPiece);
if(!foundPiece)
failedPieces.Add(piece);
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.F))
Piecepiece=failedPieces[failedPiecePick];
GameCam.CheckThisOut(piece.GetBounds(gen).Center,piece.side==0?GameCam.CurrentSide.front:piece.side==-1);
EditorCamControll.SetEditorFocus();
failedPiecePick=(failedPiecePick+1).Repeat(failedPieces.Count);
Debug.Log(piece.Log().B_Red());
publicpartialclassHouseOcclusion:MonoBehaviour
privateHouseGengen;
privatebool[]occlusionGen,occlusionGenB;
privatereadonlyList<Bounds2D>occludedBounds=newList<Bounds2D>(1000),
notOccludedBounds=newList<Bounds2D>(1000);
privateUniqueListoccluded,notOccluded;
publicvoidInit()
gen=GetComponent<HouseGen>();
occlusionGen=newbool[gen.cellCount];
occlusionGenB=newbool[gen.cellCount];
occluded=newUniqueList(gen.cellCount);
notOccluded=newUniqueList(gen.cellCount);
publicvoidCalculateOcclusion()
Timer.Start(Timer.Entry.Occlusion);
Profiler.BeginSample("Occlusion_FindOutline");
intcount=gen.cellCount;
for(inti=0;i<count;i++)
occlusionGen[i]=gen.cells[i].Is(Cell.House);
notOccluded.Clear();
for(inte=0;e<2;e++)
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
Vector2IntcellPos=newVector2Int(x,y);
intindex=gen.CellPosToIndex(cellPos);
if(!occlusionGen[index])
occlusionGenB[index]=false;
continue;
if(gen.cells[index].Is(Cell.Hole))
notOccluded.Add(index);
occlusionGenB[index]=false;
continue;
boolsolid=true;
for(inti=0;i<HouseHelp.Dirs.Length;i++)
Vector2Intneighbour=cellPos+HouseHelp.Dirs[i];
if(gen.ValidCellPos(neighbour))
intneighbourIndex=gen.CellPosToIndex(neighbour);
if(!occlusionGen[neighbourIndex]||gen.cells[neighbourIndex].Is(Cell.Hole))
solid=false;
break;
if(solid)
occlusionGenB[index]=true;
else
notOccluded.Add(index);
occlusionGenB[index]=false;
occlusionGen.CopyFrom(occlusionGenB);
occluded.Clear();
for(inti=0;i<count;i++)
if(occlusionGen[i])
occluded.Add(i);
Profiler.EndSample();
Profiler.BeginSample("Occlusion_OccludedBounds");
occludedBounds.Clear();
while(occluded.Length>0)
intindex=occluded.RemoveAt(gen.random.Range(0,occluded.Length));
occlusionGen[index]=false;
Piecep=newPiece(gen.IndexToCellPos(index),Vector2Int.one,newCornerIDs(1,1,1,1),0,0);
while(true)
Piecegrown=p.Grow(HouseHelp.RandomAxisDir(gen.random));
for(intyP=0;yP<grown.size.y;yP++)
for(intxP=0;xP<grown.size.x;xP++)
Vector2IntcheckPos=grown.pos.Add(xP,yP);
if(p.Contains(checkPos))
continue;
if(!gen.ValidCellPos(checkPos)||!occlusionGen[gen.CellPosToIndex(checkPos)])
gotoNotGrowing;
for(intyP=0;yP<grown.size.y;yP++)
for(intxP=0;xP<grown.size.x;xP++)
Vector2IntcheckPos=grown.pos.Add(xP,yP);
if(p.Contains(checkPos))
continue;
intcheckIndex=gen.CellPosToIndex(checkPos);
occlusionGen[checkIndex]=false;
occluded.Remove(checkIndex);
p=grown;
continue;
NotGrowing:
occludedBounds.Add(p.GetBounds(gen));
break;
Profiler.EndSample();
Profiler.BeginSample("Occlusion_NonOccludedBounds");
occlusionGenB.Clear();
for(inti=0;i<notOccluded.Length;i++)
occlusionGenB[notOccluded[i]]=true;
notOccludedBounds.Clear();
while(notOccluded.Length>0)
intindex=notOccluded.RemoveAt(gen.random.Range(0,notOccluded.Length));
occlusionGen[index]=false;
Piecep=newPiece(gen.IndexToCellPos(index),Vector2Int.one,newCornerIDs(1,1,1,1),0,0);
while(true)
Piecegrown=p.Grow(HouseHelp.RandomAxisDir(gen.random));
for(intyP=0;yP<grown.size.y;yP++)
for(intxP=0;xP<grown.size.x;xP++)
Vector2IntcheckPos=grown.pos.Add(xP,yP);
if(p.Contains(checkPos))
continue;
if(!gen.ValidCellPos(checkPos)||!occlusionGenB[gen.CellPosToIndex(checkPos)])
gotoNotGrowing;
for(intyP=0;yP<grown.size.y;yP++)
for(intxP=0;xP<grown.size.x;xP++)
Vector2IntcheckPos=grown.pos.Add(xP,yP);
if(p.Contains(checkPos))
continue;
intcheckIndex=gen.CellPosToIndex(checkPos);
occlusionGenB[checkIndex]=false;
notOccluded.Remove(checkIndex);
p=grown;
continue;
NotGrowing:
notOccludedBounds.Add(p.GetBounds(gen));
break;
Profiler.EndSample();
Timer.End(Timer.Entry.Occlusion);
Timer.Start(Timer.Entry.TellLevelAboutOcclusion);
Level.ClearOccluders();
for(inti=0;i<occludedBounds.Count;i++)
Level.AddWallBound(occludedBounds[i],true);
for(inti=0;i<notOccludedBounds.Count;i++)
Level.AddWallBound(notOccludedBounds[i],false);
Timer.End(Timer.Entry.TellLevelAboutOcclusion);
publicpartialclassHousePiecePlacer:MonoBehaviour
publicreadonlyList<Piece>edgePieces=newList<Piece>(10000),
cornerPieces=newList<Piece>(10000),
fillPieces=newList<Piece>(10000);
publicreadonlyList<Piece>seamPieces=newList<Piece>(10000),
seamCornerPieces=newList<Piece>(10000);
publicreadonlyList<Piece>allPieces=newList<Piece>(100000);
publicreadonlyList<Piece>potentialHoles=newList<Piece>(10000);
privatebool[]fillList;
privateint[]flush,justBlocked;
privateList<int>usedCells,frontUsed,backUsed;
privateHouseGengen;
privateHouseRulesrules;
privatereadonlyOrderRandomizerrandomizer=newOrderRandomizer(10000);
publicvoidInit()
gen=GetComponent<HouseGen>();
rules=GetComponent<HouseRules>();
usedCells=newList<int>(gen.cellCount);
frontUsed=newList<int>(gen.cellCount);
backUsed=newList<int>(gen.cellCount);
flush=newint[gen.cellCount];
justBlocked=newint[gen.cellCount];
fillList=newbool[gen.cellCount];
publicvoidPieceItTogether()
Timer.Start(Timer.Entry.Piecer);
FindUsed();
allPieces.Clear();
seamCornerPieces.Clear();
CollectEdges();
CollectSeams();
CollectFills();
Timer.End(Timer.Entry.Piecer);
privatevoidFindUsed()
Timer.Start(Timer.Entry.FindUsedCells);
usedCells.Clear();
for(inty=0;y<gen.yCells;y++)
for(intx=0;x<gen.xCells;x++)
intindex=gen.CellPosToIndex(newVector2Int(x,y));
if(gen.cells[index].Is(Cell.House))
usedCells.Add(index);
Timer.End(Timer.Entry.FindUsedCells);
privatevoidCollectEdges()
cornerPieces.Clear();
intusedCellCount=usedCells.Count;
for(inti=0;i<usedCellCount;i++)
intindex=usedCells[i];
Vector2Intpos=gen.IndexToCellPos(index);
CornerIDscorner=gen.frontIDs[index];
if(corner.IsEdgeCorner)
cornerPieces.Add(newPiece(pos,Vector2Int.one,corner,PieceType.Detail,0));
gen.cells.Set(Cell.Corner,usedCells[i]);
continue;
bytezone=corner.Zone;
switch(corner.cornerValue)
default:continue;
case1010:
cornerPieces.Add(newPiece(pos,Vector2Int.one,newCornerIDs(zone,0,0,0),PieceType.Detail,0));
cornerPieces.Add(newPiece(pos,Vector2Int.one,newCornerIDs(0,0,zone,0),PieceType.Detail,0));
break;
case0101:
cornerPieces.Add(newPiece(pos,Vector2Int.one,newCornerIDs(0,zone,0,0),PieceType.Detail,0));
cornerPieces.Add(newPiece(pos,Vector2Int.one,newCornerIDs(0,0,0,zone),PieceType.Detail,0));
break;
gen.cells.Set(Cell.Corner,usedCells[i]);
CellListRemoval(usedCells,Cell.Corner);
intcornersCount=cornerPieces.Count;
edgePieces.Clear();
intedgeCount=CreateEdges(cornerPieces,edgePieces,false);
CellListRemoval(usedCells,Cell.Edge);
for(inti=0;i<cornersCount;i++)
Piecepiece=cornerPieces[i];
intindex=gen.CellPosToIndex(piece.pos);
if(gen.cells[index].Is(Cell.Seam))
cornerPieces.RemoveAt(i);
i--;
cornersCount--;
seamCornerPieces.Add(piece);
for(intgrowStep=0;growStep<3;growStep++)
randomizer.Randomize(cornersCount,gen.random);
for(inti=0;i<cornersCount;i++)
if(gen.random.Chance(4,6))
intindex=randomizer[i];
cornerPieces[index]=GrowCorner(cornerPieces[index]);
CellListRemoval(usedCells,Cell.Corner);
for(inti=0;i<edgeCount;i++)
Pieceedge=edgePieces[i];
Piecetrimmed=TrimmEdgeIfInCorner(edge);
if(trimmed.sqrArea==0)
edgePieces.RemoveAt(i);
i--;
edgeCount--;
else
edgePieces[i]=trimmed;
edgeCount=EdgeDivide(edgePieces,6);
for(inti=0;i<edgeCount;i++)
Pieceedge=edgePieces[i];
intlength=edge.sqrArea;
if(length==1)
continue;
if(edge.size.x>edge.size.y)
for(intj=0;j<length;j++)
Vector2Intpos=edge.pos.Add(j,0);
intindex=gen.CellPosToIndex(pos);
if(gen.frontIDs[index].HasZoneChange)
edgePieces.RemoveAt(i);
i--;
edgeCount--;
if(j>0)
edgePieces.Add(newPiece(edge.pos,edge.size.Clamp(j),edge.cornerIDs,PieceType.Detail,0));
edgeCount++;
seamCornerPieces.Add(newPiece(pos,newVector2Int(1,1),edge.cornerIDs,PieceType.Detail,0));
if(j<length-1)
edgePieces.Add(newPiece(pos.Add(1,0),edge.size.Clamp(length-(j+1)),edge.cornerIDs,PieceType.Detail,0));
edgeCount++;
else
for(intj=0;j<length;j++)
Vector2Intpos=edge.pos.Add(0,j);
intindex=gen.CellPosToIndex(pos);
if(gen.frontIDs[index].HasZoneChange)
edgePieces.RemoveAt(i);
i--;
edgeCount--;
if(j>0)
edgePieces.Add(newPiece(edge.pos,edge.size.Clamp(j),edge.cornerIDs,PieceType.Detail,0));
edgeCount++;
seamCornerPieces.Add(newPiece(pos,newVector2Int(1,1),edge.cornerIDs,PieceType.Detail,0));
if(j<length-1)
edgePieces.Add(newPiece(pos.Add(0,1),edge.size.Clamp(length-(j+1)),edge.cornerIDs,PieceType.Detail,0));
edgeCount++;
for(intgrowStep=0;growStep<2;growStep++)
randomizer.Randomize(edgeCount,gen.random);
for(inti=0;i<edgeCount;i++)
if(gen.random.Chance(3,10))
intindex=randomizer[i];
edgePieces[index]=GrowEdge(edgePieces[index]);
CellListRemoval(usedCells,Cell.Edge);
intcount=cornerPieces.Count;
for(inti=0;i<count;i++)
cornerPieces[i]=SetRightZone(cornerPieces[i]);
intcount=edgePieces.Count;
for(inti=0;i<count;i++)
edgePieces[i]=SetRightZone(edgePieces[i]);
privatePieceSetRightZone(Piecepiece)
intvalue=piece.cornerIDs.cornerValue;
for(inty=0;y<piece.size.y;y++)
for(intx=0;x<piece.size.x;x++)
Vector2Intp=piece.pos.Add(x,y);
intindex=gen.CellPosToIndex(p);
CornerIDscIds=gen.frontIDs[index];
if(gen.frontIDs[index].cornerValue==value)
returnnewPiece(piece.pos,piece.size,cIds,piece.type,piece.side);
returnpiece;
privatePieceGrowCorner(Piecepiece)
if(gen.cells[gen.CellPosToIndex(piece.pos)].Is(Cell.Seam))
returnpiece;
Piecegrown=piece.Grow(piece.cornerIDs.GrowDir());
if(grown.pos.x<0||grown.pos.x+grown.size.x>=gen.xCells||
grown.pos.y<0||grown.pos.y+grown.size.y>=gen.yCells)
returnpiece;
Vector2IntcornerPos=piece.pos;
for(inty=0;y<grown.size.y;y++)
for(intx=0;x<grown.size.x;x++)
Vector2Intp=grown.pos.Add(x,y);
intindex=gen.CellPosToIndex(p);
if(gen.frontIDs[index]==piece.cornerIDs)
cornerPos=p;
gotoFoundCornerPos;
FoundCornerPos:
CornerIDscornerPosIDs=gen.frontIDs[gen.CellPosToIndex(cornerPos)];
for(inty=0;y<grown.size.y;y++)
for(intx=0;x<grown.size.x;x++)
Vector2Intp=grown.pos.Add(x,y);
if(piece.Contains(p)||p==cornerPos)
continue;
intindex=gen.CellPosToIndex(p);
Cellcell=gen.cells[index];
if(cell.Any(Cell.Corner|Cell.Seam|Cell.Blocked))
returnpiece;
Vector2IntdirToCell=(p-cornerPos).Normalized();
CornerIDscIDs=gen.frontIDs[index];
if((dirToCell.x==0||dirToCell.y==0)&&cIDs.IsEdgeCorner)
returnpiece;
boolisAir=!cell.Is(Cell.House);
if(!cornerPosIDs.FitsDir(cIDs,dirToCell,isAir))
returnpiece;
piece=grown;
gen.SetAreaCells(piece.pos,piece.size,Cell.Corner);
returnpiece;
privatePieceTrimmEdgeIfInCorner(Piecepiece)
boolrootIsChecked=gen.cells[gen.CellPosToIndex(piece.pos)].Is(Cell.Corner);
if(rootIsChecked&&piece.sqrArea==1)
returnnewPiece(piece.pos,Vector2Int.zero,piece.cornerIDs,piece.type,0);
if(piece.size.x>piece.size.y)
if(rootIsChecked)
piece=newPiece(newVector2Int(piece.pos.x+1,piece.pos.y),newVector2Int(piece.size.x-1,piece.size.y),piece.cornerIDs,piece.type,0);
Vector2Inttip=piece.pos.Add(piece.size.x-1,0);
if(gen.cells[gen.CellPosToIndex(tip)].Is(Cell.Corner))
piece=newPiece(piece.pos,piece.size.Add(-1,0),piece.cornerIDs,piece.type,0);
else
if(rootIsChecked)
piece=newPiece(newVector2Int(piece.pos.x,piece.pos.y+1),newVector2Int(piece.size.x,piece.size.y-1),piece.cornerIDs,piece.type,0);
Vector2Inttip=piece.pos.Add(0,piece.size.y-1);
if(gen.cells[gen.CellPosToIndex(tip)].Is(Cell.Corner))
piece=newPiece(piece.pos,piece.size.Add(0,-1),piece.cornerIDs,piece.type,0);
returnpiece;
privatePieceGrowEdge(Piecepiece)
if(piece.sqrArea==1||gen.cells[gen.CellPosToIndex(piece.pos)].Is(Cell.Seam))
returnpiece;
Piecegrown=piece.Grow(piece.cornerIDs.GrowDir().Reverse());
for(inty=0;y<grown.size.y;y++)
for(intx=0;x<grown.size.x;x++)
Vector2Intp=grown.pos.Add(x,y);
if(piece.Contains(p))
continue;
intindex=gen.CellPosToIndex(p);
Cellcell=gen.cells[index];
if(cell.Any(Cell.Edge|Cell.Seam|Cell.Corner|Cell.Blocked))
returnpiece;
piece=grown;
gen.SetAreaCells(piece.pos,piece.size,Cell.Edge);
returnpiece;
privatevoidCollectSeams()
seamPieces.Clear();
intuseCount=usedCells.Count;
for(inti=0;i<useCount;i++)
intindex=usedCells[i];
if(gen.cells[index].Is(Cell.Seam))
CornerIDscIDs=gen.frontIDs[index];
if(cIDs.IsZoneCorner)
gen.cells.Set(Cell.SeamCorner,index);
Vector2Intpos=gen.IndexToCellPos(index);
seamCornerPieces.Add(newPiece(pos,Vector2Int.one,cIDs,PieceType.Flat,-1));
CellListRemoval(usedCells,Cell.SeamCorner);
CellListRemoval(usedCells,Cell.Seam);
CreateEdges(seamCornerPieces,seamPieces,true);
intcount=seamCornerPieces.Count;
for(inti=0;i<count;i++)
seamCornerPieces.Add(newPiece(seamCornerPieces[i],1));
intcount=seamPieces.Count;
for(inti=0;i<count;i++)
seamPieces.Add(newPiece(seamPieces[i],1));
CellListRemoval(usedCells,Cell.FrontSeamEdge);
EdgeDivide(seamPieces,3);
intcount=seamCornerPieces.Count;
for(inti=0;i<count;i++)
seamCornerPieces[i]=SetRightZone(seamCornerPieces[i]);
intcount=seamPieces.Count;
for(inti=0;i<count;i++)
seamPieces[i]=SetRightZone(seamPieces[i]);
privatevoidCollectFills()
fillPieces.Clear();
potentialHoles.Clear();
intuseCount=usedCells.Count;
intflushCount=0;
for(inti=0;i<useCount;i++)
intindex=usedCells[i];
if(!gen.cells[index].Any(Cell.Blocked))
flush[flushCount++]=index;
FillArea(fillPieces,flush,flushCount,PieceType.Hole,0);
intholeFillCount=fillPieces.Count;
for(inti=0;i<holeFillCount;i++)
Piecepiece=fillPieces[i];
if(piece.size.x>3&&piece.size.y==piece.size.x)
for(inty=0;y<piece.size.x;y++)
for(intx=0;x<piece.size.x;x++)
intindex=gen.CellPosToIndex(piece.pos.Add(x,y));
gen.cells.Set(Cell.Hole,index);
else
if(piece.size.x>1&&piece.size.y>1)
potentialHoles.Add(piece);
fillPieces.RemoveAt(i);
i--;
holeFillCount--;
CellListRemoval(usedCells,Cell.Hole);
for(intside=0;side<2;side++)
boolfront=side==0;
intsideValue=front?-1:1;
List<int>used=front?frontUsed:backUsed;
CellcellInfo=front?Cell.FrontWindow:Cell.BackWindow;
used.Clear();
intblockCount=0;
intuseCount=usedCells.Count;
for(inti=0;i<useCount;i++)
intindex=usedCells[i];
if(gen.cells[index].Is(front?Cell.FrontBlock:Cell.BackBlock))
justBlocked[blockCount++]=index;
else
used.Add(index);
FillArea(fillPieces,justBlocked,blockCount,PieceType.Flat,sideValue);
intcount=used.Count;
for(inti=0;i<count;i++)
intindex=used[i];
Vector2Intpos=gen.IndexToCellPos(index);
if(pos.x%3==0&&pos.y%5==0&&GrowWindow(pos,front))
fillPieces.Add(newPiece(pos,newVector2Int(2,3),gen.frontIDs[index],PieceType.Window,sideValue));
CellListRemoval(used,cellInfo);
count=used.Count;
intflushCount=0;
for(inti=0;i<count;i++)
flush[flushCount++]=used[i];
FillArea(fillPieces,flush,flushCount,PieceType.Detail,sideValue);
usedCells.Clear();
privatevoidFillArea(List<Piece>pieceList,int[]areaList,intareaCount,PieceTypesurfaceType,intsideValue)
areaList.RandomizeRange(gen.random,areaCount);
fillList.Clear();
for(inti=0;i<areaCount;i++)
fillList[areaList[i]]=true;
while(true)
intindex;
while(true)
areaCount--;
if(areaCount<0)
gotoDone;
index=areaList[areaCount];
if(fillList[index])
fillList[index]=false;
break;
Piecep=newPiece(gen.IndexToCellPos(index),Vector2Int.one,gen.frontIDs[index],surfaceType,sideValue);
while(true)
Piecegrown=p.Grow(HouseHelp.RandomAxisDir(gen.random));
for(intyP=0;yP<grown.size.y;yP++)
for(intxP=0;xP<grown.size.x;xP++)
Vector2IntcheckPos=grown.pos.Add(xP,yP);
if(p.Contains(checkPos))
continue;
if(!gen.ValidCellPos(checkPos)||!fillList[gen.CellPosToIndex(checkPos)])
gotoNotGrowing;
constintmaxSideLength=9;
if(grown.size.x>maxSideLength||grown.size.y>maxSideLength)
pieceList.Add(p);
break;
p=grown;
gen.SetAreaBools(grown.pos,grown.size,fillList,false);
continue;
NotGrowing:
pieceList.Add(p);
break;
continue;
Done:break;
privateboolGrowWindow(Vector2Intpos,boolfront)
inti=0;
for(inty=0;y<3;y++)
for(intx=0;x<2;x++)
i++;
if(i==1)
continue;
Vector2IntcheckPos=pos.Add(x,y);
if(!gen.ValidCellPos(checkPos))
returnfalse;
intcheckIndex=gen.CellPosToIndex(checkPos);
CornerIDscID=gen.frontIDs[checkIndex];
if(!cID.AllTheSame||!rules.GetZone(cID.ArrayZone).windows)
returnfalse;
Cellcell=gen.cells[checkIndex];
if(!cell.Is(Cell.House)||
cell.Any(Cell.Corner|Cell.Edge|Cell.Seam|Cell.Hole|Cell.Blocked))
returnfalse;
gen.SetAreaCells(pos,newVector2Int(2,3),front?Cell.FrontWindow:Cell.BackWindow);
returntrue;
privateintCreateEdges(List<Piece>corners,List<Piece>edges,boolseams)
PieceTypetype=seams?PieceType.Flat:PieceType.Detail;
intcornerCount=corners.Count;
for(inti=0;i<cornerCount;i++)
Piecepiece=corners[i];
boolfront=piece.side!=1;
CornerIDs[]cornerIDs=front?gen.frontIDs:gen.backIDs;
CellcellInfo=seams?Cell.FrontSeamEdge|Cell.BackSeamEdge:Cell.Edge;
for(intdir=0;dir<4;dir++)
CornerIDsnext=piece.cornerIDs.ProjectDir(dir);
intcornerValue=seams?next.ZoneCornerValue:next.cornerValue;
if(dir%2==0?cornerValue!=0110&&cornerValue!=1001:
cornerValue!=0011&&cornerValue!=1100)
continue;
intedgeLength=0;
Vector2IntgrowDir;
switch(dir)
default:growDir=Vector2Int.up;break;
case1:growDir=Vector2Int.right;break;
case2:growDir=Vector2Int.down;break;
case3:growDir=Vector2Int.left;break;
while(true)
Vector2IntcheckPos=piece.pos+growDir*(edgeLength+1);
if(!gen.ValidCellPos(checkPos))
break;
intcheckIndex=gen.CellPosToIndex(checkPos);
CornerIDscheckIDs=cornerIDs[checkIndex];
if(gen.cells[checkIndex].Is(cellInfo))
break;
if(seams?(!checkIDs.IsOnEdge&&checkIDs.ZoneCornerValue==cornerValue):checkIDs.cornerValue==cornerValue)
gen.cells.Set(cellInfo,checkIndex);
edgeLength++;
else
break;
if(edgeLength==0)
continue;
switch(dir)
case0:edges.Add(newPiece(piece.pos.Add(0,1),newVector2Int(1,edgeLength),next,type,piece.side));break;
case1:edges.Add(newPiece(piece.pos.Add(1,0),newVector2Int(edgeLength,1),next,type,piece.side));break;
case2:edges.Add(newPiece(piece.pos.Add(0,-edgeLength),newVector2Int(1,edgeLength),next,type,piece.side));break;
case3:edges.Add(newPiece(piece.pos.Add(-edgeLength,0),newVector2Int(edgeLength,1),next,type,piece.side));break;
returnedges.Count;
privateintEdgeDivide(List<Piece>pieces,intmaxEdgeLength)
intedgeCount=pieces.Count;
for(inti=0;i<edgeCount;i++)
Pieceedge=pieces[i];
intlength=edge.sqrArea;
if(length>maxEdgeLength)
pieces.RemoveAt(i);
i--;
intpieceLength=gen.random.Range(1,maxEdgeLength+1);
pieces.Add(newPiece(edge.pos,edge.size.Clamp(pieceLength),edge.cornerIDs,edge.type,edge.side));
Vector2Intpos=edge.pos+edge.size.ToDir()*pieceLength;
pieces.Add(newPiece(pos,edge.size.Clamp(length-pieceLength),edge.cornerIDs,edge.type,edge.side));
edgeCount++;
returnedgeCount;
privatevoidCellListRemoval(List<int>cells,Cellinfo)
intcount=cells.Count;
for(inti=0;i<count;i++)
if(gen.cells[cells[i]].Is(info))
cells.RemoveAt(i);
i--;
count--;
publicpartialclassHouseRules:MonoBehaviour
[System.Serializable]
publicstructZonePoint
publicVector2pos;
publicintzoneID;
publicfloatmulti;
publicZonePoint(Vector2pos,intzoneID,floatradius)
this.pos=pos;
this.zoneID=zoneID;
multi=1f/Mathf.Pow(radius,2);
publicZonePoint(floatmulti,Vector2pos,intzoneID)
this.pos=pos;
this.zoneID=zoneID;
this.multi=multi;
publicfloatRadiusLerp(Vector2point)
return(point-pos).sqrMagnitude*multi;
publicZonePointSetZoneID(intzoneID)
returnnewZonePoint(multi,pos,zoneID);
[SerializeField]privateHouseZone[]zones;
privateZonePoint[]zonePoints;
privateBounds2D[]frontElements,backElements;
privateBounds2DbroadBound;
privateconstfloatcellSize=HouseGen.cellSize;
privateHouseGengen;
publicvoidInit()
gen=GetComponent<HouseGen>();
intzoneCount=transform.childCount;
zonePoints=newZonePoint[zoneCount];
for(inti=0;i<zoneCount;i++)
Transformt=transform.GetChild(i);
t.GetComponent<MeshRenderer>().enabled=false;
zonePoints[i]=newZonePoint(t.position,0,t.localScale.x*.5f);
string[]boundLines=ResourceTxt.Read("AllBounds");
List<Bounds2D>front=newList<Bounds2D>();
List<Bounds2D>back=newList<Bounds2D>();
for(inti=0;i<boundLines.Length;i++)
stringline=boundLines[i];
if(line.Length==0)
continue;
string[]parts=boundLines[i].Split('#');
Bounds2Dbounds=Bounds2D.GetViaString(parts[0]);
if(int.Parse(parts[2])==0)
front.Add(bounds);
else
back.Add(bounds);
frontElements=front.ToArray();
backElements=back.ToArray();
broadBound=frontElements[0];
for(inti=1;i<frontElements.Length;i++)
broadBound=broadBound.Add(frontElements[i]);
for(inti=0;i<backElements.Length;i++)
broadBound=broadBound.Add(backElements[i]);
floatpad=0;
for(inti=0;i<zones.Length;i++)
pad=Mathf.Max(pad,zones[i].elementPad);
broadBound.Pad(pad);
publicvoidSetupZones()
intzoneCount=zonePoints.Length;
for(inti=0;i<zoneCount;i++)
zonePoints[i]=zonePoints[i].SetZoneID(gen.random.Range(1,zones.Length)*2+1);
publicRectZoneGetZone(Bounds2Drect)
Vector2pos=rect.Center;
intzoneID=1;
floatradiusLerp=1;
intzoneCount=zonePoints.Length;
for(inti=0;i<zoneCount;i++)
ZonePointzP=zonePoints[i];
floatcheckRadiusLerp=zP.RadiusLerp(pos);
if(checkRadiusLerp<radiusLerp)
radiusLerp=checkRadiusLerp;
zoneID=zP.zoneID;
returnnewRectZone(rect,zoneID);
publicboolIntersectsPadElement(Bounds2Dbounds,intzone)
if(!bounds.Intersects(broadBound))
returnfalse;
bounds=bounds.Pad(zones[zone].elementPad);
intlength=frontElements.Length;
for(inti=0;i<length;i++)
if(bounds.Intersects(frontElements[i]))
returntrue;
intlength=backElements.Length;
for(inti=0;i<length;i++)
if(bounds.Intersects(backElements[i]))
returntrue;
returnfalse;
publicvoidDetectBlockedCells()
for(inti=0;i<frontElements.Length;i++)
Vector2Intmin,steps;
gen.BoundsToCellArea(frontElements[i],outmin,outsteps);
gen.SetAreaCells(min,steps,Cell.FrontBlock);
for(inti=0;i<backElements.Length;i++)
Vector2Intmin,steps;
gen.BoundsToCellArea(backElements[i],outmin,outsteps);
gen.SetAreaCells(min,steps,Cell.BackBlock);
publicHouseZoneGetZone(intindex)
returnzones[index];
publicintZoneCount{get{returnzones.Length;}}
[CreateAssetMenu]
publicclassHouseZone:ScriptableObject
publicbytepieceID;
[Space]
publicfloatminArea,xShift;
[Space]
publicColordebugColor;
publicboolwindows;
[Space]
publicPadRulesextrudePadRules;
[Space]
publicfloatelementPad;
[System.Serializable]
publicstructPadRules
publicinttop,sides,bottom;
publicclassIntListTest:MonoBehaviour
privatereadonlyUniqueListlist=newUniqueList(10);
voidUpdate()
if(Input.GetKeyDown(KeyCode.A))
list.Add(Random.Range(0,10));
if(Input.GetKeyDown(KeyCode.R))
list.Remove(Random.Range(0,10));
if(Input.GetKeyDown(KeyCode.T))
list.RemoveAt(Random.Range(0,10));
/*List<int>banana=newList<int>();
banana.Remove(0);*/
publicclassOverlapTest:MonoBehaviour
privateVector2s1,s2;
privateVector2pos;
privateBounds2Db1,b2;
privatevoidStart()
SizeUpdate();
privatevoidSizeUpdate()
s1=newVector2(Random.Range(2.0f,15.0f),Random.Range(2.0f,15.0f))*10;
s2=newVector2(Random.Range(2.0f,15.0f),Random.Range(2.0f,15.0f))*10;
Vector2p=Vector3.up*200;
b2=newBounds2D(p+s2*-.5f).Add(p+s2*.5f);
privatevoidUpdate()
pos+=newVector2(Time.deltaTime*Input.GetAxis("Horizontal"),Time.deltaTime*Input.GetAxis("Vertical"))*100;
if(Input.GetKeyDown(KeyCode.Space))
SizeUpdate();
b1=newBounds2D(pos+s1*-.5f).Add(pos+s1*.5f);
b1.Draw().SetColor(Color.red);
b2.Draw().SetColor(Color.red);
DRAW.GUI_Text(b1.IntersectLerp(b2).ToString("F2"),pos,Color.red,3);
[CreateAssetMenu]
publicclassPlacerMeshes:ScriptableObject
publicMesh[]pieces;
publicMesh[]shadows;
publicMaterialmat,shadowMat;
publicintpoolSize;
privatestaticreadonlyMeshPlacement[]placements=newMeshPlacement[10000];
privatestaticreadonlyGTF[]activePieces=newGTF[10000],
activeShadows=newGTF[10000];
privatestaticintplacedMeshCount;
privatestaticStack<GTF>poolPieces,poolShadows;
privatestaticfloatscale;
publicstaticvoidClear(floatscale)
PlacerMeshes.scale=scale;
for(inti=0;i<placedMeshCount;i++)
MeshPlacementplacement=placements[i];
Level.RemoveBGMeshFromCells(i,GetBounds(placement),placement.side);
placedMeshCount=0;
publicvoidSetup()
GTF.Pieces=newPieceDictionary(pieces);
GTF.Shadows=newMeshDictionary(shadows);
if(mat==null)
mat=Resources.Load<Material>("Mats/MainMatSimple");
poolPieces=newStack<GTF>(poolSize);
for(inti=0;i<poolSize;i++)
poolPieces.Push(newGTF("Piece",mat,false));
poolShadows=newStack<GTF>(poolSize);
for(inti=0;i<poolSize;i++)
poolShadows.Push(newGTF("Shadow",shadowMat,true));
publicstaticvoidPlace(Piecepiece,HouseGengen,intside,refboolfoundPiece)
Vector2pos=gen.cellMin+(Vector2)piece.pos*HouseGen.cellSize;
intpieceInfo=GetPieceInfo(0,piece.cornerIDs.PieceID(),piece.size.x,piece.size.y,(int)piece.type);
if(!GTF.Pieces.HasMeshFor(pieceInfo))
pieceInfo=GetPieceInfo(0,piece.cornerIDs.PieceID(true),piece.size.x,piece.size.y,(int)piece.type);
foundPiece=false;
if(!GTF.Pieces.HasMeshFor(pieceInfo))
Debug.Log("Nope:"+pieceInfo.ToString("D10")+""+piece.cornerIDs.Log());
return;
MeshPlacementplacement=newMeshPlacement(pos,pieceInfo,piece.cornerIDs,side);
Level.AddBGMeshToCells(placedMeshCount,GetBounds(placement),side);
placements[placedMeshCount++]=placement;
publicstaticvoidUpdateVisiblePieces(int[]addPieces,intaddCount,int[]removePieces,intremoveCount)
for(inti=0;i<removeCount;i++)
intid=removePieces[i];
GTFpiece=activePieces[id];
if(piece!=null)
poolPieces.Push(piece.SetInactive());
GTFshadow=activeShadows[id];
if(shadow!=null)
poolShadows.Push(shadow.SetInactive());
for(inti=0;i<addCount;i++)
intid=addPieces[i];
if(poolPieces.Count>0)
activePieces[id]=poolPieces.Pop().SetActive(placements[id]);
else
break;
activeShadows[id]=poolShadows.Pop().SetActive(placements[id]);
privatestaticBounds2DGetBounds(MeshPlacementplacement)
intx=Mathf.FloorToInt(placement.pieceInfo%1000/100.0f);
inty=Mathf.FloorToInt(placement.pieceInfo%100/10.0f);
Vector2min=placement.pos-newVector2(scale*.5f,scale*.5f);
returnnewBounds2D(min).Add(min+newVector2(x*scale,y*scale));
publicstaticvoidDrawPieceBounds(intpieceIndex)
MeshPlacementplacement=placements[pieceIndex];
GetBounds(placement).Pad(-.1f).Draw().SetColor(Color.red).SetDepth(Z.W20);
publicstaticvoidReport()
Debug.LogFormat("Got{0}MeshPlacements",placedMeshCount);
publicstaticintGetPieceInfo(intside,intpieceID,intx,inty,intsurface)
returnside*1000000000+
pieceID*1000+
x*100+
y*10+
surface;
publicstaticintMeshNameToID(stringname)
string[]parts=name.Split('_');
string[]corners=parts[1].Split('.');
intpieceID=
HouseHelp.GetPieceID(
int.Parse(corners[0]),
int.Parse(corners[1]),
int.Parse(corners[2]),
int.Parse(corners[3]));
string[]size=parts[2].Split('.');
intx=int.Parse(size[0]);
inty=int.Parse(size[1]);
stringsurface=parts[3];
intsurf;
switch(surface)
default:surf=0;break;
case"Bump":surf=1;break;
case"Hole":surf=2;break;
case"Window":surf=3;break;
intside=parts[4]=="F"?0:1;
returnGetPieceInfo(side,pieceID,x,y,surf);
publicclassGTF
privatereadonlyTransformt;
privatereadonlyMeshFiltermF;
privatereadonlyMeshRenderermR;
publicstaticPieceDictionaryPieces;
publicstaticMeshDictionaryShadows;
publicstaticintActiveCount;
privatereadonlyboolshadow;
publicGTF(stringname,Materialmat,boolshadow)
GameObjectgO=newGameObject(name);
t=gO.transform;
mF=gO.AddComponent<MeshFilter>();
mR=gO.AddComponent<MeshRenderer>();
mR.material=mat;
this.shadow=shadow;
if(shadow)
gO.layer=LayerMask.NameToLayer("Lighting");
mR.enabled=false;
publicGTFSetInactive()
mR.enabled=false;
ActiveCount--;
returnthis;
publicGTFSetActive(MeshPlacementplacement)
Meshmesh=shadow?Shadows.GetMesh(placement.pieceInfo,"Shadow"):
Pieces.GetMesh(placement.pieceInfo,"Pieces");
if(mesh==null)
Debug.Log("Can'tfind"+placement.pieceInfo.ToString("D10").B_Purple()+""+placement.corners.Log());
returnthis;
t.position=placement.pos;
t.localScale=newVector3(1,1,placement.side>0?-1:1);
mR.enabled=true;
mF.sharedMesh=mesh;
ActiveCount++;
returnthis;
publicclassMeshDictionary
privatereadonlyMesh[]meshes;
privatereadonlyDictionary<int,int>pieceInfoMap;
publicMeshDictionary(Mesh[]meshes)
this.meshes=meshes;
pieceInfoMap=newDictionary<int,int>();
for(inti=0;i<meshes.Length;i++)
intpieceInfo=MeshNameToID(meshes[i].name);
if(!pieceInfoMap.ContainsKey(pieceInfo))
pieceInfoMap.Add(pieceInfo,i);
/*else
Debug.Log("ShadowMeshNameDuplicate:"+pieceInfo.ToString().B_Pink()+"|"+meshes[i]);*/
publicMeshGetMesh(intpieceInfo,stringinfo)
if(!HasMeshFor(pieceInfo))
Debug.LogFormat("Can'tfind\"{0}\"Meshfor"+pieceInfo.ToString().B_Purple(),info);
returnnull;
returnmeshes[pieceInfoMap[pieceInfo]];
privateboolHasMeshFor(intpieceInfo)
returnpieceInfoMap.ContainsKey(pieceInfo);
publicclassPieceDictionary
privatereadonlyPieceVariation[]pieces;
privatereadonlyDictionary<int,int>pieceInfoMap;
publicPieceDictionary(Mesh[]meshes)
List<PieceVariation>pieceList=newList<PieceVariation>();
pieceInfoMap=newDictionary<int,int>();
intindex=0;
for(inti=0;i<meshes.Length;i++)
Meshmesh=meshes[i];
intpieceInfo=MeshNameToID(mesh.name);
if(!pieceInfoMap.ContainsKey(pieceInfo))
pieceInfoMap.Add(pieceInfo,index++);
pieceList.Add(newPieceVariation(mesh));
else
pieceList[pieceInfoMap[pieceInfo]].AddMesh(mesh);
pieces=pieceList.ToArray();
publicMeshGetMesh(intpieceInfo,stringinfo)
if(!HasMeshFor(pieceInfo))
Debug.LogFormat("Can'tfind\"{0}\"Meshfor"+pieceInfo.ToString().B_Purple(),info);
returnnull;
returnpieces[pieceInfoMap[pieceInfo]].GetMesh();
publicboolHasMeshFor(intpieceInfo)
returnpieceInfoMap.ContainsKey(pieceInfo);
privateclassPieceVariation
privatereadonlyMesh[]variations=newMesh[10];
privateintcount;
publicPieceVariation(Meshmesh)
AddMesh(mesh);
publicvoidAddMesh(Meshmesh)
variations[count++]=mesh;
publicMeshGetMesh()
returncount==0?variations[0]:variations[Random.Range(0,count)];
publicstaticclassManageBGMeshes
[MenuItem("BG_Meshes/Collect")]
publicstaticvoidCollect()
PlacerMeshespM=Assets.Get<PlacerMeshes>("TestMeshes");
if(pM==null)
return;
List<Mesh>pieces=newList<Mesh>(),shadows=newList<Mesh>();
Mesh[]pieceMeshes=Assets.FindAllMeshes("HoudiniMesh/_Backgrounds/Pieces");
for(inti=0;i<pieceMeshes.Length;i++)
pieces.Add(pieceMeshes[i]);
Mesh[]shadowMeshes=Assets.FindAllMeshes("HoudiniMesh/_Backgrounds/Shadows");
for(inti=0;i<shadowMeshes.Length;i++)
shadows.Add(shadowMeshes[i]);
pM.pieces=pieces.ToArray();
pM.shadows=shadows.ToArray();
EditorUtility.SetDirty(pM);
[MenuItem("BG_Meshes/Delete")]
publicstaticvoidDeleteAll()
stringdir=Application.dataPath+"/HoudiniMesh/_Backgrounds/Pieces/";
string[]allFiles=Directory.GetFiles(dir);
for(inti=0;i<allFiles.Length;i++)
File.Delete(allFiles[i]);
stringdir=Application.dataPath+"/HoudiniMesh/_Backgrounds/Shadows";
string[]allFiles=Directory.GetFiles(dir);
for(inti=0;i<allFiles.Length;i++)
File.Delete(allFiles[i]);
AssetDatabase.Refresh();
PlacerMeshespM=Assets.Get<PlacerMeshes>("TestMeshes");
if(pM==null)
return;
pM.pieces=newMesh[0];
pM.shadows=newMesh[0];
EditorUtility.SetDirty(pM);
[MenuItem("BG_Meshes/Select")]
publicstaticvoidSelect()
PlacerMeshespM=Assets.Get<PlacerMeshes>("TestMeshes");
if(pM!=null)
Selection.activeObject=pM;
publicclassInstancingTest:MonoBehaviour
publicMeshFilter[]filters;
publicMaterialmaterial;
privateBaseMesh[]baseMeshes;
privateMatrix4x4[]animMatrixes;
privatevoidAwake()
baseMeshes=newBaseMesh[filters.Length];
for(inti=0;i<baseMeshes.Length;i++)
baseMeshes[i]=newBaseMesh(filters[i]);
animMatrixes=newMatrix4x4[100];
privatevoidUpdate()
QuaternionstarSpin=Quaternion.AngleAxis(Time.realtimeSinceStartup*45,Vector3.forward);
for(inti=0;i<baseMeshes.Length;i++)
Vector3pos=baseMeshes[i].pos;
Quaternionrot=baseMeshes[i].rot;
for(inte=0;e<animMatrixes.Length;e++)
constfloatstep=3.7f;
floaty=Mathf.Floor(e/10f)*-step+5*step;
floatx=e%10*step-5*step;
Quaterniontilt=Quaternion.AngleAxis(Mathf.SmoothStep(-13,13,Mathf.PingPong(Time.realtimeSinceStartup*.5f+e*.22f,1)),Vector3.right);
if(i==1)
tilt*=starSpin;
Vector3animPos=newVector3(x,y,0)+tilt*pos;
tilt*=rot;
animMatrixes[e]=Matrix4x4.TRS(animPos,tilt,Vector3.one);
Graphics.DrawMeshInstanced(baseMeshes[i].mesh,0,material,animMatrixes,animMatrixes.Length);
privateclassBaseMesh
publicMeshmesh;
publicVector3pos;
publicQuaternionrot;
publicBaseMesh(MeshFilterfilter)
this.mesh=filter.sharedMesh;
pos=filter.transform.localPosition;
rot=filter.transform.localRotation;
publicclassLogin:MonoBehaviour
publicGameObjectnameBttn,emailBttn,passwordBttn,loginBttn;
[Space(10)]
publicGameObjectabcButton;
publicGameObjectnumberButton;
[Space(10)]
publicGameObjectscreenA;
publicGameObjectscreenB;
publicTextMeshProUGUIwait;
privateTextMeshProUGUIname,email,password;
privateEventSystemsystem;
privatePointerEventDatapointer;
privateList<RaycastResult>Hits;
privateTextMeshProUGUIeditText;
privatestringeditString;
privateKeyboardButton[]buttons;
privateKeyboardButtonspace,back;
privateKeyboardButtonlogin;
publicenumeditMode{None,Name,Email,Password}
privateeditModemode;
privateboolloggingIn;
privateintplayerID;
[Serializable]
publicclassKeyboardButton
publicGameObjectbutton;
privatereadonlyTextMeshProUGUItext;
publicstringupper,lower;
publicstringaddString;
privatereadonlyImageimage;
privateboolactive;
publicKeyboardButton(GameObjectbutton,stringcharacter)
this.button=button;
upper=character;
lower=upper=="@"||upper=="."?upper:upper.ToLower();
text=button.GetComponentInChildren<TextMeshProUGUI>();
text.text=upper;
image=button.GetComponent<Image>();
publicboolGotHit(GameObjecthitObject)
returnactive&&button==hitObject;
publicvoidSetActive(editModemode,stringeditString)
switch(mode)
default:
active=false;
break;
caseeditMode.Name:
active=upper!="."&&upper!="@";
break;
caseeditMode.Email:
active=true;
break;
caseeditMode.Password:
active=upper!="."&&upper!="@";
break;
if(upper=="Back")
active=mode!=editMode.None&&editString.Length>0;
if(upper=="Space")
active=mode!=editMode.None&&editString.Length>0;
SetActive(active);
publicvoidSetActive(boolactive)
this.active=active;
image.color=this.active?Color.white:newColor(.75f,.75f,.75f,1);
publicvoidSetCaps(boolbig)
addString=big?upper:lower;
text.text=addString;
privatevoidStart()
screenB.SetActive(false);
name=nameBttn.GetComponentInChildren<TextMeshProUGUI>();
email=emailBttn.GetComponentInChildren<TextMeshProUGUI>();
password=passwordBttn.GetComponentInChildren<TextMeshProUGUI>();
LoadLocalLoginFile();
system=EventSystem.current;
pointer=newPointerEventData(system);
Hits=newList<RaycastResult>();
conststringleftButtons="ABCDEFGHIJKLMNOPQRSTUVWXYZ@.";
conststringrightButtons="3216549870?!";
buttons=newKeyboardButton[leftButtons.Length+rightButtons.Length];
Transformparent=abcButton.transform.parent;
constintbuttonsPerRow=7,buttonsPerRow2=3,
gap=3,
width=25,
height=35;
for(inti=0;i<leftButtons.Length;i++)
GameObjectnewButton=Instantiate(abcButton,parent);
inty=Mathf.FloorToInt((float)i/buttonsPerRow);
intx=i%buttonsPerRow;
newButton.GetComponent<RectTransform>().anchoredPosition=newVector3(x*(width+gap),
y*-(height+gap));
buttons[i]=newKeyboardButton(newButton,leftButtons[i].ToString());
buttons[i].SetActive(mode,editString);
for(inte=0;e<rightButtons.Length;e++)
GameObjectnewButton=Instantiate(numberButton,parent);
inty=Mathf.FloorToInt((float)e/buttonsPerRow2);
intx=e%buttonsPerRow2;
newButton.GetComponent<RectTransform>().anchoredPosition=newVector3(x*-(width+gap),
y*-(height+gap));
inti=e+leftButtons.Length;
buttons[i]=newKeyboardButton(newButton,rightButtons[e].ToString());
buttons[i].SetActive(mode,editString);
GameObjectnewButton=Instantiate(abcButton,parent);
RectTransformrect=newButton.GetComponent<RectTransform>();
rect.anchoredPosition=newVector3(0,4*-(height+gap));
rect.sizeDelta=newVector2(buttonsPerRow*width+(buttonsPerRow-1)*gap,height);
space=newKeyboardButton(newButton,"Space");
space.SetActive(mode,editString);
GameObjectnewButton=Instantiate(numberButton,parent);
RectTransformrect=newButton.GetComponent<RectTransform>();
rect.anchoredPosition=newVector3(0,4*-(height+gap));
rect.sizeDelta=newVector2(buttonsPerRow2*width+(buttonsPerRow2-1)*gap,height);
back=newKeyboardButton(newButton,"Back");
back.SetActive(mode,editString);
Destroy(abcButton);
Destroy(numberButton);
if(Application.internetReachability==NetworkReachability.NotReachable)
screenA.SetActive(false);
if(Application.isEditor)
SceneManager.LoadScene("main");
else
SceneManager.LoadScene(1);
return;
login=newKeyboardButton(loginBttn,"Login");
if(name.text.Length>0&&password.text.Length>0)
login.SetActive(true);
LogIn();
else
login.SetActive(false);
privatevoidUpdate()
if(loggingIn)
return;
if(Input.GetMouseButtonDown(0))
Hits.Clear();
pointer.position=Input.mousePosition;
system.RaycastAll(pointer,Hits);
for(inti=0;i<Hits.Count;i++)
GameObjecthitObject=Hits[i].gameObject;
if(login.GotHit(hitObject))
if(name.text.Length>0&&password.text.Length>0)
LogIn();
break;
if(hitObject==nameBttn)
editText=editText==name?null:name;
editString=name.text;
SetEditMode(editText==name?editMode.Name:editMode.None);
break;
if(hitObject==emailBttn)
editText=editText==email?null:email;
editString=name.text;
SetEditMode(editText==email?editMode.Email:editMode.None);
break;
if(hitObject==passwordBttn)
editText=editText==password?null:password;
editString=password.text;
SetEditMode(editText==password?editMode.Password:editMode.None);
break;
boolhitKeyboard=false;
if(editText!=null)
for(inte=0;e<buttons.Length;e++)
if(buttons[e].GotHit(hitObject))
editString+=buttons[e].addString;
editText.text=editString;
hitKeyboard=true;
break;
if(!hitKeyboard&&space.GotHit(hitObject))
editString+=mode==editMode.Name?"":"_";
editText.text=editString;
hitKeyboard=true;
if(!hitKeyboard&&back.GotHit(hitObject))
editString=editString.Substring(0,editString.Length-1);
editText.text=editString;
hitKeyboard=true;
if(hitKeyboard)
SetEditMode(mode);
break;
privatevoidSetEditMode(editModemode)
this.mode=mode;
for(inti=0;i<buttons.Length;i++)
buttons[i].SetActive(mode,editString);
space.SetActive(mode,editString);
back.SetActive(mode,editString);
login.SetActive(name.text.Length>0&&password.text.Length>0);
switch(mode)
caseeditMode.Name:
for(inti=0;i<buttons.Length;i++)
buttons[i].SetCaps(editString.Length==0||editString.Length>=2&&editString[editString.Length-1]=='');
break;
caseeditMode.Password:
for(inti=0;i<buttons.Length;i++)
buttons[i].SetCaps(true);
break;
caseeditMode.Email:
for(inti=0;i<buttons.Length;i++)
buttons[i].SetCaps(false);
break;
privatevoidLogIn()
StartCoroutine(LoggingIn(name.text,password.text,accountID=>
if(accountID!=0)
SaveLocalLoginFile(name.text,password.text,accountID);
if(Application.isEditor)
SceneManager.LoadScene("main");
else
SceneManager.LoadScene(1);
else
screenA.SetActive(true);
screenB.SetActive(false);
DeleteLocalLoginFile();
privateIEnumeratorLoggingIn(stringname,stringpassword,Action<int>accountIDCallback)
screenA.SetActive(false);
screenB.SetActive(true);
loggingIn=true;
StartCoroutine(LogInAnim());
WWWFormform=newWWWForm();
form.AddField("n",name);
form.AddField("p",password);
boolloginFailed=false;
UnityWebRequestwww=UnityWebRequest.Post(Database.LoginPHP,form);
yieldreturnwww.SendWebRequest();
floatt=0;
while(!www.isDone)
t+=Time.deltaTime;
if(t>=3)
loginFailed=true;
break;
yieldreturnnull;
if(!loginFailed)
accountIDCallback(!www.isNetworkError&&!www.isHttpError?int.Parse(www.downloadHandler.text):0);
else
accountIDCallback(1);
www.Dispose();
loggingIn=false;
privateIEnumeratorLogInAnim()
intpick=0;
while(loggingIn)
wait.text=waitTexts[pick];
pick=(pick+1)%waitTexts.Length;
yieldreturnnewWaitForSeconds(.08f);
privatestaticreadonlystring[]waitTexts=
"Wait",
"Wait.",
"Wait..",
"Wait..."
privatestaticstringPath{get{returnApplication.persistentDataPath+"/player.lgn";}}
privatevoidLoadLocalLoginFile()
if(File.Exists(Path))
name.text=r.ReadString();
password.text=r.ReadString();
playerID=r.ReadInt32();
privatestaticvoidSaveLocalLoginFile(stringname,stringpassword,intaccountID)
r.Write(name);
r.Write(password);
r.Write(accountID);
File.WriteAllBytes(Path,m.GetBuffer().Jumble());
privatestaticvoidDeleteLocalLoginFile()
if(File.Exists(Path))
File.Delete(Path);
publicclassMarchingSquares:MonoBehaviour
publicintwidth,height;
publicbooldraw;
publicMaterialmat;
publicinttestBlockCount;
publicGameObject[]fbx;
privateint[]edgePoints,frontPoints,backPoints;
privateintgenWidth,genHeight;
privatevoidStart()
Generate();
privatevoidUpdate()
if(width!=genWidth||height!=genHeight||Input.GetKeyDown(KeyCode.Space))
Generate();
if(!draw)
return;
floatdepth=Camera.main.transform.forward.z>0?-.51f:.51f;
Vector2min=newVector2(genWidth*-.5f+.5f,genHeight*-.5f+.5f);
for(inty=0;y<genHeight;y++)
for(intx=0;x<genWidth;x++)
Vector2pos=newVector2(min.x+x,min.y+y);
intindex=y*genWidth+x;
intvalue=edgePoints[index];
if(value>=1)
DRAW.Circle(pos,.15f,10).SetDepth(depth*value).SetColor(COLOR.turquois.aquamarine).Fill(1,true);
else
DRAW.Circle(pos,.1f,8).SetDepth(depth*value).SetColor(COLOR.red.tomato).Fill(1,true);
privatevoidGenerate()
foreach(Transformchildintransform)
Destroy(child.gameObject);
genWidth=width;
genHeight=height;
GenerateEdgePoints();
intxLess=genWidth-1;
intyLess=genHeight-1;
floatmin=genWidth*-.5f+1;
for(inty=0;y<yLess;y++)
for(intx=0;x<xLess;x++)
inttile_index=GetIndex(x,y,edgePoints)*256+
GetIndex(x,y,frontPoints)*16+
GetIndex(x,y,backPoints);
GameObjectgO=Instantiate(fbx[tile_index]);
Transformtrans=gO.transform;
trans.SetParent(transform,false);
trans.rotation=Quaternion.Euler(0,180,0);
trans.localPosition=newVector2(min+x,y+.5f);
MeshRenderermR=gO.GetComponent<MeshRenderer>();
if(mR!=null)
mR.material=mat;
privateintGetIndex(intx,inty,int[]points)
inta=points[(y+1)*genWidth+x];
intb=points[(y+1)*genWidth+x+1];
intc=points[y*genWidth+x+1];
intd=points[y*genWidth+x];
returna*8+b*4+c*2+d;
privatevoidGenerateEdgePoints()
edgePoints=newint[genWidth*genHeight];
frontPoints=newint[genWidth*genHeight];
backPoints=newint[genWidth*genHeight];
intmaxHeight=genHeight-6;
intbuildHeight=0;
while(buildHeight<maxHeight)
intblockWidth=Random.Range(6,11);
intxMin=Random.Range(1,genWidth-1-blockWidth);
intblockHeight=Random.Range(4,7);
inthitheight=0;
for(intx=0;x<blockWidth;x++)
intcheckX=xMin+x;
for(inty=maxHeight;y>-1;y--)
intindex=y*genWidth+checkX;
if(edgePoints[index]==1)
hitheight=Mathf.Max(hitheight,y+1);
break;
for(inty=0;y<blockHeight;y++)
for(intx=0;x<blockWidth;x++)
intindex=(hitheight+y)*genWidth+xMin+x;
edgePoints[index]=1;
buildHeight=Mathf.Max(buildHeight,hitheight+blockHeight);
intcounter=0;
while(counter<testBlockCount)
intcastX=Random.Range(1,genWidth-1);
intcastY=Random.Range(1,genHeight-1);
if(edgePoints[castY*genWidth+castX]==1)
intblockWidth=Random.Range(3,7);
intxMin=castX-blockWidth/2;
intblockHeight=Random.Range(6,11);
intyMin=castY-blockHeight/2;
for(inty=0;y<blockHeight;y++)
for(intx=0;x<blockWidth;x++)
intxValue=xMin+x;
intyValue=yMin+y;
if(xValue>=1&&xValue<=genWidth-2&&yValue>=1&&yValue<=genHeight-2)
intindex2=yValue*genWidth+xValue;
frontPoints[index2]=1;
counter++;
counter=0;
while(counter<testBlockCount)
intcastX=Random.Range(1,genWidth-1);
intcastY=Random.Range(1,genHeight-1);
if(edgePoints[castY*genWidth+castX]==1)
intblockWidth=Random.Range(3,7);
intxMin=castX-blockWidth/2;
intblockHeight=Random.Range(6,11);
intyMin=castY-blockHeight/2;
for(inty=0;y<blockHeight;y++)
for(intx=0;x<blockWidth;x++)
intxValue=xMin+x;
intyValue=yMin+y;
if(xValue>=1&&xValue<=genWidth-2&&yValue>=1&&yValue<=genHeight-2)
intindex2=yValue*genWidth+xValue;
backPoints[index2]=1;
counter++;
publicclasswobble:MonoBehaviour
privatefloatr;
privatevoidOnEnable()
r=Random.Range(0,1000f);
privatevoidUpdate()
transform.localScale=newVector3(S(5f),S(4f),S(6f));
privatefloatS(floatinput)
returnMathf.Lerp(.25f,1.4f,Mathf.PerlinNoise(input*.36f*Time.realtimeSinceStartup+r,input*.48f*Time.realtimeSinceStartup+r)*.5f+.5f);
publicclassMeshCam:MonoBehaviour
privateboolactive;
privatevoidUpdate()
if(Input.GetKey(KeyCode.LeftControl)&&Input.GetKeyDown(KeyCode.W))
active=!active;
privatevoidOnPreRender()
if(active)
GL.wireframe=true;
privatevoidOnPostRender()
GL.wireframe=false;
publicclassMeshDraw:MonoBehaviour
/*privateint[]triangles;
privateVector3[]vertices,triNormals,triEdge1,triEdge2;
privateMeshmesh;
privateColor32[]colors;
privateCameracam;
privateintclosestPoint;
publicbooldrawPoints;
privatebool[]vis,triVis;
privateint[]checkList;
privateintcheckCounter;
privateVector2clickStart;
privateQuaternionoldRot;
privateVector2[]screenPos;
privatevoidAwake()
mesh=GetComponent<MeshFilter>().mesh;
triangles=mesh.triangles;
vertices=mesh.vertices;
colors=newColor32[vertices.Length];
for(inti=0;i<colors.Length;i++)
colors[i]=newColor32(255,255,255,255);
mesh.colors32=colors;
cam=Camera.main;
vis=newbool[vertices.Length];
checkList=newint[vertices.Length];
triNormals=newVector3[triangles.Length/3];
triEdge1=newVector3[triNormals.Length];
triEdge2=newVector3[triNormals.Length];
for(inti=0;i<triNormals.Length;i++)
inta=triangles[i*3],b=triangles[i*3+1],c=triangles[i*3+2];
Vector3pA=vertices[a],
pB=vertices[b],
pC=vertices[c];
triEdge1[i]=pB-pA;
triEdge2[i]=pC-pA;
triNormals[i]=Vector3.Cross(triEdge1[i],triEdge2[i]).normalized;
triVis=newbool[triNormals.Length];
screenPos=newVector2[vertices.Length];
privatevoidUpdate()
Quaternionrot=transform.rotation;
boolrotChanged=rot!=oldRot;
oldRot=rot;
if(rotChanged)
VisCheck();
if(Input.GetMouseButtonDown(0))
clickStart=Input.mousePosition;
Vector2min=Vector2.zero,max=Vector2.zero;
if(Input.GetMouseButton(0))
Vector2clickPos=Input.mousePosition;
Vector2p=(clickStart+clickPos)*.5f,
d=newVector2(Mathf.Abs(clickPos.x-clickStart.x),Mathf.Abs(clickPos.y-clickStart.y));
DRAW.ScreenRect(p,d).SetColor(Color.cyan).Fill(.15f,true);
DRAW.ScreenRect(p,d).SetColor(Color.yellow);
min=p-d*.5f;
max=p+d*.5f;
if(drawPoints)
boolselecting=min!=max;
for(inti=0;i<vertices.Length;i++)
if(vis[i])
screenPos[i]=cam.WorldToScreenPoint(transform.TransformPoint(vertices[i]));
boolinSelection=selecting&&screenPos[i].x>=min.x&&screenPos[i].x<=max.x&&
screenPos[i].y>=min.y&&screenPos[i].y<=max.y;
DRAW.ScreenPoint(screenPos[i],.003f,5).SetColor(inSelection?Color.yellow:Color.red).Fill(1,true);
/*for(inti=0;i<triNormals.Length;i++)
Vector3dir=transform.TransformDirection(triNormals[i]);
intt=i*3;
inta=triangles[t],b=triangles[t+1],c=triangles[t+2];
Vector3pA=transform.TransformPoint(vertices[a]),
pB=transform.TransformPoint(vertices[b]),
pC=transform.TransformPoint(vertices[c]);
DRAW.Vector(pA,dir).SetColor(Color.green);
DRAW.Vector(pB,dir).SetColor(Color.green);
DRAW.Vector(pC,dir).SetColor(Color.green);
privatevoidVisCheck()
Vector3localCam=transform.InverseTransformPoint(cam.transform.position);
Vector3localCamForward=transform.InverseTransformDirection(cam.transform.forward);
checkCounter++;
for(inti=0;i<triVis.Length;i++)
triVis[i]=Vector3.Dot(triNormals[i],localCamForward)<=0;
for(intvisCheck=0;visCheck<triangles.Length;visCheck+=3)
if(!triVis[visCheck/3])
vis[triangles[visCheck+0]]=false;
vis[triangles[visCheck+1]]=false;
vis[triangles[visCheck+2]]=false;
else
for(inti=0;i<3;i++)
intindex=triangles[visCheck+i];
if(checkList[index]==checkCounter)
continue;
checkList[index]=checkCounter;
Vector3dir=vertices[index]-localCam;
boolhidden=false;
floatbestDist=float.MaxValue,bestPow=float.MaxValue;
for(intt=0;t<triangles.Length;t+=3)
if(!triVis[t/3])
continue;
inta=triangles[t],b=triangles[t+1],c=triangles[t+2];
Vector3pA=vertices[a],
pB=vertices[b],
pC=vertices[c];
if((pA-localCam).sqrMagnitude>bestPow&&
(pB-localCam).sqrMagnitude>bestPow&&
(pC-localCam).sqrMagnitude>bestPow)
continue;
floatdist;
if(RayIntersectsTriangle(localCam,dir,pA,triEdge1[t/3],triEdge2[t/3],outdist)&&dist<bestDist)
bestDist=dist;
bestPow=dist*dist;
hidden=a!=index&&b!=index&&c!=index;
vis[index]=!hidden;
privatestaticboolRayIntersectsTriangle(Vector3origin,Vector3dir,Vector3vertex0,Vector3edge1,Vector3edge2,outfloatt)
Vector3h=Vector3.Cross(dir,edge2);
floata=Vector3.Dot(edge1,h);
constfloatextra=.01f,min=0-extra,max=1+extra;
floatf=1/a;
Vector3s=origin-vertex0;
floatu=f*Vector3.Dot(s,h);
if(u<min||u>max)
t=float.MaxValue;
returnfalse;
Vector3q=Vector3.Cross(s,edge1);
floatv=f*Vector3.Dot(dir,q);
if(v<min||u+v>max)
t=float.MaxValue;
returnfalse;
t=f*Vector3.Dot(edge2,q)*dir.magnitude;
returnt>0;
publicclassMultiMesh:MonoBehaviour
privateclassCachedMesh
publicreadonlyVector3[]vertices;
publicreadonlyVector3[]normals;
publicreadonlyVector2[]uv;
publicreadonlyint[]triangles;
publicCachedMesh(Meshmesh)
vertices=mesh.vertices;
normals=mesh.normals;
uv=mesh.uv;
triangles=mesh.triangles;
publicGameObject[]sourceObjects;
privateCachedMesh[]_cachedMeshes;
privateMeshFiltermeshFilter;
privateMeshmesh;
privateintverticeCount;
privateinttriangleCount;
privateintmeshPick;
privatereadonlyVector3[]vertices=newVector3[ushort.MaxValue];
privatereadonlyVector3[]normals=newVector3[ushort.MaxValue];
privatereadonlyVector2[]uv=newVector2[ushort.MaxValue];
privatefloatt;
privatevoidOnEnable()
_cachedMeshes=newCachedMesh[sourceObjects.Length];
for(inti=0;i<_cachedMeshes.Length;i++)
_cachedMeshes[i]=newCachedMesh(sourceObjects[i].GetComponent<MeshFilter>().mesh);
sourceObjects[i].SetActive(false);
mesh=newMesh{bounds=newBounds(transform.position,Vector3.one)};
meshFilter=GetComponent<MeshFilter>();
meshFilter.mesh=mesh;
UpdateMesh();
t=Time.realtimeSinceStartup;
privatevoidUpdate()
if(Time.realtimeSinceStartup-t>.2f)
meshPick=(meshPick+1)%_cachedMeshes.Length;
UpdateMesh();
t=Time.realtimeSinceStartup;
transform.rotation*=Quaternion.AngleAxis(Time.deltaTime*20,transform.up);
privatevoidUpdateMesh()
CachedMeshcachedMesh=_cachedMeshes[meshPick];
for(inti=0;i<cachedMesh.vertices.Length;i++)
vertices[i]=cachedMesh.vertices[i];
normals[i]=cachedMesh.normals[i];
uv[i]=cachedMesh.uv[i];
mesh.vertices=vertices;
mesh.triangles=cachedMesh.triangles;
mesh.normals=normals;
mesh.uv=uv;
publicclassImpactSquashTest:MonoBehaviour
publicVector2startPos;
publicfloatmaxForce,floorHeight;
privateFlyPathfP;
privatefloatanimStart=float.MaxValue;
privateboolfalling,crash;
privateVector3size;
privateVector2impactMV;
privateVector3impactPos;
[Space(10)]
publicfloatfreqDamp;
publicfloatdamp;
[Space(10)]publicfloattimeScale;
privatevoidAwake()
size=transform.localScale;
privatevoidUpdate()
Transformt=transform;
if(!falling&&Input.GetKeyDown(KeyCode.Space))
fP=newFlyPath(startPos,newVector2(.001f,Random.Range(-maxForce,maxForce)));
animStart=Time.realtimeSinceStartup;
falling=true;
crash=false;
t.localScale=size;
if(falling)
floattime=(Time.realtimeSinceStartup-animStart)/timeScale;
Vector3pos=fP.GetPos(time);
if(pos.y<=floorHeight+size.y*.5f)
impactMV=fP.GetMV(time);
pos.y=floorHeight+size.y*.5f;
falling=false;
crash=true;
animStart=Time.realtimeSinceStartup;
impactPos=pos;
t.position=pos;
if(crash)
floatfrequency=-Mathf.Abs(impactMV.y)/size.y/freqDamp;
floatduration=Mathf.Abs(impactMV.y)/damp;
floattime=(Time.realtimeSinceStartup-animStart)/timeScale;
floatsquash=1+GPhysics.NewOscillate(time,frequency,duration);
t.localScale=size.VolumeScaleY(squash);
t.position=newVector3(impactPos.x,floorHeight+size.y*.5f*squash);
publicclassOccilationTest:MonoBehaviour
publicfloatmagnitude;
publicfloatfrequency;
privatefloatstartTime;
privateboolshake;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
shake=true;
startTime=Time.realtimeSinceStartup;
if(!shake)
return;
floatocci=GPhysics.NewOscillate(Time.realtimeSinceStartup-startTime,frequency,10,true);
transform.position=newVector3(magnitude*occi,0,0);
publicclassOccluderPacking:MonoBehaviour
privatereadonlyList<Bounds2D>pieceBounds=newList<Bounds2D>();
privatereadonlyList<TriLine>lines=newList<TriLine>();
publicstaticCellPosBounds[]cellPosBounds;
privatevoidStart()
ParsePieces();
privatevoidParsePieces()
MeshFilter[]meshFilters=GetComponentsInChildren<MeshFilter>();
cellPosBounds=newCellPosBounds[meshFilters.Length];
for(inti=0;i<meshFilters.Length;i++)
cellPosBounds[i]=GetCellPosBounds(meshFilters[i].mesh,meshFilters[i].GetComponent<MeshRenderer>().bounds.center);
Destroy(meshFilters[i].gameObject);
privateCellPosBoundsGetCellPosBounds(Meshmesh,Vector3center)
lines.Clear();
pieceBounds.Clear();
Vector3[]vertices=mesh.vertices;
floatmin=float.MaxValue,max=float.MinValue;
for(inti=0;i<vertices.Length;i++)
min=Mathf.Min(min,vertices[i].x);
max=Mathf.Max(max,vertices[i].x);
int[]triangles=mesh.triangles;
for(inti=0;i<triangles.Length;i+=3)
Vector3p1=vertices[triangles[i]];
Vector3p2=vertices[triangles[i+1]];
Vector3p3=vertices[triangles[i+2]];
if(Mathf.Approximately(p1.y,p2.y))
lines.Add(p1.x<p2.x?newTriLine(p1,p2,p3.y<p1.y):newTriLine(p2,p1,p3.y<p1.y));
if(Mathf.Approximately(p2.y,p3.y))
lines.Add(p2.x<p3.x?newTriLine(p2,p3,p1.y<p2.y):newTriLine(p3,p2,p1.y<p2.y));
if(Mathf.Approximately(p3.y,p1.y))
lines.Add(p3.x<p1.x?newTriLine(p3,p1,p2.y<p3.y):newTriLine(p1,p3,p2.y<p3.y));
while(lines.Count>0)
TriLinea=lines[0],hitLine=null;
lines.RemoveAt(0);
Vector2a1=a.line.l1;
Vector2a2=a.line.GetL2();
floatdist=float.MaxValue;
boolhit=false;
booltop=a.topEdge;
intcount=lines.Count;
for(inte=0;e<count;e++)
TriLineb=lines[e];
Vector2b1=b.line.l1;
Vector2b2=b.line.GetL2();
if(a.topEdge==b.topEdge)
continue;
if(top&&b1.y>a1.y||!top&&b1.y<a1.y)
continue;
if(a1.x<b2.x&&a2.x>b1.x)
floathitDist=top?a1.y-b1.y:b1.y-a1.y;
if(hitDist<dist)
dist=hitDist;
hit=true;
hitLine=b;
if(hit)
lines.Remove(hitLine);
Vector2b1=hitLine.line.l1;
Vector2b2=hitLine.line.GetL2();
floatoverlapMin=Mathf.Max(a1.x,b1.x);
floatoverlapMax=Mathf.Min(a2.x,b2.x);
if(a1.x<overlapMin)
lines.Add(newTriLine(a1,newVector2(overlapMin,a1.y),a.topEdge));
if(a2.x>overlapMax)
lines.Add(newTriLine(newVector2(overlapMax,a2.y),a2,a.topEdge));
if(b1.x<overlapMin)
lines.Add(newTriLine(b1,newVector2(overlapMin,b1.y),hitLine.topEdge));
if(hitLine.line.GetL2().x>overlapMax)
lines.Add(newTriLine(newVector2(overlapMax,b2.y),b2,hitLine.topEdge));
pieceBounds.Add(newBounds2D(newVector2(overlapMin,a1.y)).Add(newVector2(overlapMax,b1.y)));
while(true)
boolfoundNeighbour=false;
for(inti=0;i<pieceBounds.Count;i++)
Bounds2Da=pieceBounds[i];
for(inte=0;e<pieceBounds.Count;e++)
if(i==e)
continue;
Bounds2Db=pieceBounds[e];
if(Mathf.Approximately(a.minY,b.minY)&&Mathf.Approximately(a.maxY,b.maxY)&&
(Mathf.Approximately(a.minX,b.maxX)||Mathf.Approximately(a.maxX,b.minX)))
foundNeighbour=true;
pieceBounds.Remove(a);
pieceBounds.Remove(b);
pieceBounds.Add(newBounds2D(newVector2(Mathf.Min(a.minX,b.minX),a.minY)).
Add(newVector2(Mathf.Max(a.maxX,b.maxX),a.maxY)));
break;
if(foundNeighbour)
break;
if(!foundNeighbour)
break;
Vector2IntcellPos=Cell.ToCellPos(center);
returnnewCellPosBounds(cellPos,pieceBounds.ToArray());
/*publicstaticvoidAddOccludersToCells()
if(cellPosBounds!=null)
for(inti=0;i<cellPosBounds.Length;i++)
Level.AddOccluderToCell(cellPosBounds[i].pos,cellPosBounds[i].bounds);
privateclassTriLine
publicLineline;
publicreadonlybooltopEdge;
publicTriLine(Vector2l1,Vector2l2,booltopEdge)
line=newLine(l1,l2);
this.topEdge=topEdge;
publicclassCellPosBounds
publicVector2Intpos;
publicreadonlyBounds2D[]bounds;
publicCellPosBounds(Vector2Intpos,Bounds2D[]bounds)
this.pos=pos;
this.bounds=bounds;
publicvoidDraw()
Colorc=(pos.x+pos.y)%2==0?COLOR.red.tomato:COLOR.purple.orchid;
for(inti=0;i<bounds.Length;i++)
bounds[i].Pad(-.075f).Draw().SetColor(c).SetDepth(Z.W10).Fill(.3f,true);
publicclassOffsetTest:MonoBehaviour
publicTransformcylinder,cube;
publicfloatcylinderRadius;
publicVector3cubeSize;
privatefloatspinAngle;
privatefloatleanX,leanY;
privatevoidUpdate()
spinAngle+=Time.deltaTime*100;
Quaternionspin=Rot.Z(spinAngle);
leanX=leanX.Axis("Horizontal",40).Clamp(-45,45);
leanY=leanY.Axis("Vertical",40).Clamp(-45,45);
Quaternionlean=Quaternion.Euler(leanY,-leanX,0);
cube.localScale=cubeSize;
cylinder.localScale=newVector3(cylinderRadius*2,1,cylinderRadius*2);
Vector3spinOffset=newVector3(cubeSize.x*.5f,cubeSize.y*.5f,0)+newVector3(1,1,0).normalized*cylinderRadius;
cube.position=lean*(spin*-spinOffset);
cube.rotation=lean*spin;
cylinder.rotation=lean*Rot.X(90);
publicstaticclassBotPlayers
privatestaticstring[]PlayerNames;
privatestaticDictionary<string,int>nameIDs;
[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
privatestaticvoidCreatePlayerNames()
PlayerNames=(Resources.Load("BotNames")asTextAsset).text.Split('\n');
nameIDs=newDictionary<string,int>();
for(inti=0;i<PlayerNames.Length;i++)
PlayerNames[i]=Regex.Replace(PlayerNames[i],@"\t|\n|\r","");
nameIDs.Add(PlayerNames[i],i+1);
privatestaticTextbotText;
publicstaticvoidGetName(refstringname,refintid)
Random.InitState((int)System.DateTime.Now.Ticks);
intr=Random.Range(0,PlayerNames.Length);
id=r+1;
name=PlayerNames[r];
if(botText!=null)
botText.text=PlayerNames[r];
publicstaticstringRandomName
get{returnPlayerNames[Random.Range(0,PlayerNames.Length)];}
publicstaticstringGetName(intid)
returnPlayerNames[id];
publicstaticintGetNameID(stringname)
returnnameIDs[name];
publicclassAnimationHandler:MonoBehaviour{
privateISimpleAnimanimType;
publicAnimationCurve[]aC;
privateVector3realPos;
privatevoidStart()
realPos=transform.localPosition;
SetAnimation();
privateIEnumeratorCoolAnim()
floatwaitFor=Random.Range(0,2.0f);
yieldreturnnewWaitForSeconds(waitFor);
floatcount=0;
floatspeed=Random.Range(1f,5.0f);
AnimationCurveanimCurve=aC[Random.Range(0,aC.Length)];
while(count<1)
count+=Time.deltaTime*speed;
animType.Anim(transform,count,animCurve);
yieldreturnnull;
SetAnimation();
privatevoidSetAnimation()
Transformt=transform;
Quaternionrot=t.rotation;
Vector3localPos=t.localPosition;
switch(Random.Range(0,15))
case0:animType=newTurnLeft(localPos,rot);break;
case1:animType=newTurnRight(localPos,rot);break;
case2:animType=newTurnForward(localPos,rot);break;
case3:animType=newTurnBack(localPos,rot);break;
case4:animType=newSpinLeft(localPos,rot);break;
case5:animType=newSpinRight(localPos,rot);break;
case6:animType=newMove(localPos,rot);break;
case7:animType=newResetHeight(localPos,rot);break;
case8:animType=newResetHeight2(localPos,rot);break;
case9:animType=newResetHeight3(localPos,rot);break;
case10:animType=newResetHeight(localPos,rot);break;
case11:animType=newResetHeight2(localPos,rot);break;
case12:animType=newResetHeight3(localPos,rot);break;
case13:animType=newMove2(localPos,rot,realPos);break;
case14:animType=newMove3(localPos,rot,realPos);break;
StartCoroutine(CoolAnim());
publicinterfaceISimpleAnim
voidAnim(Transformtrans,floatlerp,AnimationCurvecurve);
publicclassTurnLeft:ISimpleAnim
QuaternionstartRot;
publicTurnLeft(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,0,90);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassTurnRight:ISimpleAnim
QuaternionstartRot;
publicTurnRight(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,0,-90);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassTurnForward:ISimpleAnim
QuaternionstartRot;
publicTurnForward(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(90,0,0);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassTurnBack:ISimpleAnim
QuaternionstartRot;
publicTurnBack(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(-90,0,0);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassSpinLeft:ISimpleAnim
QuaternionstartRot;
publicSpinLeft(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,90,0);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassSpinRight:ISimpleAnim
QuaternionstartRot;
publicSpinRight(Vector3startPos,QuaternionstartRot)
this.startRot=startRot;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
QuaterniongoalRot=newQuaternion();
goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,-90,0);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
publicclassMove:ISimpleAnim
Vector3startPos;
floatgoalHeight;
publicMove(Vector3startPos,QuaternionstartRot)
this.startPos=startPos;
goalHeight=Random.Range(0.0f,2.0f);
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatyPos=Mathf.Lerp(startPos.y,startPos.y+goalHeight,curve.Evaluate(lerp));
trans.localPosition=newVector3(trans.localPosition.x,yPos,trans.localPosition.z);
publicclassMove2:ISimpleAnim
Vector3startPos;
Vector3endPos;
publicMove2(Vector3startPos,QuaternionstartRot,Vector3realPos)
this.startPos=startPos;
endPos=newVector3(realPos.x+Random.Range(-0.4f,0.4f),startPos.y,realPos.z+Random.Range(-0.4f,0.4f));
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
trans.localPosition=Vector3.Lerp(startPos,endPos,curve.Evaluate(lerp));
publicclassMove3:ISimpleAnim
Vector3startPos;
Vector3endPos;
publicMove3(Vector3startPos,QuaternionstartRot,Vector3realPos)
this.startPos=startPos;
endPos=newVector3(realPos.x+Random.Range(-0.4f,0.4f),startPos.y+Random.Range(0.0f,5.0f),realPos.z+Random.Range(-0.4f,0.4f));
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
trans.localPosition=Vector3.Lerp(startPos,endPos,curve.Evaluate(lerp));
publicclassResetHeight:ISimpleAnim
Vector3startPos;
floatgoalHeight;
publicResetHeight(Vector3startPos,QuaternionstartRot)
this.startPos=startPos;
goalHeight=0;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatyPos=Mathf.Lerp(startPos.y,goalHeight,curve.Evaluate(lerp));
trans.localPosition=newVector3(trans.localPosition.x,yPos,trans.localPosition.z);
publicclassResetHeight2:ISimpleAnim
Vector3startPos;
QuaternionstartRot;
floatgoalHeight;
QuaterniongoalRot;
publicResetHeight2(Vector3startPos,QuaternionstartRot)
this.startPos=startPos;
this.startRot=startRot;
goalHeight=0;
goalRot=newQuaternion();
intpick=Random.Range(0,6);
switch(pick)
case0:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,-90,0);break;
case1:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,90,0);break;
case2:goalRot.eulerAngles=startRot.eulerAngles+newVector3(90,0,0);break;
case3:goalRot.eulerAngles=startRot.eulerAngles+newVector3(-90,0,0);break;
case4:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,0,90);break;
case5:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,0,-90);break;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
floatyPos=Mathf.Lerp(startPos.y,goalHeight,animLerp);
trans.localPosition=newVector3(trans.localPosition.x,yPos,trans.localPosition.z);
publicclassResetHeight3:ISimpleAnim
Vector3startPos;
QuaternionstartRot;
floatgoalHeight;
QuaterniongoalRot;
publicResetHeight3(Vector3startPos,QuaternionstartRot)
this.startPos=startPos;
this.startRot=startRot;
goalHeight=0;
goalRot=newQuaternion();
intpick=Random.Range(0,6);
switch(pick)
case0:goalRot.eulerAngles=startRot.eulerAngles+newVector3(270,-90,0);break;
case1:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,90,180);break;
case2:goalRot.eulerAngles=startRot.eulerAngles+newVector3(90,90,90);break;
case3:goalRot.eulerAngles=startRot.eulerAngles+newVector3(-90,360,0);break;
case4:goalRot.eulerAngles=startRot.eulerAngles+newVector3(0,90,90);break;
case5:goalRot.eulerAngles=startRot.eulerAngles+newVector3(90,0,-90);break;
publicvoidAnim(Transformtrans,floatlerp,AnimationCurvecurve)
floatanimLerp=curve.Evaluate(lerp);
trans.rotation=Quaternion.Slerp(startRot,goalRot,animLerp);
floatyPos=Mathf.Lerp(startPos.y,goalHeight,animLerp);
trans.localPosition=newVector3(trans.localPosition.x,yPos,trans.localPosition.z);
publicclassPerlinNoiseCheck:MonoBehaviour{
publicintsquareSize;
publicfloatxOffset;
publicfloatyOffset;
[Space(10)]
[Range(-2,2)]
publicfloatxMulti;
[Range(-2,2)]
publicfloatyMulti;
[Space(10)]
publicAnimationCurvecurve;
privateCameracam;
privatevoidOnEnable()
DRAW.Enabled=true;
cam=Camera.main;
privatevoidUpdate()
xOffset+=Input.GetAxis("Horizontal")*-Time.deltaTime;
yOffset+=Input.GetAxis("Vertical")*-Time.deltaTime;
for(intx=0;x<squareSize;x++)
for(inty=0;y<squareSize;y++)
floatvalue=curve.Evaluate(Mathf.PerlinNoise(xOffset+x*xMulti,yOffset+y*yMulti));
Colorc=Color.Lerp(COLOR.red.hot,Color.white,value);
floatsize=Mathf.Lerp(.2f,.85f,value);
floatangle=Mathf.Lerp(135f,0,value);
DRAW.Rectangle(newVector3(x-(squareSize*.5f),y-(squareSize*.5f),0),Vector2.one*size,angle).SetColor(c);
if(cam!=null)
cam.orthographicSize=squareSize*.5f+4;
namespaceOldShit
publicclassGridRegions:MonoBehaviour
publicintxCells,yCells,maxRadius,points;
publicMaterialvertexColorMat;
privateList<PointArea>pointAreas;
privateDictionary<Vector2,Cell>cellDict;
privateDictionary<Vector2,MeshFilter>quads;
privateVector2[]circleCells;
privatevoidStart()
intsideLength=maxRadius*2+1;
intarrayLength=sideLength*sideLength;
Vector2[]box=newVector2[arrayLength];
bool[]insideCircle=newbool[arrayLength];
intnr=0;
intcircleCount=0;
for(intx=0;x<sideLength;x++)
for(inty=0;y<sideLength;y++)
box[nr]=newVector2(x-maxRadius,y-maxRadius);
if(Vector2.Distance(box[nr],V2.zero)<=maxRadius)
insideCircle[nr]=true;
circleCount++;
nr++;
circleCells=newVector2[circleCount];
nr=0;
for(inti=0;i<arrayLength;i++)
if(insideCircle[i])
circleCells[nr]=box[i];
nr++;
quads=newDictionary<Vector2,MeshFilter>();
for(intx=0;x<xCells;x++)
for(inty=0;y<yCells;y++)
quads.Add(newVector2(x,y),CreateQuad(x,y));
privatevoidResetDictionarys()
boolnewDictionary=(cellDict==null);
if(newDictionary)
cellDict=newDictionary<Vector2,Cell>();
for(intx=0;x<xCells;x++)
for(inty=0;y<yCells;y++)
Vector2key=newVector2(x,y);
if(newDictionary)
cellDict.Add(key,newCell());
Cellcell=cellDict[key];
cell.areaID=-1;
cell.distance=1000;
MeshFilterquadStuff=quads[key];
quadStuff.mesh=GetQuadMesh(Color.black,quadStuff.mesh);
privateMeshFilterCreateQuad(floatx,floaty)
GameObjectnewQuad=newGameObject();
MeshFiltermF=newQuad.AddComponent<MeshFilter>();
MeshRenderermR=newQuad.AddComponent<MeshRenderer>();
mR.material=vertexColorMat;
floatxOffset=xCells-xCells*.5f;
floatyOffset=yCells-yCells*.5f;
newQuad.transform.position=newVector3(x-xOffset,y-yOffset,0);
newQuad.transform.parent=transform;
newQuad.name="Quad_"+x.ToString("F0")+"/"+y.ToString("F0");
mF.mesh=newMesh
vertices=new[]{newVector3(.5f,.5f,0),newVector3(.5f,-.5f,0),newVector3(-.5f,-.5f,0),newVector3(-.5f,.5f,0)},
triangles=new[]{0,1,2,3,0,2}
returnmF;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Mouse0))
floatt=Time.realtimeSinceStartup;
CreateGrid();
Debug.Log(Time.realtimeSinceStartup-t);
privatevoidCreateGrid()
ResetDictionarys();
pointAreas=newList<PointArea>();
Vector2randomPoint=V2.zero;
for(inti=0;i<points;i++)
boolcanSet=false;
while(!canSet)
canSet=true;
randomPoint=newVector2(Random.Range(0f,xCells),Random.Range(0f,yCells));
for(inte=0;e<pointAreas.Count;e++)
if((randomPoint-pointAreas[e].areaPoint).sqrMagnitude<4)
canSet=false;
PointAreanewArea=newPointArea(randomPoint,newColor(Random.Range(0.2f,0.8f),Random.Range(0.2f,0.8f),Random.Range(0.2f,0.8f),1));
pointAreas.Add(newArea);
SetInfluences(newArea,i);
for(intx=0;x<xCells;x++)
for(inty=0;y<yCells;y++)
Vector2key=newVector2(x,y);
MeshFilterquadStuff=quads[key];
quadStuff.mesh=GetQuadMesh(CellArea(cellDict[key]),quadStuff.mesh);
privatevoidSetInfluences(PointAreapointArea,intareaID)
Vector2roundedPosition=newVector2(Mathf.Round(pointArea.areaPoint.x),Mathf.Round(pointArea.areaPoint.y));
for(inti=0;i<circleCells.Length;i++)
Vector2key=circleCells[i]+roundedPosition;
if(key.x>=0&&key.y>=0&&key.x<xCells&&key.y<yCells)
Cellcell=cellDict[key];
floatdistance=(key-pointArea.areaPoint).sqrMagnitude;
if(distance<cell.distance)
cell.distance=distance;
cell.areaID=areaID;
privateColorCellArea(CellgridCell)
return(gridCell.areaID!=-1)?pointAreas[gridCell.areaID].areaColor:Color.black;
privatestaticMeshGetQuadMesh(ColormeshColor,Meshm)
m.colors=new[]{
meshColor,
meshColor,
meshColor,
meshColor
returnm;
[System.Serializable]
publicclassCell
publicintareaID;
publicfloatdistance;
[System.Serializable]
publicclassPointArea
publicVector2areaPoint;
publicColorareaColor;
publicPointArea(Vector2areaPoint,ColorareaColor)
this.areaPoint=areaPoint;
this.areaColor=areaColor;
publicclasspumpRingTest:MonoBehaviour
publicGameObjectring;
publicintrings;
publicfloatscale;
privateMaterial[]mats;
privatefloatanim;
privatestaticreadonlyintScale=Shader.PropertyToID("_scale");
privatestaticreadonlyintBlob=Shader.PropertyToID("_blob");
privatestaticreadonlyintLerp=Shader.PropertyToID("_lerp");
privatevoidStart()
mats=newMaterial[rings];
mats[0]=ring.GetComponent<MeshRenderer>().material;
ring.transform.rotation=Quaternion.AngleAxis(Random.Range(0,360),Vector3.up)*Quaternion.AngleAxis(Random.Range(-2f,2f),Vector3.forward);
for(inti=1;i<rings;i++)
GameObjectinst=Instantiate(ring);
inst.transform.rotation=Quaternion.AngleAxis(Random.Range(0,360),Vector3.up)*Quaternion.AngleAxis(Random.Range(-2f,2f),Vector3.forward);
mats[i]=inst.GetComponent<MeshRenderer>().material;
privatevoidUpdate()
anim+=Time.deltaTime*.2f;
for(inti=0;i<rings;i++)
floatlerp=(i*1f/rings+anim)%1;
mats[i].SetFloat(Scale,(1-Mathf.Pow(1-lerp,3))*scale);
mats[i].SetFloat(Blob,Mathf.SmoothStep(0,2,Mathf.PingPong(lerp*2,1)));
mats[i].SetFloat(Lerp,-.45f+lerp*1.65f);
publicclassRadAngleTest:MonoBehaviour
[Range(0,1)]
publicfloatforwardLerp,range;
publicfloatradius;
privatevoidUpdate()
forwardLerp=Mathf.Repeat(forwardLerp+Time.deltaTime*.2f,1);
DRAW.Circle(Vector3.zero,radius,100).SetColor(Color.red);
Vector2forward=Quaternion.AngleAxis(forwardLerp*360,Vector3.forward)*Vector3.up;
Vector2point1=Quaternion.AngleAxis((forwardLerp-range*.5f)*360,Vector3.forward)*Vector3.up*radius;
Vector2point2=Quaternion.AngleAxis((forwardLerp+range*.5f)*360,Vector3.forward)*Vector3.up*radius;
DRAW.Circle(point1,.1f,30).SetColor(Color.red).Fill(1);
DRAW.Circle(point2,.1f,30).SetColor(Color.red).Fill(1);
Vector2point=Camera.main.ScreenToWorldPoint(Input.mousePosition).SetZ(0);
DRAW.Circle(point,.1f,30).SetColor(Color.cyan).Fill(1);
DRAW.Circle(forward*radius,.2f,30).SetColor(Color.yellow);
DRAW.Vector(Vector2.zero,forward*radius).SetColor(Color.yellow);
Vector2dir=point.normalized;
floatangle=forward.RadAngle(dir);
DRAW.Text(angle.ToString(),point,Color.cyan,3,offset:Vector2.up*4);
floatclampAngle=Mathf.Min(Mathf.Abs(angle),range*Mathf.PI)*Mathf.Sign(angle);
Vector2point3=Quaternion.AngleAxis(forwardLerp*360+clampAngle*Mathf.Rad2Deg,Vector3.forward)*Vector3.up*radius;
DRAW.Circle(point3,.3f,30).SetColor(Color.cyan);
publicclassMeshColorSwap:MonoBehaviour
publicMesh[]meshes;
[HideInInspector]publicint[]colorIDs;
[Space(10)]
publicMeshFiltermF;
privateintpick;
privatevoidOnEnable()
SetColor();
publicvoidonSwitchActorColor()
pick=(pick+1)%meshes.Length;
SetColor();
privatevoidSetColor()
if(!gameObject.activeInHierarchy)
return;
mF.mesh=meshes[pick];
publicvoidCollectBounceColors()
colorIDs=newint[meshes.Length];
for(inti=0;i<meshes.Length;i++)
colorIDs[i]=Mathf.FloorToInt(meshes[i].colors[0].r*255);
[CustomEditor(typeof(MeshColorSwap))]
publicclassMeshColorSwapEditor:Editor
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.Space(10);
if(GUILayout.Button("CheckColors"))
(targetasMeshColorSwap).CollectBounceColors();
publicclassMeshPaletteColor:MonoBehaviour
publicintpick;
publicMeshFiltermF;
[Space(10)]
publicBounceLightbounceLight;
privateMeshmesh;
privateList<Color32>colors;
[Space(10)]
publicboolsetOnEnable=true;
privatevoidAwake()
mesh=mF.mesh;
colors=newList<Color32>();
Color32[]c=mesh.colors32;
for(inti=0;i<c.Length;i++)
colors.Add(c[i]);
pick=colors[0].r;
UpdateBounceLightColor();
ShaderPaletteInit.onSwitchActorColor+=onSwitchActorColor;
privatevoidOnEnable()
if(setOnEnable)
SetColor();
privatevoidonSwitchActorColor()
pick=(pick+1)%Palette.Colors.Length;
SetColor();
privatevoidSetColor()
if(!gameObject.activeInHierarchy)
return;
UpdateBounceLightColor();
if(mesh==null)
return;
intcount=colors.Count;
bytep=(byte)pick;
for(inti=0;i<count;i++)
colors[i]=newColor32(p,colors[i].g,colors[i].b,colors[i].a);
mesh.SetColors(colors);
privatevoidUpdateBounceLightColor()
bounceLight.SetColor(Palette.Colors[pick]);
[CreateAssetMenu]
publicclassPalette:ScriptableObject
publicColor[]colors;
publicTexture2Dtextures,matCaps;
[Range(0,2)]
publicfloatreflectionMulti;
publicstaticboolInitialized;
publicstaticColor[]Colors;
publicstaticPaletteInst;
publicconstinttexSize=128;
publicconstfloattexMargin=2/128f;
privatestaticTexture2DgamutText,genTex;
privatestaticreadonlyintMainTex=Shader.PropertyToID("MainTex");
privatestaticreadonlyintPaletteTex=Shader.PropertyToID("Palette");
privatestaticreadonlyintMatCapTex=Shader.PropertyToID("MatCap");
privatestaticreadonlyintPaletteFactor=Shader.PropertyToID("PaletteFactor");
privatestaticreadonlyintPaletteOffset=Shader.PropertyToID("PaletteOffset");
privatestaticreadonlyintMatCapXMulti=Shader.PropertyToID("MatCapXMulti");
privatestaticreadonlyintTexMargin=Shader.PropertyToID("TexMargin");
privatestaticreadonlyintTexMarginMulti=Shader.PropertyToID("TexMarginMulti");
privatestaticreadonlyintReflectionMulti=Shader.PropertyToID("ReflectionMulti");
publicstaticvoidLoad(boolloadNormal=true)
Inst=Resources.Load<Palette>("Palette");
Colors=Inst.colors;
for(inti=0;i<Colors.Length;i++)
Colors[i]=Colors[i].A(1);
if(loadNormal)
genTex=newTexture2D(Inst.colors.Length,1,TextureFormat.ARGB32,false)
filterMode=FilterMode.Point
genTex.SetPixels(Colors);
else
genTex=newTexture2D(Inst.colors.Length,1,TextureFormat.ARGB32,false)
filterMode=FilterMode.Point
genTex.SetPixels(Colors.Copy().Randomize());
genTex.Apply();
Shader.SetGlobalTexture(PaletteTex,genTex);
Shader.SetGlobalFloat(PaletteFactor,1f/genTex.width);
Shader.SetGlobalFloat(PaletteOffset,1f/genTex.width*.5f);
Shader.SetGlobalTexture(MatCapTex,Inst.matCaps);
Shader.SetGlobalFloat(MatCapXMulti,1f/((float)Inst.matCaps.width/Inst.matCaps.height));
Shader.SetGlobalFloat(TexMargin,texMargin);
Shader.SetGlobalFloat(TexMarginMulti,1f/(1f+texMargin*2));
Shader.SetGlobalTexture(MainTex,Inst.textures);
Shader.SetGlobalFloat(ReflectionMulti,Inst.reflectionMulti);
Initialized=true;
publicstaticvoidEditorLoad(){Load();}
publicclassPaletteSource:ScriptableObject
publicColor[]oldColors,newColors,hues,houdini;
[Space(10)]
publicTexture2D[]textures,matCaps;
[Space(10)]
publicTexture2DtestMatCap;
[HideInInspector]
publicint[]mapping;
privatestaticPaletteSource_source;
publicstaticPaletteSourceGet
get
if(_source==null)
_source=AssetDatabase.LoadAssetAtPath<PaletteSource>("Assets/03_Scenes/ShaderPalette/SourceFiles/PaletteSource.asset");
return_source;
publicclassShaderPaletteInit:Singleton<ShaderPaletteInit>,IamUI
[Space(10)]publicGameObject[]button;
privateImage[]images;
privateColor[]colors;
publicdelegatevoidSwitchActorColor();
publicstaticeventSwitchActorColoronSwitchActorColor;
privatereadonlystring[]Keywords={"normals","grey","desaturate","test","cheap"};
privatestring[]PrefKeywords;
privatevoidAwake()
PrefKeywords=newstring[Keywords.Length];
for(inti=0;i<Keywords.Length;i++)
PrefKeywords[i]="ShaderVar_"+Keywords[i];
Palette.Load();
images=newImage[button.Length];
colors=newColor[button.Length];
for(inti=0;i<button.Length;i++)
images[i]=button[i].transform.parent.GetComponent<Image>();
colors[i]=images[i].color;
for(inti=0;i<button.Length;i++)
SetValue(i);
privatevoidOnEnable()
UI_Manager.activeUI.Add(this);
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Slash))
SetValue(0,true);
if(Input.GetKeyDown(KeyCode.Quote))
SetValue(1,true);
if(Input.GetKeyDown(KeyCode.BackQuote))
SetValue(2,true);
/*if(Input.GetKeyDown(KeyCode.N))
SetValue(Test,true);*/
if(KeyMap.Down(Key.Dev_ColorShift)&&onSwitchActorColor!=null)
onSwitchActorColor();
privatevoidSetValue(intindex,booltoggle=false)
stringvarName=Keywords[index];
stringprefName=PrefKeywords[index];
boolvalue=PlayerPrefs.GetInt(prefName)==1;
if(toggle)
value=!value;
PlayerPrefs.SetInt(prefName,value?1:0);
else
PlayerPrefs.SetInt(prefName,0);
value=false;
stringbigString=varName.ToUpper();
Shader.DisableKeyword(bigString+(value?"_OFF":"_ON"));
Shader.EnableKeyword(bigString+(!value?"_OFF":"_ON"));
images[index].color=(colors[index]*(value?1:.75f)).A(1);
publicboolHitUI(boolclick)
for(inti=0;i<5;i++)
if(UI_Manager.ImPointedAt(button[i]))
if(click)
SetValue(i,true);
returntrue;
returnfalse;
publicvoidShow(boolshow)
gameObject.SetActive(show);
[CustomEditor(typeof(Palette))]
publicclassPaletteEditor:Editor{
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.Space(20);
GUI.color=COLOR.green.lime;
if(GUILayout.Button("Load"))
Palette.Load();
[CustomEditor(typeof(PaletteSource))]
publicclassPaletteSourceEditor:Editor
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.Space(20);
GUILayout.BeginHorizontal();
GUI.color=COLOR.green.lime;
if(GUILayout.Button("UpdateTextures"))
UpdateTextures(targetasPaletteSource,false);
GUI.color=COLOR.orange.coral;
if(GUILayout.Button("UpdateTextureswithTestMatCap"))
UpdateTextures(targetasPaletteSource,true);
GUI.color=Color.white;
GUILayout.EndHorizontal();
privatestaticvoidUpdateTextures(PaletteSourcesource,booluseTestMaptCap)
if(!Palette.Initialized)
Palette.Load();
Palettepalette=Palette.Inst;
constinttexRes=Palette.texSize;
Texture2DwallTexture=newTexture2D((source.textures.Length*texRes).NextPowerOfTwo(),texRes,TextureFormat.ARGB32,false)
filterMode=FilterMode.Bilinear,wrapMode=TextureWrapMode.Clamp,requestedMipmapLevel=0
constfloatstepMulti=(1+Palette.texMargin*2)/1f;
for(inti=0;i<source.textures.Length;i++)
Texture2DreadTex=source.textures[i];
floatsize=readTex.width;
floatreadStep=size/texRes;
floatoffset=size*-Palette.texMargin;
intxOffset=i*texRes;
for(intx=0;x<texRes;x++)
for(inty=0;y<texRes;y++)
intreadX=Mathf.FloorToInt(Mathf.Repeat(offset+x*readStep*stepMulti,size));
intreadY=Mathf.FloorToInt(Mathf.Repeat(offset+y*readStep*stepMulti,size));
wallTexture.SetPixel(x+xOffset,y,readTex.GetPixel(readX,readY));
wallTexture.Apply();
wallTexture=SaveTexture(wallTexture,"WallTextures");
palette.textures=wallTexture;
intmatCapRes=source.matCaps[0].height;
Texture2DmatCapTex=newTexture2D((source.matCaps.Length*matCapRes).NextPowerOfTwo(),matCapRes,TextureFormat.ARGB32,false)
filterMode=FilterMode.Trilinear,
wrapMode=TextureWrapMode.Clamp,
for(inti=0;i<source.matCaps.Length;i++)
Texture2DreadTex=useTestMaptCap?source.testMatCap:source.matCaps[i];
for(intx=0;x<matCapRes;x++)
for(inty=0;y<matCapRes;y++)
matCapTex.SetPixel(x+i*matCapRes,y,readTex.GetPixel(x,y));
matCapTex.Apply();
matCapTex=SaveTexture(matCapTex,"MatCaps");
palette.matCaps=matCapTex;
EditorUtility.SetDirty(palette);
Palette.Load();
privatestaticTexture2DSaveTexture(Texture2Dtexture,stringname)
stringfullPath=Application.dataPath+"/03_Scenes/ShaderPalette/SourceFiles/"+name+".png";
byte[]bytes=texture.EncodeToPNG();
FileStreamstream=newFileStream(fullPath,FileMode.OpenOrCreate,FileAccess.Write);
BinaryWriterwriter=newBinaryWriter(stream);
for(inti=0;i<bytes.Length;i++)
writer.Write(bytes[i]);
writer.Close();
stream.Close();
AssetDatabase.Refresh();
returnAssetDatabase.LoadAssetAtPath<Texture2D>(folder+name+".png");
privateconststringfolder="Assets/03_Scenes/ShaderPalette/SourceFiles/";
publicstaticclassUpdatePalette
[MenuItem("Tools/Mesh/LogVerticeColors%#F10",false,101)]
publicstaticvoidCheckColor()
if(Selection.activeGameObject==null)
return;
MeshFilterfilter=Selection.activeGameObject.GetComponent<MeshFilter>();
SkinnedMeshRendererskinnedMeshRenderer=Selection.activeGameObject.GetComponent<SkinnedMeshRenderer>();
if(filter==null&&skinnedMeshRenderer==null)
return;
Color32[]verticeColors=filter!=null?filter.sharedMesh.colors32:skinnedMeshRenderer.sharedMesh.colors32;
List<Color32>colors=newList<Color32>();
for(inti=0;i<verticeColors.Length;i++)
colors.AddUnique(verticeColors[i]);
for(inti=0;i<colors.Count;i++)
Debug.Log(colors.Log());
[MenuItem("Tools/Mesh/Info")]
privatestaticvoidMeshInfo()
if(Selection.activeGameObject!=null)
MeshFiltermF=Selection.activeGameObject.GetComponent<MeshFilter>();
if(mF!=null)
Meshmesh=Application.isPlaying?mF.mesh:mF.sharedMesh;
Colorcolor=mesh.colors[0];
Debug.Log("R:"+Mathf.Floor(color.r*255)+"float:"+color.r);
Debug.Log("G:"+Mathf.Floor(color.g*255)+"float:"+color.g);
Debug.Log("B:"+Mathf.Floor(color.g*255)+"float:"+color.b);
if(mesh.uv.Length>0)
Debug.Log("MeshhasUVs");
if(mesh.tangents.Length>0)
Debug.Log("MeshhasTangents");
[MenuItem("Assets/DeleteSubAsset")]
privatestaticvoidSubAsset()
stringpath=AssetDatabase.GetAssetPath(Selection.activeObject);
Object.DestroyImmediate(Selection.activeObject,true);
AssetDatabase.ImportAsset(path);
[MenuItem("Assets/DeleteSubAsset",true)]
privatestaticboolNewMenuOptionValidation()
returnSelection.activeObjectisMesh;
namespaceShapeStuff
publicpartialclassShape
privatevoidCreate_WigglyLine()
segmentCount=10;
for(inti=0;i<segmentCount;i++)
(i==0?segments[0].Randomize():segments[i].Connect(segments[i-1])).SetLengthBend(Random.Range(1,3),Random.Range(-.8f,.8f));
FinishSetup();
privatevoidCreate_Circle()
segmentCount=1;
segments[0].Randomize().SetLengthBend(Random.Range(4,20f),Sign.Random);
FinishSetup();
privatevoidCreate_Quad()
segmentCount=8;
floatsideLength=Random.Range(.5f,4);
floatcornerLength=Random.Range(.5f,4);
floatextra=Random.Range(-.2f,.2f);
floatdir=.25f*Sign.Random;
segments[0].Randomize().SetLengthBend(cornerLength,dir+extra);
segments[1].Connect(segments[0]).SetLengthBend(sideLength,-extra);
segments[2].Connect(segments[1]).SetLengthBend(cornerLength,dir+extra);
segments[3].Connect(segments[2]).SetLengthBend(sideLength,-extra);
segments[4].Connect(segments[3]).SetLengthBend(cornerLength,dir+extra);
segments[5].Connect(segments[4]).SetLengthBend(sideLength,-extra);
segments[6].Connect(segments[5]).SetLengthBend(cornerLength,dir+extra);
segments[7].Connect(segments[6]).SetLengthBend(sideLength,-extra);
FinishSetup();
privatevoidCreate_Tri()
segmentCount=6;
floatsideLength=Random.Range(.5f,4);
floatcornerLength=Random.Range(.5f,4);
floatextra=Random.Range(-.2f,.2f);
floatdir=1f/3*Sign.Random;
segments[0].Randomize().SetLengthBend(cornerLength,dir+extra);
segments[1].Connect(segments[0]).SetLengthBend(sideLength,-extra);
segments[2].Connect(segments[1]).SetLengthBend(cornerLength,dir+extra);
segments[3].Connect(segments[2]).SetLengthBend(sideLength,-extra);
segments[4].Connect(segments[3]).SetLengthBend(cornerLength,dir+extra);
segments[5].Connect(segments[4]).SetLengthBend(sideLength,-extra);
FinishSetup();
privatevoidCreate_Pill()
segmentCount=4;
floatsideLength=Random.Range(.5f,4);
floatcornerLength=Random.Range(.5f,4);
floatextra=Random.Range(-.3f,.3f);
floatdir=.5f*Sign.Random;
segments[0].Randomize().SetLengthBend(cornerLength,dir+extra);
segments[1].Connect(segments[0]).SetLengthBend(sideLength,-extra);
segments[2].Connect(segments[1]).SetLengthBend(cornerLength,dir+extra);
segments[3].Connect(segments[2]).SetLengthBend(sideLength,-extra);
FinishSetup();
privatevoidCreate_WigglePill()
segmentCount=6;
floatsideLength=Random.Range(.5f,4);
floatcornerLength=Random.Range(.5f,4);
floatwiggle=Random.Range(-.2f,.2f);
floatdir=.5f*Sign.Random;
segments[0].Randomize().SetLengthBend(cornerLength,dir);
segments[1].Connect(segments[0]).SetLengthBend(sideLength*.5f,wiggle);
segments[2].Connect(segments[1]).SetLengthBend(sideLength*.5f,-wiggle);
segments[3].Connect(segments[2]).SetLengthBend(cornerLength,dir);
segments[4].Connect(segments[3]).SetLengthBend(sideLength*.5f,wiggle);
segments[5].Connect(segments[4]).SetLengthBend(sideLength*.5f,-wiggle);
FinishSetup();
privatevoidCreate_BendPill()
segmentCount=4;
floatcornerLength=Random.Range(.5f,4);
floatcornerRadius=cornerLength/Mathf.PI;
floatsideLength=Random.Range(cornerLength*2,12);
floatpillBend=Random.Range(-.49f,.49f);
floatbendRadius=sideLength*(1f/Mathf.Abs(pillBend))*.5f/2/Mathf.PI;
floatinnerLength=(bendRadius-cornerRadius)*2*Mathf.PI*Mathf.Abs(pillBend);
floatouterLength=(bendRadius+cornerRadius)*2*Mathf.PI*Mathf.Abs(pillBend);
boolleftBend=pillBend>0;
segments[0].Randomize().SetLengthBend(cornerLength,.5f);
segments[1].Connect(segments[0]).SetLengthBend(leftBend?outerLength:innerLength,pillBend);
segments[2].Connect(segments[1]).SetLengthBend(cornerLength,.5f);
segments[3].Connect(segments[2]).SetLengthBend(leftBend?innerLength:outerLength,-pillBend);
FinishSetup();
privatevoidCreate_Spiral()
segmentCount=10;
floatstartLength=Random.Range(1f,4f);
floatshrinkage=1f/segmentCount*Random.Range(.3f,.98f);
floatsegmentBend=Random.Range(.05f,.4f)*Sign.Random;
for(inti=0;i<segmentCount;i++)
(i==0?segments[0].Randomize():segments[i].Connect(segments[i-1])).SetLengthBend(startLength*(1-shrinkage*i),segmentBend);
FinishSetup();
privatevoidCreate_Flower()
intsegCount=Random.Range(2,6);
segmentCount=segCount*2;
floatradius=Random.Range(1f,1.5f);
floatsegmentRad=2*Mathf.PI/segCount;
floatratio=Random.Range(.3f,.7f);
floatsegmentA=segmentRad*ratio;
floatradA=(.5f*Mathf.PI-segmentA*.5f)*2;
floatradiusA=radius*Mathf.Sin(segmentA*.5f)/Mathf.Sin(radA*.5f);
floatbendA=1-radA/(2*Mathf.PI);
floatlengthA=2*Mathf.PI*radiusA*bendA;
floatsegmentB=segmentRad-segmentA;
floatradB=(.5f*Mathf.PI-segmentB*.5f)*2;
floatradiusB=radius*Mathf.Sin(segmentB*.5f)/Mathf.Sin(radB*.5f);
floatbendB=radB/(2*Mathf.PI);
floatlengthB=2*Mathf.PI*radiusB*bendB;
intdir=Sign.Random;
for(inti=0;i<segCount;i++)
(i==0?segments[0].Randomize():segments[i*2].Connect(segments[i*2-1])).SetLengthBend(lengthA,-bendA*dir);
segments[i*2+1].Connect(segments[i*2]).SetLengthBend(lengthB,bendB*dir);
FinishSetup();
privatevoidCreate_Splooch()
intsegCount=Random.Range(2,6);
segmentCount=segCount*2;
floatradius=Random.Range(1f,1.5f);
floatsegmentRad=2*Mathf.PI/segCount;
intdir=Sign.Random;
for(inti=0;i<segCount;i++)
floatratio=Random.Range(.2f,.8f);
floatsegmentA=segmentRad*ratio;
floatradA=(.5f*Mathf.PI-segmentA*.5f)*2;
floatradiusA=radius*Mathf.Sin(segmentA*.5f)/Mathf.Sin(radA*.5f);
floatbendA=1-radA/(2*Mathf.PI);
floatlengthA=2*Mathf.PI*radiusA*bendA;
floatsegmentB=segmentRad-segmentA;
floatradB=(.5f*Mathf.PI-segmentB*.5f)*2;
floatradiusB=radius*Mathf.Sin(segmentB*.5f)/Mathf.Sin(radB*.5f);
floatbendB=radB/(2*Mathf.PI);
floatlengthB=2*Mathf.PI*radiusB*bendB;
(i==0?segments[0].Randomize():segments[i*2].Connect(segments[i*2-1])).SetLengthBend(lengthA,-bendA*dir);
segments[i*2+1].Connect(segments[i*2]).SetLengthBend(lengthB,bendB*dir);
FinishSetup();
publicvoidCreateExtrude(ShapeguideShape)
if(guideShape.loop)
segmentCount=0;
FinishSetup();
return;
floatwidth=Mathf.Min(.14f,guideShape.PossibleThickness);
segmentCount=guideShape.segmentCount*2+2;
floatdir=1;
Segmentbefore=null;
intindex=0;
for(inti=0;i<2;i++)
for(inte=0;e<guideShape.segmentCount;e++)
intreadIndex=i==0?e:guideShape.segmentCount-1-e;
SegmentreadSegment=guideShape.segments[readIndex];
floatradius=readSegment.arc.SignedRadius;
floatnewRadius=radius-width*dir;
floatmulti=newRadius/radius;
floatsegmentLength=readSegment.length*multi;
if(before==null)
segments[0].SetPointDir(guideShape.GetPoint(0,-width),guideShape.segments[0].radA);
else
segments[index].Connect(before);
segments[index].SetLengthBend(segmentLength,readSegment.Bend*dir);
before=segments[index];
index++;
floatcapLength=Mathf.PI*width;
segments[index].Connect(before).SetLengthBend(capLength,-.5f);
before=segments[index];
index++;
dir=-1;
FinishSetup();
publicvoidCreateByNumber(intnumber)
switch(number)
case0:Create_WigglyLine();break;
case1:Create_Circle();break;
case2:Create_Quad();break;
case3:Create_Tri();break;
case4:Create_Pill();break;
case5:Create_WigglePill();break;
case6:Create_BendPill();break;
case7:Create_Spiral();break;
case8:Create_Flower();break;
case9:Create_Splooch();break;
publicclassCamTilt:MonoBehaviour
privatefloatlerp;
privateboolstraight=true;
privateintcall;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.T))
StartCoroutine(SwingCam());
transform.rotation=Quaternion.Slerp(Rot.Zero,Quaternion.Euler(newVector3(-17,-30,.5f)),lerp);
privateIEnumeratorSwingCam()
straight=!straight;
call++;
intmyCall=call;
floattime=0;
floatstart=lerp;
floatend=straight?0:1;
while(time<1&&myCall==call)
time+=Time.deltaTime*3;
lerp=Mathf.SmoothStep(start,end,Mathf.Pow(time,1.5f));
yieldreturnnull;
publicclassFillMesher:MonoBehaviour
publicMeshFiltermeshFilter;
publicMeshRenderermeshRenderer;
privatereadonlyVector3[]vertices=newVector3[short.MaxValue],
normals=newVector3[short.MaxValue];
privateMeshmesh;
privatevoidAwake()
mesh=newMesh();
meshFilter.mesh=mesh;
mesh.vertices=vertices;
for(inti=0;i<normals.Length;i++)
normals[i]=Vector3.back;
mesh.normals=normals;
publicvoidSetShape(Shapeshape)
if(!gameObject.activeInHierarchy)
return;
if(!shape.loop||shape.Intersects(shape))
if(meshRenderer.enabled)
meshRenderer.enabled=false;
return;
if(!meshRenderer.enabled)
meshRenderer.enabled=true;
Triangulator.FillShape(shape,.09f);
for(inti=0;i<Triangulator.pointCount;i++)
vertices[i]=Triangulator.pnts[i];
mesh.vertices=vertices;
mesh.triangles=Triangulator.triangles.ToArray();
mesh.RecalculateBounds();
publicclassIntersectionTest:MonoBehaviour
publicTransformcenter;
publicfloatradius;
[Space(10)]
publicTransformroot;
publicTransformaim;
[Space(10)]publicShapeTestshapeTest;
[Space(10)]publicbooluseShape;
privatevoidUpdate()
if(!useShape)
Vector2p1,p2;
intintersection=newCircle(center.position,radius).Contact(newLine(root.position,aim.position),outp1,outp2);
boolintersect=intersection>0;
if(intersection>0)
DRAW.Circle(p1,.1f,16).SetColor(Color.white).Fill(1);
if(intersection==2)
DRAW.Circle(p2,.1f,16).SetColor(Color.white).Fill(1);
DRAW.Circle(center.position,radius,50).SetColor(COLOR.blue.cornflower);
DRAW.Ray(root.position,aim.position).SetColor(intersect?Color.white:COLOR.red.tomato);
else
Vector2p1;
boolhit=shapeTest.shape.Raycast(root.position,aim.position-root.position,outp1);
DRAW.Ray(root.position,aim.position).SetColor(hit?Color.white:COLOR.red.tomato);
if(hit)
DRAW.Circle(p1,.1f,16).SetColor(Color.white).Fill(1);
publicclassLerpTest:MonoBehaviour
publicfloatvalue,a,b,result;
privatevoidUpdate()
result=Mth.Repeat(a,b,value);
publicclassMeshDrawTest:MonoBehaviour
publicMeshmesh;
privateVector3[]vertices;
privateint[]triangles;
privatevoidAwake()
vertices=mesh.vertices;
triangles=mesh.triangles;
privatevoidUpdate()
DRAW.Polygons(vertices,triangles,transform).SetColor(COLOR.red.tomato);
namespaceShapeStuff
publicpartialclassShape
publicreadonlySegment[]segments;
privatereadonlyfloat[]lerps;
publicintsegmentCount;
publicfloatlength;
publicboolloop,clockwise;
publicBounds2Dbounds;
publicVector2intersectionPoint;
publicShape()
constintmaxSegments=30;
segments=newSegment[maxSegments];
for(inti=0;i<maxSegments;i++)
segments[i]=newSegment();
lerps=newfloat[maxSegments];
publicvoidFinishSetup()
length=0;
for(inti=0;i<segmentCount;i++)
length+=segments[i].length;
floatdist=0;
for(inti=0;i<segmentCount;i++)
floatlerpA=dist/length;
lerps[i]=lerpA;
dist+=segments[i].length;
floatlerpB=dist/length;
segments[i].SetShapeLerpRange(lerpA,lerpB,i==segmentCount-1);
lerps[segmentCount]=1;
UpdateBounds();
loop=segmentCount>0&&GetPoint(0).Same(GetPoint(1));
clockwise=GetRad(0)>GetRad(1);
privatevoidUpdateBounds()
bounds=segments[0].bounds;
for(inti=1;i<segmentCount;i++)
bounds=bounds.Add(segments[i].bounds);
bounds=bounds.Pad(1f);
publicvoidMove(Vector2dir)
for(inti=0;i<segmentCount;i++)
segments[i].Move(dir);
UpdateBounds();
publicvoidRotateAround(Vector2point,floatrad)
for(inti=0;i<segmentCount;i++)
segments[i].RotateAround(point,rad);
UpdateBounds();
publicfloatPossibleThickness
get
floatthickness=float.MaxValue;
for(inti=0;i<segmentCount;i++)
segments[i].MaxShapeThickness(refthickness);
returnthickness;
publicintGetSegmentIndex(floatshapeLerp)
for(inti=0;i<segmentCount;i++)
if(lerps[i]>shapeLerp)
returni-1;
returnMathf.Max(0,segmentCount-1);
publicfloatGetSegmentLerp(intsegmentIndex,floatshapeLerp)
returnMathf.InverseLerp(lerps[segmentIndex],lerps[segmentIndex+1],shapeLerp);
publicVector2GetPoint(floatshapeLerp,floatoffset=0)
intsegmentIndex=GetSegmentIndex(shapeLerp);
floatsegmentLerp=GetSegmentLerp(segmentIndex,shapeLerp);
returnsegments[segmentIndex].LerpPos(segmentLerp,offset);
privatefloatGetRad(floatshapeLerp)
intsegmentIndex=GetSegmentIndex(shapeLerp);
floatsegmentLerp=GetSegmentLerp(segmentIndex,shapeLerp);
returnsegments[segmentIndex].LerpRad(segmentLerp);
publicVector2GetDir(floatshapeLerp)
intsegmentIndex=GetSegmentIndex(shapeLerp);
floatsegmentLerp=GetSegmentLerp(segmentIndex,shapeLerp);
returnsegments[segmentIndex].LerpDir(segmentLerp);
publicVector2GetNormal(floatshapeLerp)
intsegmentIndex=GetSegmentIndex(shapeLerp);
floatsegmentLerp=GetSegmentLerp(segmentIndex,shapeLerp);
returnsegments[segmentIndex].LerpRight(segmentLerp)*(clockwise?-1:1);
publicVector2GetClosestPoint(Vector2point)
Vector2closestPoint=point;
floatminDist=float.MaxValue;
for(inti=0;i<segmentCount;i++)
Vector2closestSegmentPoint=segments[i].GetClosestPoint(point);
floatdist=(point-closestSegmentPoint).sqrMagnitude;
if(dist<minDist)
minDist=dist;
closestPoint=closestSegmentPoint;
returnclosestPoint;
publicboolIsInside(Vector2point)
if(!loop)
returnfalse;
for(inti=0;i<segmentCount;i++)
if(!segments[i].OnInsideSide(point,clockwise))
floatradius=segments[i].arc.radius;
Vector2dir=segments[i].arc.center-point;
boolisClose=dir.sqrMagnitude<radius*radius;
if(segments[i]==RaycastSegment(point,isClose?-dir:dir))
returnfalse;
returntrue;
publicfloatGetClosestDistance(ShapeotherShape,outVector2p1,outVector2p2)
p1=p2=V2.zero;
Vector2segmentP1=V2.zero,segmentP2=V2.zero;
floatclosestDist=float.MaxValue;
for(inti=0;i<segmentCount;i++)
for(inte=0;e<otherShape.segmentCount;e++)
floatdist=segments[i].DistanceSqr(otherShape.segments[e],closestDist,refsegmentP1,refsegmentP2);
if(dist<closestDist)
closestDist=dist;
p1=segmentP1;
p2=segmentP2;
if(f.Same(dist,0))
returnclosestDist;
returnclosestDist;
publicboolIntersects(ShapeotherShape)
if(!bounds.Intersects(otherShape.bounds))
returnfalse;
boolself=otherShape==this;
intstep=0;
for(inti=0;i<segmentCount;i++)
for(inte=step;e<otherShape.segmentCount;e++)
boolignore=self&&(e==i||e==i.IndexDown(segmentCount)||e==i.IndexUp(segmentCount));
if(!ignore&&segments[i].Overlap(otherShape.segments[e],refintersectionPoint))
returntrue;
if(self)
step++;
returnfalse;
publicboolRaycast(Vector2root,Vector2dir,outVector2hitPoint)
boolhit=false;
floathitDistance=float.MaxValue;
hitPoint=Vector2.zero;
for(inti=0;i<segmentCount;i++)
Vector2segmentPoint;
if(segments[i].RayCast(root,dir,outsegmentPoint))
hit=true;
floatdist=(segmentPoint-root).sqrMagnitude;
if(dist<hitDistance)
hitDistance=dist;
hitPoint=segmentPoint;
returnhit;
privateSegmentRaycastSegment(Vector2root,Vector2dir)
SegmenthitSegment=null;
floathitDistance=float.MaxValue;
for(inti=0;i<segmentCount;i++)
Vector2segmentPoint;
if(segments[i].RayCast(root,dir,outsegmentPoint))
floatdist=(segmentPoint-root).sqrMagnitude;
if(dist<hitDistance)
hitDistance=dist;
hitSegment=segments[i];
returnhitSegment;
publicintGetTesselation(floattesselation)
intsteps=0;
for(inti=0;i<segmentCount;i++)
steps+=segments[i].GetTesselation(tesselation);
returnsteps+(loop?0:1);
publicintGetFacingDirections(floattopRatio,floatbottomRatio,refSegment.FacingLerp[]points)
floatnormalRad=GetNormal(0).ToRadian();
floatbendLerp4=normalRad/Mathf.PI*2;
intdirStep=Mathf.FloorToInt(bendLerp4);
floatlerp=bendLerp4-dirStep;
intdir=-1;
switch(dirStep)
case0:dir=lerp<1f-topRatio?0:1;break;
case1:dir=lerp<topRatio?1:2;break;
case2:dir=lerp<1f-bottomRatio?2:3;break;
case3:dir=lerp<bottomRatio?3:0;break;
intindex=0;
for(inti=0;i<segmentCount;i++)
index=segments[i].GetFacingChanges(clockwise,topRatio,bottomRatio,refpoints,refdir,index);
returnindex;
publicclassShapeFacingDrawer
privateShape.Segment.FacingLerp[]facings=newShape.Segment.FacingLerp[200];
privateintfacingCount;
privatefloattopRatio=.5f,bottomRatio=.5f;
publicboolActive{get{returnfacingCount>0;}}
publicvoidUpdateRatios(Shapeshape)
boolinput=false;
if(Input.GetKey(KeyCode.Alpha1))
topRatio=Mathf.Clamp(topRatio-Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha3))
topRatio=Mathf.Clamp(topRatio+Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha4))
bottomRatio=Mathf.Clamp(bottomRatio-Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha6))
bottomRatio=Mathf.Clamp(bottomRatio+Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha2))
topRatio=.5f;
input=true;
if(Input.GetKey(KeyCode.Alpha5))
bottomRatio=.5f;
input=true;
if(input)
UpdateFacings(shape);
publicvoidUpdateFacings(Shapeshape)
facingCount=shape.GetFacingDirections(topRatio,bottomRatio,reffacings);
publicvoidDrawFacings(Shapeshape)
if(!shape.loop)
return;
for(inti=0;i<facingCount;i++)
Colorc;
switch(facings[i].sideID)
default:c=Color.Lerp(Color.red,Color.blue,.1f);break;
case1:c=Color.green;break;
case2:c=Color.yellow;break;
case3:c=Color.Lerp(Color.cyan,Color.blue,.4f);break;
floatlength=(i==facingCount-1?facings[0].lerp+1:facings[i+1].lerp)-facings[i].lerp;
intsteps=Mathf.Max(2,Mathf.CeilToInt(length*300));
floatstepLength=length/(steps-1);
floatstartLerp=facings[i].lerp;
constfloatpad=0;
floatpadding=shape.clockwise?-pad:pad;
DRAW.Line(steps,e=>shape.GetPoint(Mathf.Repeat(startLerp+e*stepLength,1))).SetColor(c);
floatmidLerp=Mathf.Repeat(startLerp+length*.5f,1);
Vector2midPoint=shape.GetPoint(midLerp);
Vector2midNormal=shape.GetNormal(midLerp);
Vector2pointDir;
switch(facings[i].sideID)
default:pointDir=V2.right;break;
case1:pointDir=V2.up;break;
case2:pointDir=V2.left;break;
case3:pointDir=V2.down;break;
DRAW.Arrow(midPoint+midNormal*pad,pointDir*.19f,.05f).SetColor(c).Fill(1);
/*for(inti=0;i<shape.segmentCount;i++)
shape.segments[i].DrawFacingChanges(shape.clockwise,.5f,.5f);*/
publicvoidDrawStartDir(Shapeshape)
Vector2point=shape.GetPoint(0);
Vector2dir=shape.GetDir(0);
Vector2normal=shape.GetNormal(0);
DRAW.Arrow(point,dir*.25f,.1f).SetColor(Color.white).Fill(1);
DRAW.Arrow(point,normal*.2f,.1f).SetColor(Color.white).Fill(1);
namespaceShapeStuff
publicclassShapeLineDrawer
publicShapeLineDrawer(intpointCount=200)
shapePointCount=pointCount;
shapePoints=newVector2[shapePointCount];
shapeNormals=newVector2[shapePointCount];
fractionBounds=newBounds2D[10];
for(inti=0;i<fractionBounds.Length;i++)
fractionBounds[i]=newBounds2D();
privatereadonlyVector2[]shapePoints;
privatereadonlyintshapePointCount;
privatereadonlyVector2[]shapeNormals;
privateboolloop,clockwise,active;
privateColorlineColor;
privatereadonlyBounds2D[]fractionBounds;
publicvoidSetShape(Shapeshape,ColorlineColor)
this.lineColor=lineColor;
active=shape.segmentCount>0;
floatdivider=1f/(shapePointCount-1);
for(inti=0;i<shapePointCount;i++)
shapePoints[i]=shape.GetPoint(Mathf.Clamp(i*divider,0,.99999f));
shapeNormals[i]=shape.GetNormal(Mathf.Clamp(i*divider,0,.99999f));
loop=shape.loop;
clockwise=shape.clockwise;
floatfraction=1f/fractionBounds.Length;
for(inti=0;i<fractionBounds.Length;i++)
floatstartLerp=i*fraction;
floatendLerp=startLerp+fraction;
Bounds2Dbounds=fractionBounds[i];
for(inte=0;e<shape.segmentCount;e++)
shape.segments[e].FillBounds(startLerp,endLerp,refbounds);
fractionBounds[i]=bounds.Pad(.1f);
publicvoidDrawLine()
if(active)
DRAW.Line(shapePoints).SetColor(lineColor);
publicvoidDrawArrows()
if(loop)
Colorc=clockwise?COLOR.green.spring.A(.5f):COLOR.red.tomato.A(.5f);
for(inti=0;i<shapePointCount;i+=4)
DRAW.Arrow(shapePoints[i]+shapeNormals[i]*.15f,shapeNormals[i]*.2f,.05f).SetColor(c);
publicstaticvoidDrawPoints(Shapeshape,boolsimple=false,ShapeLineDrawerdrawer=null)
if(simple)
Colorc=drawer!=null?drawer.lineColor.A(.5f):Color.white.A(.6f);
for(inti=0;i<shape.segmentCount;i++)
DRAW.Circle(shape.segments[i].pointA,.03f).SetColor(c).Fill(.6f);
if(i>=shape.segmentCount-1&&!shape.loop)
DRAW.Circle(shape.segments[i].pointB,.03f).SetColor(c).Fill(.6f);
else
for(inti=0;i<shape.segmentCount;i++)
DRAW.ZappCircle(shape.segments[i].pointA,.08f,.05f,10).SetColor(i==0?COLOR.green.lime:COLOR.yellow.fresh).Fill(.1f);
shape.segments[i].DrawMaxima();
if(i>=shape.segmentCount-1&&!shape.loop)
DRAW.ZappCircle(shape.segments[i].pointB,.08f,.05f,10).SetColor(COLOR.yellow.fresh).Fill(.1f);
publicstaticvoidDrawCenters(Shapeshape)
for(inti=0;i<shape.segmentCount;i++)
Vector2c=shape.segments[i].arc.center;
DRAW.Circle(c,.02f,12).SetColor(Color.white).Fill(1);
DRAW.Vector(c,shape.segments[i].LerpPos(.5f)-c).SetColor(Color.white.A(.25f));
DRAW.Vector(c,shape.segments[i].LerpPos(0)-c).SetColor(Color.white.A(.1f));
DRAW.Vector(c,shape.segments[i].LerpPos(1)-c).SetColor(Color.white.A(.1f));
publicvoidDrawFractions(floatlerp)
floatfraction=1f/fractionBounds.Length;
for(inti=0;i<fractionBounds.Length;i++)
floatstartLerp=i*fraction;
floatendLerp=startLerp+fraction;
Colorc=startLerp<=lerp&&endLerp>=lerp?Color.white:Color.white.A(.2f);
DRAW.Rectangle(fractionBounds[i].Center,fractionBounds[i].Size).SetColor(c);
publicstaticvoidDrawBounds(Shapeshape)
for(inti=0;i<shape.segmentCount;i++)
DRAW.Rectangle(shape.segments[i].bounds.Center,shape.segments[i].bounds.Size).SetColor(Color.white.A(.2f));
publicvoidSetLineColor(Colorcolor)
lineColor=color;
namespaceShapeStuff
publicclassShapeMesher
privatereadonlyVector3[]vertices=newVector3[ushort.MaxValue];
privateint[]triangles;
publicvoidSetShape(Shapeshape)
constinttesselation=10;
constfloatwidth=.2f,halfWidth=width*.5f;
intsteps=shape.GetTesselation(tesselation);
intstepCounter=0;
for(inti=0;i<shape.segmentCount;i++)
intsegmentSteps=shape.segments[i].GetTesselation(tesselation);
floatlerpStep=1f/segmentSteps;
for(inte=0;e<segmentSteps;e++)
vertices[stepCounter*2]=shape.segments[i].LerpPos(lerpStep*e,-halfWidth);
vertices[stepCounter*2+1]=shape.segments[i].LerpPos(lerpStep*e,halfWidth);
stepCounter++;
if(!shape.loop)
vertices[stepCounter*2]=shape.segments[shape.segmentCount-1].LerpPos(1,-halfWidth);
vertices[stepCounter*2+1]=shape.segments[shape.segmentCount-1].LerpPos(1,halfWidth);
inttriangleSteps=shape.loop?steps:steps-1;
triangles=newint[triangleSteps*6];
intrepeat=steps*2;
for(inti=0;i<triangleSteps;i++)
triangles[i*6]=i*2%repeat;
triangles[i*6+1]=(i+1)*2%repeat;
triangles[i*6+2]=((i+1)*2+1)%repeat;
triangles[i*6+3]=i*2%repeat;
triangles[i*6+4]=((i+1)*2+1)%repeat;
triangles[i*6+5]=(i*2+1)%repeat;
publicvoidDrawTriangles()
DRAW.Polygons(vertices,triangles).SetColor(COLOR.purple.orchid.A(.3f));
[CreateAssetMenu]
publicclassShapeMeshSet:ScriptableObject
publicboolfill=true;
publicfloatfillOffset;
[Space(10)]
publicEdgeMesh[]top;
publicEdgeMesh[]side;
publicEdgeMesh[]bottom;
[Space(10)]
publicEdgeMesh[]bridges;
privateEdgeMesh[][]edgeMap;
privatereadonlyfloat[]randomNumbers=newfloat[1000];
privatevoidOnEnable()
edgeMap=new[]{bottom,top,bottom,side};
NewSeed();
publicvoidNewSeed()
for(inti=0;i<randomNumbers.Length;i++)
randomNumbers[i]=Random.Range(0f,1f);
publicEdgeMeshGetEdge(intsideID,intsideIndex,intstep)
EdgeMesh[]edges=edgeMap[sideID];
returnedges[GetRandomIndex(0,edges.Length,sideIndex*235+step*531)];
publicEdgeMeshGetBridge(intsideIndex)
returnbridges[GetRandomIndex(0,bridges.Length,sideIndex*235)];
privateintGetRandomIndex(intmin,intmax,intvalue)
intrange=max-min;
returnmin+Mathf.FloorToInt(randomNumbers[value%randomNumbers.Length]*range);
namespaceShapeStuff
publicpartialclassShape
publicclassSegment
publicVector2pointA,pointB;
publicfloatradA,length;
privatefloatshapeLerpA,shapeLerpB,radB;
privateboolstraight,end;
privateintmaximaCount;
privatereadonlyfloat[]maximaLerps=newfloat[4];
publicBounds2Dbounds;
privateLineline;
publicArcarc;
publicfloatBend{get{returnstraight?0:arc.bend;}}
publicSegmentRandomize()
pointA=Random.insideUnitCircle*3;
radA=Random.Range(-Mathf.PI,Mathf.PI);
returnthis;
publicSegmentSetPointDir(Vector2pointA,floatradA)
this.pointA=pointA;
this.radA=radA;
returnthis;
publicSegmentConnect(Segmentbefore)
pointA=before.pointB;
radA=before.radB;
returnthis;
publicvoidSetLengthBend(floatlength,floatbend)
this.length=length;
UpdateSegment(bend);
publicvoidSetShapeLerpRange(floatshapeLerpA,floatshapeLerpB,boolend)
this.shapeLerpA=shapeLerpA;
this.shapeLerpB=shapeLerpB;
this.end=end;
privatevoidUpdateSegment(floatbend)
straight=f.Same(bend,0);
line=newLine(pointA,pointA+Vector2.up.RotRad(radA).SetLength(length));
if(!straight)
arc=newArc(line,bend,0);
radB=radA+arc.bend*2*Mathf.PI;
pointB=LerpPos(1);
maximaCount=0;
if(!straight)
floatmaxLerp=Mathf.Abs(arc.bend);
for(inti=0;i<4;i++)
floatbendLerp=ToRadLerp(.5f*Mathf.PI*i);
if(bendLerp<=maxLerp)
floatmLerp=Mathf.InverseLerp(0,maxLerp,bendLerp);
maximaLerps[maximaCount++]=mLerp;
bounds=newBounds2D(pointA).Add(pointB);
for(inti=0;i<maximaCount;i++)
bounds=bounds.Add(LerpPos(maximaLerps[i]));
publicvoidMove(Vector2dir)
pointA+=dir;
UpdateSegment(Bend);
publicvoidRotateAround(Vector2point,floatrad)
pointA=(pointA-point).RotRad(rad)+point;
radA+=rad;
UpdateSegment(Bend);
publicVector2LerpPos(floatsegmentLerp)
returnstraight?line.LerpPos(segmentLerp):arc.LerpPos(segmentLerp);
publicVector2LerpPos(floatsegmentLerp,floatoffset)
returnstraight?line.LerpPos(segmentLerp)+line.dir.normalized.Rot90(false)*offset
:arc.LerpPos(segmentLerp)+arc.LerpDir(segmentLerp).Rot90(false)*offset;
publicVector2LerpDir(floatsegmentLerp)
returnstraight?line.dir.normalized:arc.LerpDir(segmentLerp);
publicVector2LerpRight(floatsegmentLerp)
returnstraight?line.dir.normalized.Rot90(false):arc.LerpDir(segmentLerp).Rot90(false);
publicfloatLerpRad(floatsegmentLerp)
returnMathf.Lerp(radA,radB,segmentLerp);
publicvoidFillBounds(floatboundLerpA,floatboundLerpB,refBounds2DboundsToFill)
if(shapeLerpA>boundLerpB&&(end?shapeLerpB<boundLerpA:shapeLerpB<=boundLerpA))
return;
floatmin=Mathf.InverseLerp(shapeLerpA,shapeLerpB,boundLerpA);
floatmax=Mathf.InverseLerp(shapeLerpA,shapeLerpB,boundLerpB);
boundsToFill=boundsToFill.Add(LerpPos(min)).Add(LerpPos(max));
for(inti=0;i<maximaCount;i++)
if(maximaLerps[i]>=min&&maximaLerps[i]<max)
boundsToFill=boundsToFill.Add(LerpPos(maximaLerps[i]));
publicintGetTesselation(floattesselation)
returnstraight?1:Mathf.Max(1,Mathf.CeilToInt(Mathf.Abs(arc.bend)*tesselation));
privatefloatToRadLerp(floatrad)
if(arc.bend<0)
rad+=Mathf.PI;
floatfull=radA+Mathf.Sign(arc.bend)*2*Mathf.PI;
floatrangeRad=Mth.Repeat(radA,full,rad);
returnMathf.InverseLerp(radA,full,rangeRad);
privateboolPointLerpInRange(Vector2point)
floatpointLerp=straight?line.GetClosestLerp(point):arc.GetClosestLerp(point);
returnpointLerp>=0&&pointLerp<=1;
publicintGetFacingChanges(boolclockwise,floattopRatio,floatbottomRatio,refFacingLerp[]points,refintdir,intindex)
floatmaxLerp=Mathf.Abs(arc.bend);
intstartDir=dir;
boolflip=arc.bend>0&&!clockwise||arc.bend<0&&clockwise;
floattR=flip?topRatio:bottomRatio;
floatbR=flip?bottomRatio:topRatio;
for(inti=0;i<4;i++)
intcheckDir=arc.bend>0?(startDir+1+i)%4:(startDir-i)%4;
constfloatFullRad=2*Mathf.PI;
floatradLerp;
switch(checkDir)
default:radLerp=ToRadLerp(.25f*(1f-tR)*FullRad);break;
case2:radLerp=ToRadLerp((.25f+.25f*tR)*FullRad);break;
case3:radLerp=ToRadLerp((.5f+.25f*(1f-bR))*FullRad);break;
case0:radLerp=ToRadLerp((.75f+.25f*bR)*FullRad);break;
if(radLerp<=maxLerp)
intnewDir=arc.bend>0?checkDir:(checkDir+1)%4;
if(clockwise)
newDir=(newDir+2)%4;
floatshapeLerp=Mathf.Lerp(shapeLerpA,shapeLerpB,radLerp/maxLerp);
if(index==0||shapeLerp>points[index-1].lerp)
points[index]=newFacingLerp(Mathf.Lerp(shapeLerpA,shapeLerpB,radLerp/maxLerp),newDir);
index++;
dir=newDir;
returnindex;
publicstructFacingLerp
publicreadonlyfloatlerp;
publicreadonlyintsideID;
publicFacingLerp(floatlerp,intsideID)
this.lerp=lerp;
this.sideID=sideID;
publicVector2GetClosestPoint(Vector2point)
returnstraight?line.ClosestPoint(point):arc.GetClosestPoint(point);
privateboolPointProjectionHit(Vector2point,outVector2rangePoint)
Vector2dir=point-arc.center;
if(PointLerpInRange(point))
rangePoint=arc.center+dir.SetLength(arc.radius);
returntrue;
if(PointLerpInRange(arc.center-dir))
rangePoint=arc.center-dir.SetLength(arc.radius);
returntrue;
rangePoint=point;
returnfalse;
publicboolOnInsideSide(Vector2point,boolclockwise)
if(PointLerpInRange(point))
if(straight)
floatradAngle=line.dir.RadAngle(point-line.l1);
if(Mathf.Approximately(radAngle,0))
returntrue;
returnclockwise?radAngle<0:radAngle>0;
else
floatpointSqrDist=(point-arc.center).sqrMagnitude;
floatradiusSqr=arc.radius*arc.radius;
if(Mathf.Approximately(pointSqrDist,radiusSqr))
returntrue;
boolisClose=pointSqrDist<radiusSqr;
boolneedsToBeClose=!clockwise&&arc.bend>0||clockwise&&arc.bend<0;
returnisClose==needsToBeClose;
returntrue;
publicboolOverlap(SegmentotherSegment,refVector2iPoint)
if(!bounds.Intersects(otherSegment.bounds))
returnfalse;
Vector2c1=arc.center,c2=otherSegment.arc.center;
floatr1=arc.radius,r2=otherSegment.arc.radius;
Vector2p1,p2;
inthits;
if(!newCircle(c1,r1).Contact(newCircle(c2,r2),outhits,outp1,outp2))
returnfalse;
if(PointLerpInRange(p1)&&otherSegment.PointLerpInRange(p1))//p1//
iPoint=p1;
returntrue;
if(hits==2&&PointLerpInRange(p2)&&otherSegment.PointLerpInRange(p2))//p2//
iPoint=p2;
returntrue;
returnfalse;
publicfloatDistanceSqr(SegmentotherSegment,floatclosestDist,refVector2pA,refVector2pB)
if(bounds.DistanceSqr(otherSegment.bounds)>closestDist)
returnfloat.MaxValue;
Vector2refVar=V2.zero;
if(Overlap(otherSegment,refrefVar))
return0;
floatx=pointA.x-otherSegment.pointA.x;
floaty=pointA.y-otherSegment.pointA.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=pointA;
pB=otherSegment.pointA;
floatx=pointA.x-otherSegment.pointB.x;
floaty=pointA.y-otherSegment.pointB.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=pointA;
pB=otherSegment.pointB;
floatx=pointB.x-otherSegment.pointA.x;
floaty=pointB.y-otherSegment.pointA.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=pointB;
pB=otherSegment.pointA;
floatx=pointB.x-otherSegment.pointB.x;
floaty=pointB.y-otherSegment.pointB.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=pointB;
pB=otherSegment.pointB;
Vector2rangePoint;
if(PointProjectionHit(otherSegment.pointA,outrangePoint))
floatx=otherSegment.pointA.x-rangePoint.x;
floaty=otherSegment.pointA.y-rangePoint.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=rangePoint;
pB=otherSegment.pointA;
if(PointProjectionHit(otherSegment.pointB,outrangePoint))
floatx=otherSegment.pointB.x-rangePoint.x;
floaty=otherSegment.pointB.y-rangePoint.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=rangePoint;
pB=otherSegment.pointB;
if(otherSegment.PointProjectionHit(pointA,outrangePoint))
floatx=pointA.x-rangePoint.x;
floaty=pointA.y-rangePoint.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=rangePoint;
pB=pointA;
if(otherSegment.PointProjectionHit(pointB,outrangePoint))
floatx=pointB.x-rangePoint.x;
floaty=pointB.y-rangePoint.y;
floatdist=x*x+y*y;
if(dist<closestDist)
closestDist=dist;
pA=rangePoint;
pB=pointB;
Vector2c1=arc.center;
Vector2c2=otherSegment.arc.center;
floatr1=arc.radius;
floatr2=otherSegment.arc.radius;
boolaFront=PointLerpInRange(c2);
boolaBack=PointLerpInRange(c1+(c1-c2));
boolbFront=otherSegment.PointLerpInRange(c1);
boolbBack=otherSegment.PointLerpInRange(c2+(c2-c1));
if(aFront&&bFront)
Vector2a=c1+(c2-c1).SetLength(r1);
Vector2b=c2+(c1-c2).SetLength(r2);
floatdist=(b-a).sqrMagnitude;
if(dist<closestDist)
closestDist=dist;
pA=a;
pB=b;
if(aFront&&bBack)
Vector2a=c1+(c2-c1).SetLength(r1);
Vector2b=c2+(c2-c1).SetLength(r2);
floatdist=(b-a).sqrMagnitude;
if(dist<closestDist)
closestDist=dist;
pA=a;
pB=b;
if(aBack&&bBack)
Vector2a=c1+(c1-c2).SetLength(r1);
Vector2b=c2+(c2-c1).SetLength(r2);
floatdist=(b-a).sqrMagnitude;
if(dist<closestDist)
closestDist=dist;
pA=a;
pB=b;
if(aBack&&bFront)
Vector2a=c1+(c1-c2).SetLength(r1);
Vector2b=c2+(c1-c2).SetLength(r2);
floatdist=(b-a).sqrMagnitude;
if(dist<closestDist)
closestDist=dist;
pA=a;
pB=b;
returnclosestDist;
publicboolRayCast(Vector2root,Vector2dir,outVector2hitPoint)
returnstraight?line.RayCast(root,dir,outhitPoint):
arc.RayCast(root,dir,outhitPoint);
publicvoidMaxShapeThickness(reffloatthickness)
if(!straight&&arc.radius<thickness)
thickness=arc.radius;
publicvoidDrawMaxima()
for(inti=0;i<maximaCount;i++)
DRAW.Circle(LerpPos(maximaLerps[i]),.03f,12).SetColor(COLOR.yellow.fresh).Fill(.1f);
publicvoidDrawLine()
return;
if(straight)
line.Draw().SetColor(Color.cyan);
else
arc.DrawShell(.2f).SetColor(Color.cyan);
publicvoidDrawShell(floatthickness)
if(straight)
Vector2right=line.dir.Rot90().SetLength(thickness*.5f);
line.Move(right).Draw().SetColor(COLOR.green.lime);
line.Move(-right).Draw().SetColor(COLOR.blue.cornflower);
else
arc.Shift(-thickness*.5f).Draw(100).SetColor(COLOR.green.lime);
arc.Shift(thickness*.5f).Draw(100).SetColor(COLOR.blue.cornflower);
publicclassShapeTest:MonoBehaviour
publicShapeshape;
privatereadonlyShapeLineDrawerlineDrawer=newShapeLineDrawer();
privatereadonlyShapeMeshermesher=newShapeMesher();
privateShapeFacingDrawerfacingDrawer;
publicCameraorthoCam;
[Range(.1f,1)]
publicfloatspeed;
privatefloattime;
privatereadonlyShapeshellShape=newShape();
privatereadonlyShapeLineDrawershellDrawer=newShapeLineDrawer(400);
privatereadonlyShapecollisionShape=newShape();
privatereadonlyShapeLineDrawercollisionDrawer=newShapeLineDrawer();
privatereadonlyShapecollisionShellShape=newShape();
privatereadonlyShapeLineDrawercollisionShellDrawer=newShapeLineDrawer(400);
privateVector2p1,p2;
[Space(10)]
publicEdgeMesheredgeMesher;
privateShape[]allShapes;
privateintshapePick,undos;
privateboolselfIntersecting;
privatevoidAwake()
allShapes=newShape[20];
for(inti=0;i<20;i++)
allShapes[i]=newShape();
facingDrawer=newShapeFacingDrawer();
privatevoidOnEnable()
NewShape(Random.Range(0,10));
privatevoidUpdate()
time+=Time.deltaTime*speed;
if(Input.GetKeyDown(KeyCode.Space))NewShape(Random.Range(0,10));
if(Input.GetKeyDown(KeyCode.Alpha0))NewShape(0);
if(Input.GetKeyDown(KeyCode.Alpha1))NewShape(1);
if(Input.GetKeyDown(KeyCode.Alpha2))NewShape(2);
if(Input.GetKeyDown(KeyCode.Alpha3))NewShape(3);
if(Input.GetKeyDown(KeyCode.Alpha4))NewShape(4);
if(Input.GetKeyDown(KeyCode.Alpha5))NewShape(5);
if(Input.GetKeyDown(KeyCode.Alpha6))NewShape(6);
if(Input.GetKeyDown(KeyCode.Alpha7))NewShape(7);
if(Input.GetKeyDown(KeyCode.Alpha8))NewShape(8);
if(Input.GetKeyDown(KeyCode.Alpha9))NewShape(9);
if(Input.GetKeyDown(KeyCode.Backspace))Undo();
floatrad=(Input.GetKey(KeyCode.Q)?1:0)+(Input.GetKey(KeyCode.Q)?-1:0);
if(!f.Same(rad,0))
shape.RotateAround(MousePoint,rad*Time.deltaTime);
UpdateShapeStuff(false);
drawLine.KeySwitch(KeyCode.L);
drawMesh.KeySwitch(KeyCode.M);
drawArrow.KeySwitch(KeyCode.A);
drawPoints.KeySwitch(KeyCode.P);
showCollision.KeySwitch(KeyCode.C);
drawIndicator.KeySwitch(KeyCode.I);
drawFacing.KeySwitch(KeyCode.F);
drawBounds.Set(Input.GetKeyDown(KeyCode.B)?(drawBounds+1)%3:drawBounds);
facingDrawer.UpdateRatios(shape);
floattipLerp=Mathf.Repeat(time/GTime.LoopTime,1);
if(drawBounds==1)
ShapeLineDrawer.DrawBounds(shape);
if(drawBounds==2)
lineDrawer.DrawFractions(tipLerp);
if(drawPoints)
ShapeLineDrawer.DrawPoints(shape);
if(drawLine&&!(drawFacing&&facingDrawer.Active&&shape.loop))
lineDrawer.DrawLine();
shellDrawer.DrawLine();
for(inti=0;i<shape.segmentCount;i++)
shape.segments[i].DrawLine();
floatthickness=Mathf.Min(10,shape.PossibleThickness)*Mth.SmoothPP(.1f,1,Time.realtimeSinceStartup);
for(inti=0;i<shape.segmentCount;i++)
shape.segments[i].DrawShell(thickness);
if(drawArrow)
lineDrawer.DrawArrows();
if(drawMesh)
mesher.DrawTriangles();
if(drawFacing)
facingDrawer.DrawFacings(shape);
facingDrawer.DrawStartDir(shape);
if(showCollision)
Vector2movement=newVector2((Input.GetKey(KeyCode.RightArrow)?1:0)+(Input.GetKey(KeyCode.LeftArrow)?-1:0),
(Input.GetKey(KeyCode.UpArrow)?1:0)+(Input.GetKey(KeyCode.DownArrow)?-1:0));
if(movement!=Vector2.zero)
collisionShape.Move(movement.normalized*Time.deltaTime*4);
boolintersection=collisionShape.Intersects(shape);
boolinside=!intersection&&shape.IsInside(collisionShape.segments[0].pointA);
collisionDrawer.SetShape(collisionShape,intersection?COLOR.green.spring:(inside?COLOR.yellow.golden:COLOR.turquois.bright.A(.2f)));
collisionShellShape.CreateExtrude(collisionShape);
collisionShellDrawer.SetShape(collisionShellShape,COLOR.grey.dark);
floatrad=(Input.GetKey(KeyCode.Z)?1:0)+(Input.GetKey(KeyCode.X)?-1:0);
if(!f.Same(rad,0))
collisionShape.RotateAround(MousePoint,rad*Time.deltaTime);
CheckCollision();
collisionDrawer.DrawLine();
ShapeLineDrawer.DrawPoints(collisionShape,true,collisionDrawer);
if(collisionShape.GetClosestDistance(shape,outp1,outp2)>0)
Vector2dir=p2-p1;
DRAW.TwoWayArrow(p1,dir,.1f).SetColor(Color.white).Fill(1);
DRAW.Circle(Vector2.Lerp(p1,p2,.5f),dir.magnitude*.5f,30).SetColor(Color.white.A(.2f));
if(drawIndicator&&OnScreen(Input.mousePosition))
Vector2mousePoint=MousePoint;
ColorpointColor=shape.IsInside(MousePoint)?Color.yellow:Color.cyan;
Vector2closestPoint=shape.GetClosestPoint(mousePoint);
floatdistance=Vector2.Distance(mousePoint,closestPoint);
constfloatmax=5;
if(distance<max)
floatlerp=1-distance/max;
DRAW.MultiCircle(closestPoint,.3f*lerp,3,.08f*lerp,16).SetColor(pointColor).Fill(.1f);
DRAW.Vector(mousePoint,closestPoint-mousePoint).SetColor(pointColor);
if(drawPoints)
ShapeLineDrawer.DrawCenters(shape);
if(selfIntersecting)
DRAW.Circle(shape.intersectionPoint,.05f,20).SetColor(COLOR.red.firebrick).Fill(1);
DRAW.GapVector(mousePoint,shape.intersectionPoint-mousePoint,20).SetColor(pointColor);
drawSnake.Set(Input.GetKeyDown(KeyCode.S)?(drawSnake+1)%3:drawSnake);
Colorgrey=newColor(.98f,.98f,.98f,1);
if(drawSnake==1)
floatlength=shape.length*.1f;
intsteps=Mathf.CeilToInt(length/.2f);
floatlerpStep=.1f/steps;
for(inti=0;i<steps;i++)
floatlerp=Mathf.Repeat(time/GTime.LoopTime-lerpStep*i,1);
DRAW.Circle(shape.GetPoint(lerp),.05f,20).SetColor(grey).Fill(1);
DRAW.Circle(shape.GetPoint(lerp,.08f),.02f,20).SetColor(COLOR.red.tomato).Fill(1);
DRAW.Circle(shape.GetPoint(lerp,-.08f),.02f,20).SetColor(COLOR.green.spring).Fill(1);
Vector2dir=shape.GetDir(tipLerp);
DRAW.Arrow(shape.GetPoint(tipLerp)+dir*.05f,dir*.2f,.05f).SetColor(COLOR.blue.deepsky).Fill(1);
if(drawSnake==0)
Vector2dir=V2.up.Rot(54);
Colorc=shape.loop?(shape.clockwise?COLOR.green.spring:COLOR.red.tomato):COLOR.blue.deepsky;
for(inti=0;i<8;i++)
floatlerp=Mathf.Repeat(time/GTime.LoopTime+.125f*i,1);
Vector2point=shape.GetPoint(lerp);
floatextend=shape.loop?1:(lerp<.5f?Mathf.SmoothStep(0,1,lerp*20)
:Mathf.SmoothStep(1,0,(lerp-.95f)*20));
DRAW.Circle(point+dir*.8f*extend,.05f,20).SetColor(c).Fill(1);
DRAW.Circle(point,.025f,20).SetColor(grey).Fill(1);
DRAW.Vector(shape.GetPoint(lerp),dir*.75f*extend).SetColor(grey);
privatevoidNewShape(intshapeNumber)
shapePick=(shapePick+1)%20;
shape=allShapes[shapePick];
undos=Mathf.Min(undos+1,20);
shape.CreateByNumber(shapeNumber);
UpdateShapeStuff(true);
privatevoidUpdateShapeStuff(boolnewShape)
lineDrawer.SetShape(shape,COLOR.red.tomato);
mesher.SetShape(shape);
facingDrawer.UpdateFacings(shape);
edgeMesher.SetShape(shape);
shellShape.CreateExtrude(shape);
shellDrawer.SetShape(shellShape,COLOR.grey.mid);
if(newShape)
selfIntersecting=shape.Intersects(shape);
SetOrthoCam();
collisionShape.CreateByNumber(Random.Range(0,10));
CheckCollision();
privatevoidCheckCollision()
boolintersection=collisionShape.Intersects(shape);
boolinside=!intersection&&shape.IsInside(collisionShape.segments[0].pointA);
collisionDrawer.SetShape(collisionShape,intersection?COLOR.green.spring:(inside?COLOR.yellow.golden:COLOR.turquois.bright.A(.2f)));
collisionShellShape.CreateExtrude(collisionShape);
collisionShellDrawer.SetShape(collisionShellShape,COLOR.grey.dark);
privatevoidUndo()
if(undos==0)
return;
undos--;
shapePick--;
if(shapePick<0)
shapePick=19;
shape=allShapes[shapePick];
UpdateShapeStuff(true);
privatevoidSetOrthoCam()
orthoCam.transform.parent.position=shape.bounds.Center;
orthoCam.orthographicSize=shape.bounds.Size.y*.5f+2;
privatestaticboolOnScreen(Vector2pos)
floatmargin=Screen.height/30f;
returnpos.x>margin&&pos.x<Screen.width-margin&&pos.y>margin&&pos.y<Screen.height-margin;
privatestaticreadonlyprefBool
drawLine=newprefBool("st_drawLine"),
drawMesh=newprefBool("st_drawMesh"),
drawPoints=newprefBool("st_drawPoints"),
drawArrow=newprefBool("st_drawArrow"),
showCollision=newprefBool("st_showCollision"),
drawIndicator=newprefBool("st_drawIndicator"),
drawFacing=newprefBool("st_drawFacing");
privatestaticreadonlyprefInt
drawBounds=newprefInt("st_drawBounds"),
drawSnake=newprefInt("st_drawSnake");
privateVector2MousePoint
get
Rayray=orthoCam.ScreenPointToRay(Input.mousePosition);
floatdist;
newPlane(Vector3.forward,Vector3.zero).Raycast(ray,outdist);
returnray.origin+ray.direction*dist;
publicstaticclassTriangulator
privatestaticreadonlyVertex[]vertexPool=Array(1000);
privatestaticreadonlyList<Vertex>shapePoints=newList<Vertex>(1000);
privatestaticreadonlyList<Vertex>earVertices=newList<Vertex>(1000);
publicstaticintpointCount;
publicstaticreadonlyVector3[]pnts=newVector3[1000];
publicstaticreadonlyList<int>triangles=newList<int>(1000);
publicstaticvoidFillShape(Shapeshape,floatoffset)
constinttesselation=8;
pointCount=shape.GetTesselation(tesselation);
offset*=shape.clockwise?1:-1;
intpointIndex=0;
for(inti=0;i<shape.segmentCount;i++)
intsIndex=shape.clockwise?shape.segmentCount-1-i:i;
Shape.Segmentsegment=shape.segments[sIndex];
intsegmentSteps=segment.GetTesselation(tesselation);
floatlerpStep=1f/segmentSteps;
for(inte=0;e<segmentSteps;e++)
floatsegmentLerp=shape.clockwise?1-lerpStep*e:lerpStep*e;
pnts[pointIndex++]=segment.LerpPos(segmentLerp,offset);
Fill(pnts,pointCount);
publicstaticvoidFill(Vector3[]points,intpointCount,boolreverse=false)
shapePoints.Clear();
for(inti=0;i<pointCount;i++)
shapePoints.Add(vertexPool[i].SetPoint(points[reverse?pointCount-1-i:i],i));
for(inti=0;i<pointCount;i++)
intnextPos=(i+1)%pointCount;
intprevPos=(i-1).Repeat(pointCount);
shapePoints[i].prev=shapePoints[prevPos];
shapePoints[i].next=shapePoints[nextPos];
for(inti=0;i<shapePoints.Count;i++)
shapePoints[i].CheckIfReflex();
earVertices.Clear();
for(inti=0;i<shapePoints.Count;i++)
IsVertexEar(shapePoints[i]);
triangles.Clear();
while(true)
if(shapePoints.Count==3)
triangles.Add(shapePoints[2].index);
triangles.Add(shapePoints[1].index);
triangles.Add(shapePoints[0].index);
break;
if(earVertices.Count==0)
break;
VertexearVertex=earVertices[0];
VertexearVertexPrev=earVertex.prev;
VertexearVertexNext=earVertex.next;
triangles.Add(earVertex.index);
triangles.Add(earVertexPrev.index);
triangles.Add(earVertexNext.index);
earVertices.Remove(earVertex);
shapePoints.Remove(earVertex);
earVertexPrev.next=earVertexNext;
earVertexNext.prev=earVertexPrev;
earVertexPrev.CheckIfReflex();
earVertexNext.CheckIfReflex();
earVertices.Remove(earVertexPrev);
earVertices.Remove(earVertexNext);
IsVertexEar(earVertexPrev);
IsVertexEar(earVertexNext);
/*privatestaticvoidCheckIfReflexOrConvex(Vertexvertex)
vertex.isReflex=IsTriangleOrientedClockwise(vertex.prev.pos,vertex.pos,vertex.next.pos);
privatestaticvoidIsVertexEar(Vertexvertex)
if(vertex.isReflex)
return;
Vector2a=vertex.prev.pos;
Vector2b=vertex.pos;
Vector2c=vertex.next.pos;
boolhasPointInside=false;
intcount=shapePoints.Count;
for(inti=0;i<count;i++)
if(shapePoints[i].isReflex&&IsPointInTriangle(a,b,c,shapePoints[i].pos))
hasPointInside=true;
break;
if(!hasPointInside)
earVertices.Add(vertex);
publicclassVertex
publicintindex;
publicVector2pos;
publicVertexprev,next;
publicboolisReflex;
publicVertexSetPoint(Vector2pos,intindex)
this.pos=pos;
this.index=index;
returnthis;
publicvoidCheckIfReflex()
isReflex=IsTriangleOrientedClockwise(prev.pos,pos,next.pos);
privatestaticboolIsTriangleOrientedClockwise(Vector2p1,Vector2p2,Vector2p3)
return0>=p1.x*p2.y+p3.x*p1.y+p2.x*p3.y-p1.x*p3.y-p3.x*p2.y-p2.x*p1.y;
privatestaticboolIsPointInTriangle(Vector2p1,Vector2p2,Vector2p3,Vector2p)
floatdenominator=((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));
floata=((p2.y-p3.y)*(p.x-p3.x)+(p3.x-p2.x)*(p.y-p3.y))/denominator;
floatb=((p3.y-p1.y)*(p.x-p3.x)+(p1.x-p3.x)*(p.y-p3.y))/denominator;
floatc=1-a-b;
returna>0f&&a<1f&&b>0f&&b<1f&&c>0f&&c<1f;
privatestaticVertex[]Array(intcount)
Vertex[]array=newVertex[count];
for(inti=0;i<count;i++)
array[i]=newVertex();
returnarray;
[System.Serializable]
publicclassEdgeMesh:ScriptableObject
publicfloatheight=1;
[SerializeField]privateVector3[]baseVertices,baseNormals;
[HideInInspector]publicint[]triangles;
[HideInInspector]publicbyte[]colorPick;
[HideInInspector]publicVector3[]morphVertices,morphNormals;
[HideInInspector]publicLerpIndexes[]lerpIndexes;
publicvoidSetMesh(Meshmesh)
baseVertices=mesh.vertices;
baseNormals=mesh.normals;
triangles=mesh.triangles;
morphVertices=newVector3[baseVertices.Length];
morphNormals=newVector3[baseNormals.Length];
Quaternionrot=Rot.Y(180);
for(inti=0;i<baseVertices.Length;i++)
baseVertices[i]=rot*baseVertices[i];
baseNormals[i]=rot*baseNormals[i];
for(inti=0;i<baseVertices.Length;i++)
if(f.Same(baseVertices[i].y,0)||f.Same(baseVertices[i].y,1))
baseNormals[i]=Vector3.ProjectOnPlane(baseNormals[i],V3.up).normalized;
colorPick=newbyte[mesh.vertices.Length];
for(inti=0;i<baseVertices.Length;i++)
colorPick[i]=(byte)(baseVertices[i].z<.001f?1:0);
List<LerpIndexesList>lerpIndexesList=newList<LerpIndexesList>();
for(inti=0;i<baseVertices.Length;i++)
floatlerp=baseVertices[i].y;
booladdedIndex=false;
for(inte=0;e<lerpIndexesList.Count;e++)
if(f.Same(lerpIndexesList[e].lerp,lerp))
lerpIndexesList[e].indexes.Add(i);
addedIndex=true;
if(!addedIndex)
lerpIndexesList.Add(newLerpIndexesList(lerp,i));
lerpIndexes=newLerpIndexes[lerpIndexesList.Count];
for(inti=0;i<lerpIndexes.Length;i++)
lerpIndexes[i]=newLerpIndexes(lerpIndexesList[i]);
publicvoidMorphEdge(Shapeshape,floatstartLerp,floatlerpStep,floatwidthMulti,floatyFactor)
intlerpCount=lerpIndexes.Length;
for(inte=0;e<lerpCount;e++)
floatshapeLerp=Mathf.Repeat(startLerp+lerpStep*lerpIndexes[e].lerp,1);
intsegmentIndex=shape.GetSegmentIndex(shapeLerp);
floatsegmentLerp=shape.GetSegmentLerp(segmentIndex,shapeLerp);
Vector3point=shape.segments[segmentIndex].LerpPos(segmentLerp);
floatrad=shape.segments[segmentIndex].LerpRad(segmentLerp);
Quaternionrot=Rot.Z(rad*Mathf.Rad2Deg);
intvertCount=lerpIndexes[e].indexes.Length;
for(intf=0;f<vertCount;f++)
intindex=lerpIndexes[e].indexes[f];
morphVertices[index]=point+rot*newVector3(baseVertices[index].x*widthMulti,0,baseVertices[index].z);
morphNormals[index]=rot*newVector3(baseNormals[index].x*widthMulti,baseNormals[index].y*yFactor,baseNormals[index].z);
publicclassLerpIndexesList
publicreadonlyfloatlerp;
publicreadonlyList<int>indexes=newList<int>();
publicLerpIndexesList(floatlerp,intfirstIndex)
this.lerp=lerp;
indexes.Add(firstIndex);
[System.Serializable]
publicclassLerpIndexes
publicfloatlerp;
publicint[]indexes;
publicLerpIndexes(LerpIndexesListlerpIndexesList)
lerp=lerpIndexesList.lerp;
indexes=lerpIndexesList.indexes.ToArray();
publicclassEdgeMesher:MonoBehaviour
publicShapeMeshSetshapeMeshSet;
publicEdgeMeshtopMesh;
publicEdgeMeshsideMesh;
publicEdgeMeshbottomMesh;
[Space(10)]
publicfloatlengthMulti;
publicfloatwidthMulti;
[Space(10)]
publicMeshFiltermeshFilter;
publicMeshRenderermeshRenderer;
privateMeshmesh;
privatereadonlyList<Vector3>vertices=newList<Vector3>(5000);
privatereadonlyList<Vector3>normals=newList<Vector3>(5000);
privatereadonlyList<Color32>colors=newList<Color32>(5000);
privatereadonlyList<int>triangles=newList<int>(15000);
privateShape.Segment.FacingLerp[]facings=newShape.Segment.FacingLerp[200];
privateintfacingCount;
privatefloattopRatio=.5f;
privatefloatbottomRatio=.5f;
privateShapeshape;
privatefloatlM,wM,fO;
privateboolfill;
privatevoidAwake()
mesh=newMesh();
meshFilter.mesh=mesh;
lM=lengthMulti;
wM=widthMulti;
fO=shapeMeshSet.fillOffset;
fill=shapeMeshSet.fill;
publicvoidUpdate()
boolinput=false;
if(Input.GetKey(KeyCode.Alpha1))
topRatio=Mathf.Clamp(topRatio-Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha3))
topRatio=Mathf.Clamp(topRatio+Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha4))
bottomRatio=Mathf.Clamp(bottomRatio-Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha6))
bottomRatio=Mathf.Clamp(bottomRatio+Time.deltaTime*.5f,.001f,.999f);
input=true;
if(Input.GetKey(KeyCode.Alpha2))
topRatio=.5f;
input=true;
if(Input.GetKey(KeyCode.Alpha5))
bottomRatio=.5f;
input=true;
if(Input.GetKeyDown(KeyCode.R))
shapeMeshSet.NewSeed();
input=true;
if(input&&shape!=null)
SetShape(shape);
return;
if(!f.Same(lM,lengthMulti)||!f.Same(wM,widthMulti)||!f.Same(fO,shapeMeshSet.fillOffset)||fill!=shapeMeshSet.fill)
lM=lengthMulti;
wM=widthMulti;
fO=shapeMeshSet.fillOffset;
fill=shapeMeshSet.fill;
SetShape(shape);
publicvoidSetShape(Shapeshape)
if(!gameObject.activeInHierarchy)
return;
if(!shape.loop||shape.Intersects(shape))
if(meshRenderer.enabled)
meshRenderer.enabled=false;
return;
if(!meshRenderer.enabled)
meshRenderer.enabled=true;
this.shape=shape;
vertices.Clear();
normals.Clear();
colors.Clear();
triangles.Clear();
mesh.SetTriangles(triangles,0);
intvIndex=0;
if(fill)
Profiler.BeginSample("EdgeMesher-Fill");
Triangulator.FillShape(shape,shapeMeshSet.fillOffset*widthMulti);
vIndex=Triangulator.pointCount;
for(inti=0;i<vIndex;i++)
colors.Add(newColor32(1,0,0,0));
vertices.Add(Triangulator.pnts[i]);
normals.Add(Vector3.back);
intfillTriangleCount=Triangulator.triangles.Count;
for(inti=0;i<fillTriangleCount;i++)
triangles.Add(Triangulator.triangles[i]);
Profiler.EndSample();
Profiler.BeginSample("EdgeMesher-Edge");
facingCount=shape.GetFacingDirections(topRatio,bottomRatio,reffacings);
floatshapeLength=shape.length;
floatxSign=shape.clockwise?-1:1;
EdgeMeshgapBefore=shapeMeshSet.GetBridge(facingCount-1);
for(inti=0;i<facingCount;i++)
EdgeMeshgapNext=shapeMeshSet.GetBridge(facingCount-1);
floatgapLerpA=gapBefore.height*.5f/shapeLength;
floatgapLerpB=gapNext.height*.5f/shapeLength;
floatsideLerpLength=(i==facingCount-1?facings[0].lerp+1:facings[i+1].lerp)-facings[i].lerp-gapLerpA*.5f-gapLerpB*.5f;
floatsideLength=shapeLength*sideLerpLength;
intsteps=Mathf.Max(1,Mathf.RoundToInt(sideLength/lengthMulti));
floatyFactor=Mathf.Clamp01(1f/(sideLength/steps));
floatlerpStep=sideLerpLength/steps;
for(ints=0;s<steps;s++)
EdgeMeshedge=shapeMeshSet.GetEdge(facings[i].sideID,i,s);
edge.MorphEdge(shape,facings[i].lerp+gapLerpA*.5f+lerpStep*s,lerpStep,widthMulti*xSign,yFactor);
for(inte=0;e<edge.morphVertices.Length;e++)
vertices.Add(edge.morphVertices[e]);
normals.Add(edge.morphNormals[e]);
colors.Add(newColor32(edge.colorPick[e],0,0,0));
if(!shape.clockwise)
for(inte=0;e<edge.triangles.Length;e++)
triangles.Add(edge.triangles[e]+vIndex);
else
for(inte=0;e<edge.triangles.Length;e+=3)
triangles.Add(edge.triangles[e+2]+vIndex);
triangles.Add(edge.triangles[e+1]+vIndex);
triangles.Add(edge.triangles[e]+vIndex);
vIndex+=edge.morphVertices.Length;
gapNext.MorphEdge(shape,facings[i].lerp+gapLerpA*.5f+sideLerpLength,gapLerpB*(1f/gapNext.height),widthMulti*xSign,1);
for(inte=0;e<gapNext.morphVertices.Length;e++)
vertices.Add(gapNext.morphVertices[e]);
normals.Add(gapNext.morphNormals[e]);
colors.Add(newColor32(gapNext.colorPick[e],0,0,0));
if(!shape.clockwise)
for(inte=0;e<gapNext.triangles.Length;e++)
triangles.Add(gapNext.triangles[e]+vIndex);
else
for(inte=0;e<gapNext.triangles.Length;e+=3)
triangles.Add(gapNext.triangles[e+2]+vIndex);
triangles.Add(gapNext.triangles[e+1]+vIndex);
triangles.Add(gapNext.triangles[e]+vIndex);
vIndex+=gapNext.morphVertices.Length;
gapBefore=gapNext;
Profiler.EndSample();
Profiler.BeginSample("EdgeMesher-Mesh");
mesh.SetVertices(vertices);
mesh.SetNormals(normals);
mesh.SetColors(colors);
mesh.SetTriangles(triangles,0);
mesh.RecalculateBounds();
Profiler.EndSample();
publicstaticclassEdgeMeshCreation
[MenuItem("Assets/CreateEdge",false,-1000)]
privatestaticvoidCreateEdge()
for(inti=0;i<Selection.objects.Length;i++)
stringfbxPath=AssetDatabase.GetAssetPath(Selection.objects[i]);
Meshmesh=null;
Object[]assetObjects=AssetDatabase.LoadAllAssetsAtPath(fbxPath);
for(inte=0;e<assetObjects.Length;e++)
if(assetObjects[e]isMesh)
mesh=(Mesh)assetObjects[e];
break;
if(mesh==null)
return;
stringname=Selection.objects[i].name;
stringedgePath=fbxPath.Replace("Meshes/"+name+".fbx","Edges/"+name+".asset");
EdgeMeshedgeMesh=AssetDatabase.LoadAssetAtPath(edgePath,typeof(EdgeMesh))asEdgeMesh;
if(!edgeMesh)
edgeMesh=ScriptableObject.CreateInstance<EdgeMesh>();
AssetDatabase.CreateAsset(edgeMesh,edgePath);
Debug.LogFormat("Creating:\"{0}\"",edgePath);
edgeMesh.SetMesh(mesh);
EditorUtility.SetDirty(edgeMesh);
AssetDatabase.SaveAssets();
[MenuItem("Assets/CreateEdge",true)]
privatestaticboolValidateCreateEdge()
if(Selection.objects==null||Selection.objects.Length==0)
returnfalse;
for(inti=0;i<Selection.objects.Length;i++)
if(!AssetDatabase.GetAssetPath(Selection.objects[i]).Contains(".fbx"))
returnfalse;
returntrue;
publicclassShowVersion:MonoBehaviour
[Switch("Dev/ShowAds")]privatestaticboolshowAds;
[Switch("Dev/ShowLogin")]privatestaticboolshowLogin;
privateTexttext;
privatevoidStart()
text=GetComponent<Text>();
StartCoroutine(ShowTheVersion());
privateIEnumeratorShowTheVersion()
text.text=Application.version;
floatt=0;
while(t<1)
t+=Time.deltaTime*3;
text.color=newColor(1,1,1,Mathf.SmoothStep(0,1,t));
yieldreturnnull;
t=0;
while(t<1)
t+=Time.deltaTime;
yieldreturnnull;
t=0;
while(t<1)
t+=Time.deltaTime*3;
text.color=newColor(1,1,1,Mathf.SmoothStep(1,0,t));
yieldreturnnull;
if(showAds)
/*#if!UNITY_STANDALONE
while(!Advertisement.IsReady("rewardedVideo"))
yieldreturnnull;
Advertisement.Show("rewardedVideo",newShowOptions{resultCallback=HandleShowResult});
else
SceneManager.LoadScene(showLogin?2:1);
publicclassDrawMeshesTest:MonoBehaviour
[Serializable]
publicclassCollectedMeshes
publicstaticMaterialmat;
privatestaticintindexAdd;
publicelementTypetype;
publicMesh[]meshes;
publicVector3[]offsets;
publicintinstCount;
privatereadonlyVector3[]positions;
publicCollectedMeshes(elementTypetype,Mesh[]meshes,Vector3[]offsets,intinstCount,intstartIndex)
this.type=type;
this.meshes=meshes;
this.instCount=instCount;
this.offsets=offsets;
positions=newVector3[instCount];
for(inti=0;i<instCount;i++)
floatindex=i+startIndex;
inty=Mathf.FloorToInt(index/40);
intx=(i+startIndex)%40;
positions[i]=newVector3(x*3,y*3,0);
publicvoidDraw()
for(inti=0;i<meshes.Length;i++)
Meshmesh=meshes[i];
Vector3offset=offsets[i];
for(inte=0;e<instCount;e++)
Graphics.DrawMesh(mesh,positions[e]+offset,Quaternion.identity,mat,0,null,0,null,false,false,false);
publicMaterialmat;
publicCollectedMeshes[]collectedMeshes;
privatevoidStart()
List<CollectedMeshes>collected=newList<CollectedMeshes>();
intstartIndex=0;
foreach(elementTypeelementTinEnum.GetValues(typeof(elementType)))
if(elementT.InstanceCount()>0)
GameObjectprefab=Resources.Load("Level/Items/"+elementT)asGameObject;
if(prefab==null)
continue;
Transformmain=prefab.transform;
List<Mesh>meshes=newList<Mesh>();
List<Vector3>offsets=newList<Vector3>();
MeshFilter[]meshFilters=prefab.transform.GetComponentsInChildren<MeshFilter>();
for(inti=0;i<meshFilters.Length;i++)
meshes.Add(meshFilters[i].sharedMesh);
offsets.Add(main.InverseTransformPoint(meshFilters[i].transform.position));
collected.Add(newCollectedMeshes(elementT,meshes.ToArray(),offsets.ToArray(),elementT.InstanceCount(),startIndex));
startIndex+=elementT.InstanceCount();
collectedMeshes=collected.ToArray();
CollectedMeshes.mat=mat;
privatevoidUpdate()
for(inti=0;i<collectedMeshes.Length;i++)
collectedMeshes[i].Draw();
publicclassSkinnedMeshItems:MonoBehaviour
[Serializable]
publicclassCollectedMeshes
publicelementTypetype;
publicMesh[]meshes;
publicVector3[]offsets;
publicintinstCount;
publicCollectedMeshes(elementTypetype,Mesh[]meshes,Vector3[]offsets,intinstCount)
this.type=type;
this.meshes=meshes;
this.instCount=instCount;
publicCollectedMeshes[]collectedMeshes;
publicintboneCount;
publicTransform[]bones;
publicMeshFilterfilter;
privatevoidStart()
List<CollectedMeshes>collected=newList<CollectedMeshes>();
foreach(elementTypeelementTinEnum.GetValues(typeof(elementType)))
if(elementT.InstanceCount()>0)
GameObjectprefab=Resources.Load("Level/Items/"+elementT)asGameObject;
if(prefab==null)
continue;
List<Mesh>meshes=newList<Mesh>();
List<Vector3>offsets=newList<Vector3>();
MeshFilter[]meshFilters=prefab.transform.GetComponentsInChildren<MeshFilter>();
for(inti=0;i<meshFilters.Length;i++)
if(meshFilters[i].sharedMesh.name.Contains("Star"))
continue;
meshes.Add(meshFilters[i].sharedMesh);
offsets.Add(meshFilters[i].transform.localPosition);
collected.Add(newCollectedMeshes(elementT,meshes.ToArray(),offsets.ToArray(),elementT.InstanceCount()));
collectedMeshes=collected.ToArray();
boneCount=0;
for(inti=0;i<collectedMeshes.Length;i++)
boneCount+=collectedMeshes[i].instCount*collectedMeshes[i].meshes.Length;
introws=Mathf.FloorToInt(Mathf.Sqrt(boneCount/16f*9));
introwLength=Mathf.CeilToInt((float)boneCount/rows)-1;
bones=newTransform[boneCount];
for(inti=0;i<boneCount;i++)
GameObjectbone=newGameObject("Bone"+i.ToString("D4"));
bone.transform.SetParent(transform,false);
bones[i]=bone.transform;
intboneIndex=0;
inttriOffset=0;
List<Vector3>verts=newList<Vector3>();
List<Vector3>norms=newList<Vector3>();
List<Color>cols=newList<Color>();
List<int>tris=newList<int>();
List<int>boneRef=newList<int>();
for(inti=0;i<collectedMeshes.Length;i++)
CollectedMeshescollection=collectedMeshes[i];
for(inte=0;e<collection.meshes.Length;e++)
Meshmesh=collection.meshes[e];
Vector3[]vertices=mesh.vertices;
Vector3[]normals=mesh.normals;
Color[]colors=mesh.colors;
int[]triangles=mesh.triangles;
intvertCount=vertices.Length;
for(intf=0;f<collection.instCount;f++)
for(intj=0;j<vertCount;j++)
verts.Add(vertices[j]);
norms.Add(normals[j]);
cols.Add(colors[j]);
boneRef.Add(boneIndex);
for(intj=0;j<triangles.Length;j++)
tris.Add(triangles[j]+triOffset);
triOffset+=vertCount;
boneIndex++;
MeshfinalMesh=newMesh();
SkinnedMeshRenderermR=GetComponent<SkinnedMeshRenderer>();
mR.sharedMesh=finalMesh;
mR.bones=bones;
mR.rootBone=transform;
finalMesh.SetVertices(verts);
finalMesh.SetTriangles(tris,0);
finalMesh.SetNormals(norms);
finalMesh.SetColors(cols);
finalMesh.bounds=newBounds(Vector3.zero,Vector3.one*10000);
Matrix4x4matrix=Matrix4x4.TRS(Vector3.zero,Quaternion.identity,Vector3.one);
Matrix4x4[]bindPoses=newMatrix4x4[boneCount];
for(inti=0;i<boneCount;i++)
bindPoses[i]=matrix;
inttotalVerticeCount=verts.Count;
BoneWeight[]boneWeights=newBoneWeight[totalVerticeCount];
for(inti=0;i<totalVerticeCount;i++)
boneWeights[i].boneIndex0=boneRef[i];
boneWeights[i].weight0=1;
finalMesh.bindposes=bindPoses;
finalMesh.boneWeights=boneWeights;
for(inti=0;i<bones.Length;i++)
inty=Mathf.FloorToInt((float)i/rowLength);
intx=i%rowLength;
bones[i].transform.localPosition=newVector3(x*3,y*3,0);
filter.mesh=finalMesh;
publicclassSmoothBind:MonoBehaviour
publicMeshmesh;
publicMaterialmat;
publicfloatscale=1;
publicfloatamount=20;
[Space(10)]
publicintboneCount=8;
[Range(0,1)]
publicfloatsquashAmount=.5f;
[Range(-90,90)]
publicfloatbendAmount;
[Space(10)]
publicboolautoRig=true;
privateTransform[]bones;
privatereadonlyList<Vector3>vertices=newList<Vector3>(ushort.MaxValue);
privatevoidOnEnable()
if(autoRig)
RigIt();
publicvoidRigIt()
Rig();
TestSetup();
privatevoidRig()
floatmin=mesh.bounds.min.y;
floatmax=mesh.bounds.max.y;
floatfraction=mesh.bounds.size.y/(boneCount-1);
Vector3bottom=mesh.bounds.center-Vector3.up*mesh.bounds.size.y*.5f;
bones=newTransform[boneCount];
for(inti=0;i<boneCount;i++)
bones[i]=newGameObject().transform;
bones[i].SetParent(transform,false);
bones[i].localPosition=bottom+newVector3(0,fraction*i,0);
SkinnedMeshRendererskinnedMeshRenderer=gameObject.AddComponent<SkinnedMeshRenderer>();
skinnedMeshRenderer.sharedMesh=mesh;
skinnedMeshRenderer.bones=bones;
skinnedMeshRenderer.material=mat;
skinnedMeshRenderer.quality=SkinQuality.Bone2;
skinnedMeshRenderer.Simplify(false);
Matrix4x4[]bindPoses=newMatrix4x4[boneCount];
for(inti=0;i<boneCount;i++)
bindPoses[i]=Matrix4x4.Translate(transform.position-bones[i].position);
mesh.GetVertices(vertices);
intverticeCount=vertices.Count;
BoneWeight[]boneWeights=newBoneWeight[verticeCount];
for(inti=0;i<verticeCount;i++)
floatlerp=Mathf.InverseLerp(min,max,vertices[i].y)*(boneCount-1);
intminIndex=Mathf.FloorToInt(lerp);
intmaxIndex=Mathf.CeilToInt(lerp);
if(minIndex==maxIndex)
boneWeights[i].boneIndex0=minIndex;
boneWeights[i].weight0=1;
continue;
floatboneAHeight=min+minIndex*fraction;
floatboneBHeight=min+maxIndex*fraction;
floatboneLerp=Mathf.InverseLerp(boneAHeight,boneBHeight,vertices[i].y);
boolfirstIsCloser=boneLerp<.5f;
boneWeights[i].boneIndex0=firstIsCloser?minIndex:maxIndex;
boneWeights[i].weight0=firstIsCloser?1-boneLerp:boneLerp;
boneWeights[i].boneIndex1=firstIsCloser?maxIndex:minIndex;
boneWeights[i].weight1=firstIsCloser?boneLerp:1-boneLerp;
mesh.bindposes=bindPoses;
mesh.boneWeights=boneWeights;
mesh.MarkDynamic();
privatevoidUpdate()
if(mesh==null)
return;
for(inti=0;i<boneCount;i++)
pos[i]=Vector3.zero;
rot[i]=Rot.Zero;
scaling[i]=Vector3.one;
Squash();
Turn();
Twist();
Bend();
for(inti=0;i<boneCount;i++)
bones[i].localPosition=pos[i];
bones[i].localRotation=rot[i];
bones[i].localScale=scaling[i].ZeroDamp();
privatevoidTurn()
for(inti=0;i<boneCount;i++)
rot[i]=Quaternion.Euler(0,(Time.realtimeSinceStartup+offset*20)*-80,0)*rot[i];
privatevoidTwist()
floatspin=Mathf.Sin(offset+Time.realtimeSinceStartup*2)*amount;
constfloatantiScale=1f/360*-.7f;
Vector3twist=newVector3(Mathf.Abs(spin)*antiScale,0,Mathf.Abs(spin)*antiScale);
for(inti=0;i<boneCount;i++)
rot[i]=Quaternion.Euler(0,spin*i/(boneCount-1f),0)*rot[i];
floatlerp=-1+i/(boneCount-1f)*2;
floatscaleLerp=Mathf.Pow(Mathf.Cos(Mathf.PI*lerp/2),2.5f).NaNChk();
scaling[i]+=Vector3.Lerp(V3.zero,twist,scaleLerp);
privatevoidSquash()
floatsquash=Mathf.Sin(offset+Time.realtimeSinceStartup*4)*squashAmount+1;
Vector3scaleFactor=size.GetFactors(size.VolumeScaleY(squash));
floatpow=Mathf.SmoothStep(Mathf.PI*.5f,1,Mathf.Abs(squash-1)*.5f);
Vector3powFactor=scaleFactor.Pow(pow).SetY(1)-Vector3.one;
for(inti=0;i<boneCount;i++)
Vector3dir=bindPos[i]-bindPos[0];
pos[i]=bindPos[0]+newVector3(dir.x,dir.y*squash,dir.z);
floatlerp=-1+i/(boneCount-1f)*2;
floatscaleLerp=Mathf.Pow(Mathf.Cos(Mathf.PI*lerp/2),.5f).NaNChk();
scaling[i]+=Vector3.Lerp(V3.zero,powFactor,scaleLerp);
privatevoidBend()
floatbendFraction=bendAmount/(boneCount-1);
Vector3lastPos=pos[0];
Vector3unaltered=pos[0];
for(inti=0;i<boneCount;i++)
Vector3dir=pos[i]-unaltered;
QuaternionbendRot=Quaternion.AngleAxis(bendFraction*i,Rot.Y((Time.realtimeSinceStartup+offset)*36)*Vector3.forward);
unaltered=pos[i];
pos[i]=lastPos+bendRot*dir;
lastPos=pos[i];
rot[i]=bendRot*rot[i];
privatefloatoffset;
privateVector3[]bindPos;
privateVector3size;
privateVector3[]pos;
privateQuaternion[]rot;
privateVector3[]scaling;
privatevoidTestSetup()
offset=Random.Range(-.4f,.4f);
transform.localScale=V3.one*scale;
Vector3bottom=transform.TransformPoint(mesh.bounds.center-Vector3.up*mesh.bounds.size.y*.5f);
transform.position+=transform.position-bottom;
bindPos=newVector3[boneCount];
for(inti=0;i<boneCount;i++)
bindPos[i]=bones[i].localPosition;
pos=newVector3[boneCount];
rot=newQuaternion[boneCount];
scaling=newVector3[boneCount];
size=mesh.bounds.size;
publicclassSmoothBindBounce:MonoBehaviour
publicMeshmesh;
publicMaterialmat;
publicfloatscale=1;
publicfloatcollRot;
[Space(10)]
publicintboneCount=8;
privateTransform[]bones;
privatereadonlyList<Vector3>vertices=newList<Vector3>(ushort.MaxValue);
privatefloatsquash=1;
privateBoxCollidercoll;
privateSkinnedMeshRendererskinnedMeshRenderer;
privatereadonlyList<float>shakeTimes=newList<float>(100);
privateVector3size;
privateVector3[]bindPos,pos,scaling;
publicTransform[]testSpheres;
privateVector3[]testSpherePos;
privatevoidOnEnable()
coll=GetComponent<BoxCollider>();
Rig();
TestSetup();
testSpherePos=newVector3[testSpheres.Length];
for(inti=0;i<testSpherePos.Length;i++)
testSpherePos[i]=testSpheres[i].localPosition;
privatevoidRig()
floatmin=mesh.bounds.min.y;
floatmax=mesh.bounds.max.y;
floatstep=mesh.bounds.size.y/(boneCount-1);
Vector3bottom=mesh.bounds.center-Vector3.up*mesh.bounds.size.y*.5f;
bones=newTransform[boneCount];
for(inti=0;i<boneCount;i++)
bones[i]=newGameObject().transform;
bones[i].SetParent(transform,false);
bones[i].localPosition=bottom+newVector3(0,step*i,0);
skinnedMeshRenderer=gameObject.AddComponent<SkinnedMeshRenderer>();
skinnedMeshRenderer.sharedMesh=mesh;
skinnedMeshRenderer.bones=bones;
skinnedMeshRenderer.material=mat;
skinnedMeshRenderer.quality=SkinQuality.Bone2;
skinnedMeshRenderer.Simplify(false);
Matrix4x4[]bindPoses=newMatrix4x4[boneCount];
for(inti=0;i<boneCount;i++)
bindPoses[i]=Matrix4x4.Translate(transform.position-bones[i].position);
mesh.GetVertices(vertices);
intverticeCount=vertices.Count;
BoneWeight[]boneWeights=newBoneWeight[verticeCount];
for(inti=0;i<verticeCount;i++)
floatlerp=Mathf.InverseLerp(min,max,vertices[i].y)*(boneCount-1);
intminIndex=Mathf.FloorToInt(lerp);
intmaxIndex=Mathf.CeilToInt(lerp);
if(minIndex==maxIndex)
boneWeights[i].boneIndex0=minIndex;
boneWeights[i].weight0=1;
continue;
floatboneAHeight=min+minIndex*step;
floatboneBHeight=min+maxIndex*step;
floatboneLerp=Mathf.InverseLerp(boneAHeight,boneBHeight,vertices[i].y);
boolfirstIsCloser=boneLerp<.5f;
boneWeights[i].boneIndex0=firstIsCloser?minIndex:maxIndex;
boneWeights[i].weight0=firstIsCloser?1-boneLerp:boneLerp;
boneWeights[i].boneIndex1=firstIsCloser?maxIndex:minIndex;
boneWeights[i].weight1=firstIsCloser?boneLerp:1-boneLerp;
mesh.bindposes=bindPoses;
mesh.boneWeights=boneWeights;
mesh.MarkDynamic();
privatevoidTestSetup()
transform.localScale=V3.one*scale;
Vector3bottom=transform.TransformPoint(mesh.bounds.center-Vector3.up*mesh.bounds.size.y*.5f);
transform.position+=transform.position-bottom;
bindPos=newVector3[boneCount];
for(inti=0;i<boneCount;i++)
bindPos[i]=bones[i].localPosition;
pos=newVector3[boneCount];
scaling=newVector3[boneCount];
size=mesh.bounds.size;
privatevoidUpdate()
if(mesh==null)
return;
Squash();
for(inti=0;i<boneCount;i++)
bones[i].localPosition=pos[i];
bones[i].localScale=scaling[i].ZeroDamp();
coll.center=skinnedMeshRenderer.localBounds.center/scale;
coll.size=Rot.Y(collRot)*(skinnedMeshRenderer.bounds.size/scale);
privatevoidSquash()
squash=UpdateSquash();
Vector3scaleFactor=size.GetFactors(size.VolumeScaleY(squash));
Vector3powFactor=scaleFactor.Pow(Mathf.PI*.75f).SetY(1)-Vector3.one;
for(inti=0;i<boneCount;i++)
floatlerp=-1+i/(boneCount-1f)*2;
floatscaleLerp=Mathf.Pow(Mathf.Cos(Mathf.PI*lerp/2),.5f).NaNChk();
Vector3dir=bindPos[i]-bindPos[0];
pos[i]=bindPos[0]+Vector3.Lerp(dir,dir.MultiBy(scaleFactor).SetY(dir.y),scaleLerp).MultiY(scaleFactor.y);
scaling[i]=Vector3.one+Vector3.Lerp(V3.zero,powFactor,scaleLerp);
for(inti=0;i<testSpheres.Length;i++)
Vector3dir=testSpherePos[i];
floatlerp=-1+dir.y/size.y*2;
floatscaleLerp=Mathf.Pow(Mathf.Cos(Mathf.PI*lerp/2),.5f).NaNChk();
Vector3scl=Vector3.one+Vector3.Lerp(V3.zero,powFactor,scaleLerp);
testSpheres[i].localPosition=Vector3.Lerp(dir,dir.MultiBy(scl).SetY(dir.y),scaleLerp).MultiY(scaleFactor.y);
privatefloatUpdateSquash()
if(Input.GetKeyDown(KeyCode.Mouse0))
Rayray=Camera.main.ScreenPointToRay(Input.mousePosition);
RaycastHithit;
if(Physics.Raycast(ray,outhit)&&hit.collider==coll)
shakeTimes.Add(Time.realtimeSinceStartup);
intcount=shakeTimes.Count;
for(inti=0;i<count;i++)
if(shakeTimes[i]<Time.realtimeSinceStartup-5)
shakeTimes.RemoveAt(i);
count--;
i--;
floatsq=1;
for(inti=0;i<shakeTimes.Count;i++)
sq+=GPhysics.Oscillate(Time.realtimeSinceStartup-shakeTimes[i],5,2.3f,9,.25f)*-.25f;
returnsq.NaNChk(1);
publicclassSquashTest:MonoBehaviour
privateTransformchild;
publicVector3scale;
[Space(10)]
[Range(0,1)]
publicfloatsquashAmount;
publicfloatspeed;
privatefloattime;
privatevoidAwake()
child=transform.GetChild(0);
time=Random.Range(0,1f);
privatevoidUpdate()
time+=Time.deltaTime*speed;
Vector3newScale=scale.VolumeScaleX(Mathf.Lerp(Mth.SmoothPP(0,1,time),1,squashAmount));
child.localPosition=Vector3.up*newScale.y*.5f;
child.localScale=newScale;
publicclassStackTangle:MonoBehaviour
privateclassFallRect
privatereadonlyColorcolor;
privatereadonlyBounds2Dbounds=newBounds2D();
privateconstintxMin=-25,xMax=25;
publicstaticfloatmaxY;
publicFallRect()
boolhorizontal=rects.Count>2&&Random.Range(0,4)==0;
if(!horizontal)
floatx1,x2;
inttrys=0;
while(true)
x1=Random.Range(xMin,xMax-2);
x2=Random.Range(x1,Mathf.Min(xMax,x1+10));
if(Mathf.Abs(x2-x1)>2)
break;
trys++;
if(trys==100)
if(Application.isEditor)
Debug.Log("Horizontaldidn'twork");
return;
bounds.minX=x1;
bounds.maxX=x2;
bounds.minY=0;
bounds.maxY=Random.Range(2,10f);
color=Color.Lerp(Color.yellow,Color.green,Random.Range(0,1f));
if(rects.Count>0)
for(inti=0;i<rects.Count;i++)
Bounds2Dother=rects[i].bounds;
if(bounds.XAxisOverlap(other)&&other.maxY>bounds.minY)
floatoffset=other.maxY-bounds.minY;
bounds.maxY+=offset;
bounds.minY+=offset;
maxY=Mathf.Max(maxY,bounds.maxY);
else
floaty1,y2;
inttrys=0;
while(true)
y1=Random.Range(Mathf.Max(0,maxY-100),maxY);
y2=Random.Range(y1,Mathf.Min(maxY,y1+10));
if(Mathf.Abs(y2-y1)>2)
break;
trys++;
if(trys==100)
if(Application.isEditor)
Debug.Log("Horizontaldidn'twork");
return;
boolfromRight=Random.Range(0,2)==0;
if(fromRight)
bounds.minX=-1000;
bounds.maxX=bounds.minX+Random.Range(2,10f);
bounds.minY=y1;
bounds.maxY=y2;
color=Color.Lerp(Color.red,Color.cyan,Random.Range(0,1f));
if(rects.Count>0)
for(inti=0;i<rects.Count;i++)
Bounds2Dother=rects[i].bounds;
if(bounds.YAxisOverlap(other)&&other.maxX>bounds.minX)
floatoffset=other.maxX-bounds.minX;
bounds.maxX+=offset;
bounds.minX+=offset;
else
bounds.maxX=1000;
bounds.minX=bounds.maxX-Random.Range(2,10f);;
bounds.minY=y1;
bounds.maxY=y2;
color=Color.Lerp(Color.red,Color.cyan,Random.Range(0,1f));
if(rects.Count>0)
for(inti=0;i<rects.Count;i++)
Bounds2Dother=rects[i].bounds;
if(bounds.YAxisOverlap(other)&&other.minX<bounds.maxX)
floatoffset=other.minX-bounds.maxX;
bounds.maxX+=offset;
bounds.minX+=offset;
rects.Add(this);
privatevoidDraw(floatmin,floatmax)
if(bounds.minY<=max&&bounds.maxY>=min)
bounds.Draw().SetColor(color).Fill();
privatestaticreadonlyList<FallRect>rects=newList<FallRect>();
publicstaticvoidDrawAll(floatmin,floatmax)
for(inti=0;i<rects.Count;i++)
rects[i].Draw(min,max);
publicstaticvoidClear()
rects.Clear();
maxY=0;
publicTransformcam;
privatefloatcamAnim=0;
privatestringbuildTime;
privatevoidOnEnable()
BuildTower();
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
BuildTower();
camAnim=Mathf.Clamp(camAnim+Input.GetAxis("Vertical")/(1+FallRect.maxY)*2,0,1);
floaty=Mathf.Lerp(0,FallRect.maxY,camAnim);
cam.position=newVector3(0,y,-10);
constintlineCount=10;
for(inti=0;i<lineCount;i++)
floathorizon=y-Mathf.Lerp(0,30+i*i*30,camAnim);
DRAW.Vector(newVector3(-1000,horizon),newVector3(2000,0)).SetColor(Color.white.A(.15f*(1-(float)i/lineCount)));
floatcamY=cam.position.y;
FallRect.DrawAll(camY-40,camY+40);
privatevoidBuildTower()
FallRect.Clear();
floatt=Time.realtimeSinceStartup;
for(inti=0;i<1000;i++)
newFallRect();
t=Time.realtimeSinceStartup-t;
intframes=Mathf.FloorToInt(t*60);
buildTime="BuildTime:"+t.ToString("F4")+"\n"+frames+(frames>1?"Frames":"Frame")+"\n\n"+"Height:"+FallRect.maxY.ToString("F1");
privatevoidOnGUI()
GUI.Label(newRect(Vector2.zero,newVector2(Screen.width,Screen.height)),buildTime);
publicclassThreadingTest:MonoBehaviour,IThreadJob
publicintcount;
publicintmax;
[Space(10)]
publicfloatstepLength;
publicfloatwaitLength;
publicvoidWork(){count++;}
publicboolIsDone{get{returncount>=max;}}
privateThreadJobjob;
publicvoidCallBack(boolsuccess)
Debug.Log(success?"DoneCounting":"ThreadAborted");
privatevoidAwake()
job=newThreadJob(this,stepLength,waitLength);
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
job.Abort();
publicinterfaceIThreadJob
voidWork();
voidCallBack(boolsuccess);
boolIsDone{get;}
publicclassThreadJob
privatereadonlyThread_thread;
privatereadonlyIThreadJob_threadJob;
privatereadonlyint_stepMs;
privatereadonlyint_waitMs;
publicThreadJob(IThreadJobthreadJob,floatstepLength,floatsleepTime)
_threadJob=threadJob;
_stepMs=(int)(stepLength*1000);
_waitMs=(int)(sleepTime*1000);
_thread=newThread(ThreadedWork);
_thread.Start();
privatevoidThreadedWork()
DateTime_lastStep=DateTime.Now;
while(!_threadJob.IsDone)
_threadJob.Work();
if((DateTime.Now-_lastStep).Milliseconds>_stepMs)
Thread.Sleep(_waitMs);
_lastStep=DateTime.Now;
_threadJob.CallBack(true);
publicvoidAbort()
if(_thread.IsAlive)
_thread.Abort();
_threadJob.CallBack(false);
[CreateAssetMenu]
publicclassOutline:ScriptableObject
publicVector3[]vertices,normals;
publicColor32[]colors;
publicint[]lines;
[Space(10)]
publicintlength;
publicfloatwidth;
privatestaticreadonlyList<Vector3>verts=newList<Vector3>(ushort.MaxValue),
norms=newList<Vector3>(ushort.MaxValue);
privatestaticreadonlyList<Color32>cols=newList<Color32>(ushort.MaxValue);
privatestaticreadonlyList<int>tris=newList<int>(ushort.MaxValue);
publicvoidGenerateShapeMesh(Shapeshape,Meshmesh,floattesselation,Color32color=default(Color32),floatzOffset=0,Meshtip=null)
boolflip=zOffset>0;
for(inti=0;i<colors.Length;i++)
colors[i]=newColor32(color.r,color.g,color.b,colors[i].a);
inttriLoops=shape.GetTesselation(tesselation)-(shape.loop?0:1);
Vector3z=newVector3(0,0,zOffset);
verts.Clear();
norms.Clear();
tris.Clear();
cols.Clear();
for(inti=0;i<shape.segmentCount;i++)
Shape.Segmentsegment=shape.segments[i];
intsegmentSteps=segment.GetTesselation(tesselation);
floatlerpStep=1f/segmentSteps;
for(inte=0;e<segmentSteps;e++)
UseSegmentLerp(segment,lerpStep*e,z,flip);
UseSegmentLerp(shape.segments[shape.segmentCount-1],1,z,flip);
for(inti=0;i<triLoops;i++)
intoffset=i*length;
for(inte=0;e<lines.Length;e+=2)
inta=offset+lines[e]+length;
intb=offset+lines[e];
intc=offset+lines[e+1];
intd=offset+lines[e+1]+length;
Profiler.BeginSample("TriShit");
if(!flip)
tris.Add(a);
tris.Add(b);
tris.Add(c);
tris.Add(c);
tris.Add(d);
tris.Add(a);
else
tris.Add(c);
tris.Add(b);
tris.Add(a);
tris.Add(a);
tris.Add(d);
tris.Add(c);
Profiler.EndSample();
if(!shape.loop)
Vector3[]tipV=tip.vertices;
Vector3[]tipN=tip.normals;
int[]tipT=tip.triangles;
intsoFar=verts.Count;
intcount=tipV.Length;
Vector3shapePos=shape.GetPoint(0).V3()+z;
floatrad=shape.GetDir(0).ToRadian()+Mth.*.5f;
Quaternionrot=Rot.Z(rad*Mathf.Rad2Deg)*Quaternion.AngleAxis(180,Vector3.forward)*Quaternion.AngleAxis(-90,Vector3.right);
Matrix4x4mat=Matrix4x4.TRS(shapePos,rot,newVector3(1,flip?-1:1,1));
Color32c=newColor32(color.r,color.g,color.b,255);
for(inti=0;i<count;i++)
verts.Add(mat.MultiplyPoint(tipV[i]));
norms.Add(rot*tipN[i]);
cols.Add(c);
count=tipT.Length;
for(inti=0;i<count;i+=3)
if(!flip)
tris.Add(tipT[i]+soFar);
tris.Add(tipT[i+1]+soFar);
tris.Add(tipT[i+2]+soFar);
else
tris.Add(tipT[i+2]+soFar);
tris.Add(tipT[i+1]+soFar);
tris.Add(tipT[i]+soFar);
intsoFar=verts.Count;
intcount=tipV.Length;
Vector3shapePos=shape.GetPoint(1).V3()+z;
floatrad=shape.GetDir(1).ToRadian()+Mth.*.5f;
Quaternionrot=Rot.Z(rad*Mathf.Rad2Deg)*Quaternion.AngleAxis(-90,Vector3.right);
Matrix4x4mat=Matrix4x4.TRS(shapePos,rot,newVector3(1,flip?-1:1,1));
Color32c=newColor32(color.r,color.g,color.b,255);
for(inti=0;i<count;i++)
verts.Add(mat.MultiplyPoint(tipV[i]));
norms.Add(rot*tipN[i]);
cols.Add(c);
count=tipT.Length;
for(inti=0;i<count;i+=3)
if(!flip)
tris.Add(tipT[i]+soFar);
tris.Add(tipT[i+1]+soFar);
tris.Add(tipT[i+2]+soFar);
else
tris.Add(tipT[i+2]+soFar);
tris.Add(tipT[i+1]+soFar);
tris.Add(tipT[i]+soFar);
mesh.Clear();
mesh.SetVertices(verts);
mesh.SetNormals(norms);
mesh.SetColors(cols);
mesh.SetTriangles(tris,0);
mesh.RecalculateBounds();
publicvoidGenerateShadowMesh(Shapeshape,Meshmesh,floattesselation)
inttriLoops=shape.GetTesselation(tesselation)-(shape.loop?0:1);
verts.Clear();
norms.Clear();
tris.Clear();
cols.Clear();
for(inti=0;i<shape.segmentCount;i++)
Shape.Segmentsegment=shape.segments[i];
intsegmentSteps=segment.GetTesselation(tesselation);
floatlerpStep=1f/segmentSteps;
for(inte=0;e<segmentSteps;e++)
UseSegmentLerp(segment,lerpStep*e);
UseSegmentLerp(shape.segments[shape.segmentCount-1],1);
for(inti=0;i<triLoops;i++)
intoffset=i*length;
for(inte=0;e<lines.Length;e+=2)
inta=offset+lines[e]+length;
intb=offset+lines[e];
intc=offset+lines[e+1];
intd=offset+lines[e+1]+length;
Profiler.BeginSample("TriShit");
tris.Add(a);
tris.Add(b);
tris.Add(c);
tris.Add(c);
tris.Add(d);
tris.Add(a);
Profiler.EndSample();
mesh.Clear();
mesh.SetVertices(verts);
mesh.SetNormals(norms);
mesh.SetColors(cols);
mesh.SetTriangles(tris,0);
mesh.RecalculateBounds();
privatevoidUseSegmentLerp(Shape.Segmentsegment,floatlerp)
Vector3shapePos=segment.LerpPos(lerp);
floatrad=segment.LerpRad(lerp);
Quaternionrot=Rot.Z(rad*Mathf.Rad2Deg);
Matrix4x4mat=Matrix4x4.TRS(shapePos,rot,Vector3.one);
for(intv=0;v<length;v++)
Profiler.BeginSample("ListShit");
verts.Add(mat.MultiplyPoint(vertices[v]));
norms.Add(rot*normals[v]);
cols.Add(newColor32(0,(byte)(255-colors[v].a),0,0));
Profiler.EndSample();
privatevoidUseSegmentLerp(Shape.Segmentsegment,floatlerp,Vector3z,boolflip)
Vector3shapePos=segment.LerpPos(lerp).V3()+z;
floatrad=segment.LerpRad(lerp);
Quaternionrot=Rot.Z(rad*Mathf.Rad2Deg);
Matrix4x4mat=Matrix4x4.TRS(shapePos,rot,newVector3(1,1,flip?-1:1));
for(intv=0;v<length;v++)
Profiler.BeginSample("ListShit");
verts.Add(mat.MultiplyPoint(vertices[v]));
norms.Add(rot*normals[v]);
cols.Add(colors[v]);
Profiler.EndSample();
[CustomEditor(typeof(Outline))]
publicclassOutlineEditor:Editor
publicoverridevoidOnInspectorGUI()
base.OnInspectorGUI();
GUILayout.BeginHorizontal();
if(GUILayout.Button("GetMeshEdge"))
stringfileName=EditorUtility.OpenFilePanel("Select",Application.dataPath+"/03_Scenes/TrackTest/Meshes/","fbx");
Meshmesh=AssetDatabase.LoadAssetAtPath<Mesh>(fileName.Replace(Application.dataPath,"Assets"));
if(mesh!=null)
GetMeshEdge(mesh,targetasOutline,false);
if(GUILayout.Button("GetMeshEdge(Colored)"))
stringfileName=EditorUtility.OpenFilePanel("Select",Application.dataPath+"/03_Scenes/TrackTest/Meshes/","fbx");
Meshmesh=AssetDatabase.LoadAssetAtPath<Mesh>(fileName.Replace(Application.dataPath,"Assets"));
if(mesh!=null)
GetMeshEdge(mesh,targetasOutline,true);
GUILayout.EndHorizontal();
privatestaticvoidGetMeshEdge(Meshmesh,Outlineoutline,boolcolored)
outline.width=mesh.bounds.size.x;
floatmin=mesh.bounds.min.z;
Vector3[]vertices=mesh.vertices;
Vector3[]normals=mesh.normals;
int[]triangles=mesh.triangles;
Color[]colors=mesh.colors;
if(colors.Length==0)
colors=newColor[vertices.Length];
for(inti=0;i<vertices.Length;i++)
colors[i]=newColor(1,1,1,1);
List<EdgeSegment>segments=newList<EdgeSegment>();
for(inti=0;i<triangles.Length;i+=3)
inta=triangles[i],
b=triangles[i+1],
c=triangles[i+2];
Vector3pA=vertices[a],
pB=vertices[b],
pC=vertices[c];
Vector3nA=normals[a],
nB=normals[b];
booledgeA=f.Same(pA.z,min),
edgeB=f.Same(pB.z,min),
edgeC=f.Same(pC.z,min);
if(edgeA&&edgeB)
Vector3z=pA+Vector3.forward;
boolswitchIt=Vector3.Dot(Vector3.Cross(pA-z,pB-z),nA)>0;
segments.Add(switchIt?newEdgeSegment(a,b):newEdgeSegment(b,a));
if(edgeB&&edgeC)
Vector3z=pB+Vector3.forward;
boolswitchIt=Vector3.Dot(Vector3.Cross(pB-z,pC-z),nB)>0;
segments.Add(switchIt?newEdgeSegment(b,c):newEdgeSegment(c,b));
if(edgeA&&edgeC)
Vector3z=pA+Vector3.forward;
boolswitchIt=Vector3.Dot(Vector3.Cross(pA-z,pB-z),nA)>0;
segments.Add(switchIt?newEdgeSegment(a,c):newEdgeSegment(c,a));
List<EdgeSegment>result=newList<EdgeSegment>();
List<EdgeSegment>sorted=newList<EdgeSegment>();
intchains=0;
while(segments.Count>0)
sorted.Clear();
EdgeSegmentfrontier=segments.GetRemoveAt(0);
sorted.Add(frontier);
boolforward=true;
while(segments.Count>0)
boolfoundNewFrontier=false;
for(inti=0;i<segments.Count;i++)
if(frontier.Connected(segments[i],forward))
frontier=segments.GetRemoveAt(i);
if(forward)
sorted.Add(frontier);
else
sorted.Insert(0,frontier);
foundNewFrontier=true;
break;
if(foundNewFrontier)
continue;
if(!forward)
break;
forward=false;
frontier=sorted[0];
Debug.Log(chains.ToString().B_Blue());
chains++;
while(sorted.Count>0)
result.Add(sorted.GetRemoveAt(0));
List<Vector3>verts=newList<Vector3>(),
norms=newList<Vector3>();
List<Color32>cols=newList<Color32>();
outline.lines=newint[result.Count*2];
Quaternionrot=Rot.X(-90);
HLStintColor=newHLS(1,.5f,1);
for(inti=0;i<result.Count;i++)
outline.lines[i*2]=verts.Count;
outline.lines[i*2+1]=verts.Count+1;
intindex=result[i].a;
verts.Add(rot*vertices[index].SetZ(0));
norms.Add(rot*normals[index].SetZ(0));
cols.Add(colored?tintColor.SetA(colors[index].r):colors[index]);
if(i==result.Count-1||!result[i].ConnectedAnySide(result[i+1]))
index=result[i].b;
verts.Add(rot*vertices[index].SetZ(0));
norms.Add(rot*normals[index].SetZ(0));
cols.Add(colored?tintColor.SetA(colors[index].r):colors[index]);
tintColor=tintColor.ShiftHue(.3f);
outline.vertices=verts.ToArray();
outline.normals=norms.ToArray();
outline.colors=cols.ToArray();
outline.length=outline.vertices.Length;
EditorUtility.SetDirty(outline);
privatestructEdgeSegment
publicreadonlyinta,b;
publicEdgeSegment(inta,intb)
this.a=a;
this.b=b;
publicboolConnected(EdgeSegmentother,boolafter)
returnafter&&b==other.a||!after&&a==other.b;
publicboolConnectedAnySide(EdgeSegmentother)
returna==other.a||b==other.b||
a==other.b||b==other.a;
publicstringDebugString
get{returna+"-"+b;}
publicclassTrackTest:MonoBehaviour
publicOutlineoutline;
[Space(10)]
[Range(1,100)]
publicinttesselation;
[Space(10)]
publicTransform[]stick;
privatereadonlyShapeshape=newShape();
privateMeshgenMesh;
privateintt;
privatevoidOnEnable()
GetComponent<MeshFilter>().mesh=genMesh=newMesh();
GenerateMesh();
privatevoidGenerateMesh(boolnewShape=true)
if(newShape)
shape.CreateByNumber(Random.Range(0,10));
outline.GenerateShapeMesh(shape,genMesh,tesselation);
t=tesselation;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.Space))
GenerateMesh();
if(t!=tesselation)
GenerateMesh(false);
for(inti=0;i<stick.Length;i++)
Vector2pos=shape.GetPoint(Mathf.Repeat(Time.realtimeSinceStartup/GTime.LoopTime+i*(1f/stick.Length),1))*2.5f;
stick[i].position=transform.TransformPoint(newVector3(pos.x,pos.y,0));
publicclassActivateInRow:MonoBehaviour
privateCircleSquare[]row;
publicfloatradius;
privatevoidStart()
row=GetComponentsInChildren<CircleSquare>();
for(inti=0;i<row.Length;i++)
row[i].gameObject.SetActive(false);
StartCoroutine(YieldActivate());
privateIEnumeratorYieldActivate()
floatoffset=0;
for(inti=0;i<row.Length;i++)
offset+=Time.deltaTime;
row[i].id=i;
row[i].t=offset+i*.12f;
row[i].radius=radius;
row[i].gameObject.SetActive(true);
radius*=.85f;
yieldreturnnull;
publicclassArcDebug:MonoBehaviour
publicLineline;
[Range(-1,1)]
publicfloatbend;
privatevoidUpdate()
Arcarc=newArc(line,bend,0);
arc.Draw(100).SetColor(Color.white*.5f);
Vector2a=Camera.main.ScreenToWorldPoint(Input.mousePosition);
DRAW.Circle(a,.04f,20).SetColor(Color.red).Fill(1,true);
Vector2b=arc.GetClosestPoint(a);
DRAW.Circle(b,.04f,20).SetColor(Color.red).Fill(1,true);
publicclassArcRaycastTest:MonoBehaviour
publicLineline;
[Range(-1,1)]
publicfloatbend;
[Space(10)]
publicLineray;
privatevoidUpdate()
Arcarc=newArc(line,bend,0);
arc.Draw(100).SetColor(Color.red);
Vector2hit;
if(arc.RayCast(ray.l1,ray.dir,outhit))
DRAW.Vector(ray.l1,hit-ray.l1).SetColor(Color.yellow);
Vector2reflect=Vector2.Reflect(ray.dir,arc.LerpDir(arc.GetClosestLerp(hit)).Rot90());
DRAW.Vector(hit,reflect*100).SetColor(Color.yellow.A(.25f));
else
DRAW.Vector(ray.l1,ray.dir*10000).SetColor(Color.yellow);
publicclassCircleSquare:MonoBehaviour
publicfloatradius;
[Range(0,1)]
publicfloatlerp;
publicboolanimate;
publicfloatspeed=1;
publicfloatt;
privatereadonlyLine[]lines=newLine[4];
privatereadonlyArc[]arcs=newArc[4];
privatefloatdotT;
[Space(10)]
publicintid;
privatevoidAwake()
dotT=Random.Range(0,4f);
privatevoidUpdate()
Circlecircle=newCircle(Vector2.zero,radius);
floatsideLength=circle.Get_Circumference*.25f;
if(Input.GetKeyDown(KeyCode.Space))
dotT=Random.Range(0,4f);
dotT+=Time.deltaTime;
HLSdotColor=newHLS(dotT*.25f).SetLuminace(.7f).SetSaturation(.8f);
if(animate)
t+=Time.deltaTime*speed;
lerp=Mth.SmoothPP(0,1,t);
DRAW.Shapeshape=DRAW.Shape.Get(101);
if(lerp<.01f)
lines[0]=newLine(newVector2(-sideLength*.5f,-sideLength*.5f),newVector2(-sideLength*.5f,sideLength*.5f));
lines[1]=newLine(newVector2(-sideLength*.5f,sideLength*.5f),newVector2(sideLength*.5f,sideLength*.5f));
lines[2]=newLine(newVector2(sideLength*.5f,sideLength*.5f),newVector2(sideLength*.5f,-sideLength*.5f));
lines[3]=newLine(newVector2(sideLength*.5f,-sideLength*.5f),newVector2(-sideLength*.5f,-sideLength*.5f));
for(inti=0;i<100;i++)
floatpointLerp=i*.04f;
intsegment=Mathf.FloorToInt(pointLerp);
floatsegmentLerp=pointLerp%1;
shape.Set(i,lines[segment].LerpPos(segmentLerp).V3(id*.1f));
else
floatbend=lerp*-.25f;
ArchelpArc=newArc(newLine(newVector2(0,-sideLength*.5f),newVector2(0,sideLength*.5f)),bend);
floatanimRadius=helpArc.Get_ChordLength*.5f+helpArc.Get_Height;
arcs[0]=newArc(newLine(newVector2(-animRadius,-sideLength*.5f),newVector2(-animRadius,sideLength*.5f)),bend);
arcs[1]=newArc(newLine(newVector2(-sideLength*.5f,animRadius),newVector2(sideLength*.5f,animRadius)),bend);
arcs[2]=newArc(newLine(newVector2(animRadius,sideLength*.5f),newVector2(animRadius,-sideLength*.5f)),bend);
arcs[3]=newArc(newLine(newVector2(sideLength*.5f,-animRadius),newVector2(-sideLength*.5f,-animRadius)),bend);
/*for(inti=0;i<4;i++)
arcs[i].Draw(100).SetColor(LineBlack);*/
for(inti=0;i<100;i++)
floatpointLerp=i*.04f;
intsegment=Mathf.FloorToInt(pointLerp);
floatsegmentLerp=pointLerp%1;
shape.Set(i,arcs[segment].LerpPos(segmentLerp).V3(id*.1f));
shape.Copy(0,100);
shape.SetColor(dotColor).Fill(1,true);
privatestaticreadonlyColorLineBlack=Color.black.A(.2f);
publicclassConnectWithArcs:MonoBehaviour
publicVector2p1,p2;
[Space(10)]
publicfloatr1;
publicfloatr2;
[Space(10)]
publicboolanimate;
publicfloatanimRange;
privatestaticfloatanimTime;
[Space(10)]publicbooldrawPebbles;
privatestaticbooldrawHelpers=true;
privatefloats1,s2;
[Space(10)]
[Range(0,2)]publicfloatmulti;
publicboolapproximateMulti;
privatevoidAwake()
s1=r1;
s2=r2;
DT.Init();
privatevoidUpdate()
DT.Count=0;
if(Input.GetKeyDown(KeyCode.H))
drawHelpers=!drawHelpers;
if(animate)
animTime+=Time.deltaTime;
r1=s1+Mth.SmoothPP(-animRange,animRange,animTime*.15f);
r2=s2+Mth.SmoothPP(-animRange,animRange,animTime*.22f);
SolveThing(newLine(p1,p1+r1.ToRadDir()),newLine(p2,p2+r2.ToRadDir()),drawPebbles,refmulti,approximateMulti);
privatestaticvoidSolveThing(Lineline1,Lineline2,booldrawPebbles,reffloatmulti,boolapproximateMulti)
Vector2p1=line1.l1,p2=line2.l1;
Lineperp1=line1.GetPerpendicular();
Lineperp2=line2.GetPerpendicular();
floatl1=0,l2=0,l3=0,l4=0;
if(drawHelpers)
WhiteLine(line1.l1,line1.GetL2(),100);
WhiteLine(line2.l1,line2.GetL2(),100);
BlackLine(perp1.l1,perp1.GetL2(),100);
BlackLine(perp2.l1,perp2.GetL2(),100);
Vector2dir1Perp2Contact,dir2Perp1Contact;
if(line1.Contact(perp2,outdir1Perp2Contact,true)&&line2.Contact(perp1,outdir2Perp1Contact,true))
Dot(dir1Perp2Contact);
Dot(dir2Perp1Contact);
Vector2perp1ToP1=p1-dir2Perp1Contact;
Vector2perp2ToP2=p2-dir1Perp2Contact;
floatradius1=perp1ToP1.magnitude;
floatradius2=perp2ToP2.magnitude;
if(DT.Go)DT.Get(radius1.ToString("F2")).WorldPos(p1+perp1ToP1*-.5f).Color(TextColor).Dir(Dir.Center);
if(DT.Go)DT.Get(radius2.ToString("F2")).WorldPos(p2+perp2ToP2*-.5f).Color(TextColor).Dir(Dir.Center);
Vector2perp1ToP2=p2-dir2Perp1Contact;
Vector2perp2ToP1=p1-dir1Perp2Contact;
if(DT.Go)DT.Get(perp1ToP2.magnitude.ToString("F2")).WorldPos(p2+perp1ToP2*-.5f).Color(TextColor).Dir(Dir.Center);
if(DT.Go)DT.Get(perp2ToP1.magnitude.ToString("F2")).WorldPos(p1+perp2ToP1*-.5f).Color(TextColor).Dir(Dir.Center);
if(approximateMulti)
multi=ApproxMulti(p1,dir2Perp1Contact-p1,p2,dir1Perp2Contact-p2);
if(DT.Go)DT.Get("Multi:"+multi.ToString("F3")).Color(TextColor).List_L();
radius1*=multi;
radius2*=multi;
Vector2c1=p1+(dir2Perp1Contact-p1)*multi;
Vector2c2=p2+(dir1Perp2Contact-p2)*multi;
LinecutLine=newLine(c1,c2);
if(approximateMulti)
floatangle1=Vector2.Angle(p1-c1,c2-c1);
if(Vector2.Dot(line1.dir,c2-c1)<0)
angle1=360-angle1;
floatangle2=Vector2.Angle(p2-c2,c1-c2);
if(Vector2.Dot(-line2.dir,c1-c2)<0)
angle2=360-angle2;
if(DT.Go)DT.Get("\nAngle1:"+angle1).Color(TextColor).List_L();
if(DT.Go)DT.Get("Angle2:"+angle2).Color(TextColor).List_L();
newArc(newLine(p1,p1+line1.dir.SetLength(Mth.*radius1*(angle1/180))),-angle1/360,0).Draw(100).SetColor(Color.black);
newArc(newLine(p2,p2-line2.dir.SetLength(Mth.*radius2*(angle2/180))),-angle2/360,0).Draw(100).SetColor(Color.black);
DRAW.Circle(c1,radius1,200).SetColor(LineBlack);
DRAW.Circle(c2,radius2,200).SetColor(LineBlack);
/*WhiteLine(c1,dir1Perp2Contact);
WhiteLine(c2,dir2Perp1Contact);*/
Circlea=newCircle(p1,(p1-p2).magnitude);
Circleb=newCircle(p2,(p2-p1).magnitude);
/*a.Draw(200).SetColor(Color.black.A(.2f));
b.Draw(200).SetColor(Color.black.A(.2f));
Vector2hitA,hitB;
inthitCount;
if(a.Contact(b,outhitCount,outhitA,outhitB))
BlackLine(hitA,hitB);*/
/*floatp1HitLength=(p1-dir1Perp2Contact).magnitude;
floatp2HitLength=(p2-dir2Perp1Contact).magnitude;
DrawText.Get("Dir1-HitLength:"+p1HitLength.ToString("F3")).LeftList().Color(TextColor);
DrawText.Get("Dir2-HitLength:"+p2HitLength.ToString("F3")).LeftList().Color(TextColor);*/
/*Vector2m1=p1+(dir2Perp1Contact-p1)*.5f;
Vector2m2=p2+(dir1Perp2Contact-p2)*.5f;
BlackLine(m1,m2);*/
/*BlackLine(p1,p2);
BlackLine(dir1Perp2Contact,dir2Perp1Contact);*/
floatdirAverageLength=0;
Vector2dirHit=Vector2.zero;
Vector2averageDir=(line1.dir+line2.dir).normalized;
if(line1.Contact(line2,outdirHit,true))
Dot(dirHit);
Lineaverage=newLine(dirHit,dirHit+averageDir);
WhiteLine(average.l1,average.GetL2(),100);
Vector2cutHit=Vector2.zero;
if(cutLine.Contact(average,outcutHit,true))
Dot(cutHit);
Vector2perp1Hit,perp2Hit;
if(average.Contact(perp1,outperp1Hit,true)&&average.Contact(perp2,outperp2Hit,true))
dirAverageLength=(perp1Hit-perp2Hit).magnitude;
if(DT.Go)DT.Get("\nDirAverageLength:"+dirAverageLength.ToString("F3")).List_L().Color(TextColor);
floatcutRatio=(perp1Hit-cutHit).magnitude/dirAverageLength;
if(DT.Go)DT.Get("\n!!!CutRatio!!!:"+cutRatio.ToString("F3")).List_L().Color(TextColor);
l1=(dirHit-p1).magnitude;
l2=(dirHit-p2).magnitude;
if(DT.Go)DT.Get(l1.ToString("F5")+"-P1ToDirHit").List_R().Color(TextColor);
if(DT.Go)DT.Get(l2.ToString("F5")+"-P2ToDirHit").List_R().Color(TextColor);
floatperpAverageLength=0;
Vector2perHit=Vector2.zero;
Vector2averagePerp=(perp1.dir+perp2.dir).normalized;
if(perp1.Contact(perp2,outperHit,true))
Dot(perHit);
Lineaverage=newLine(perHit,perHit+averagePerp);
Vector2dirHit1,dirHit2;
if(average.Contact(line1,outdirHit1,true)&&average.Contact(line2,outdirHit2,true))
perpAverageLength=(dirHit1-dirHit2).magnitude;
if(DT.Go)DT.Get("PerpAverageLength:"+perpAverageLength.ToString("F3")).List_L().Color(TextColor);
l3=(perHit-p1).magnitude;
l4=(perHit-p2).magnitude;
if(DT.Go)DT.Get(l3.ToString("F5")+"-P1ToPerpHit").List_R().Color(TextColor);
if(DT.Go)DT.Get(l4.ToString("F5")+"-P2ToPerpHit").List_R().Color(TextColor);
DRAW.Circle(dirHit,(perHit-dirHit).magnitude,300).SetColor(LineHue);
DRAW.Circle(perHit,(dirHit-perHit).magnitude,300).SetColor(LineHue);
floataverageRatio=dirAverageLength/perpAverageLength;
if(DT.Go)DT.Get("AverageRatio:"+averageRatio.ToString("F3")).List_L().Color(TextColor);
floatcombined=l1+l2+l3+l4;
if(DT.Go)DT.Get("\n"+combined.ToString("F5")+"-Combined").List_R().Color(TextColor);
floatp1p2Ratio=(l2+l4)/combined;
if(DT.Go)DT.Get(p1p2Ratio.ToString("F5")+"-P1P2Ratio").List_R().Color(TextColor);
floatdirPerpRatio=(l3+l4)/combined;
if(DT.Go)DT.Get(dirPerpRatio.ToString("F5")+"-DirPerpRatio").List_R().Color(TextColor);
floatp1Ratio=l1/(l1+l3);
if(DT.Go)DT.Get("\n"+p1Ratio.ToString("F5")+"-P1Ratio").List_R().Color(TextColor);
floatp2Ratio=l2/(l2+l4);
if(DT.Go)DT.Get(p2Ratio.ToString("F5")+"-P2Ratio").List_R().Color(TextColor);
floatbiggest=Mathf.Max(l1,Mathf.Max(l2,Mathf.Max(l3,l4)));
floatsmallest=Mathf.Min(l1,Mathf.Min(l2,Mathf.Min(l3,l4)));
floatbigSmallA=smallest/biggest;
if(DT.Go)DT.Get("\n"+bigSmallA.ToString("F5")+"-BigSmallRatioA").List_R().Color(TextColor);
floatbigSmallB=smallest/(biggest+smallest);
if(DT.Go)DT.Get(bigSmallB.ToString("F5")+"-BigSmallRatioA").List_R().Color(TextColor);
/*floatfactor=radius2/radius1;
Vector2factorPoint=dir1Perp2Contact+(dir2Perp1Contact-dir1Perp2Contact)*factor;
DrawPoint(factorPoint);
radius1=(dir2Perp1Contact-factorPoint).magnitude;
radius2=(dir1Perp2Contact-factorPoint).magnitude;
Vector2circleCenter1=p1-perp1ToP1.normalized*radius1;
Vector2circleCenter2=p2-perp2ToP2.normalized*radius2;
/*DRAW.Circle(circleCenter1,radius1,100).SetColor(Color.black.A(.2f));
DRAW.Circle(circleCenter2,radius2,100).SetColor(Color.black.A(.2f));#1#
DRAW.Vector(p1,factorPoint-p1).SetColor(Color.black.A(.2f));
Vector2midPoint=p1+(factorPoint-p1)*.5f;
Lineline=newLine(midPoint,midPoint+(factorPoint-p1).Rot90(false));
Vector2hit;
if(line.Contact(perp1,outhit,true))
DrawPoint(hit);
DRAW.Circle(hit,(factorPoint-hit).magnitude,100).SetColor(Color.black.A(.2f));
DRAW.Vector(p1,p2-p1).SetColor(Color.white.A(.2f));*/
floatpathLength=0;
if(false)
Vector2perpContact;
if(perp1.Contact(perp2,outperpContact,true))
if(drawHelpers)
DRAW.Circle(perpContact,.075f,20).SetColor(Color.black).Fill(.3f,true);
Vector2toP1=p1-perpContact;
Vector2toP2=p2-perpContact;
floatoAngle=Vector2.Angle(toP1,toP2);
floatbend=(360-oAngle)/360;
if(toP1.sqrMagnitude<toP2.sqrMagnitude)
floatarcRadius=toP1.magnitude;
if(drawHelpers&&false)
DRAW.Circle(perpContact,arcRadius,100).SetColor(Color.black.A(.2f));
floatarcLength=arcRadius*2*Mth.*((360-oAngle)/360);
Arcarc=newArc(newLine(p1,p1+line1.dir*arcLength),bend);
arc.Draw(100).SetColor(Color.black);
else
floatarcRadius=toP2.magnitude;
if(drawHelpers&&false)
DRAW.Circle(perpContact,arcRadius,100).SetColor(Color.black.A(.2f));
floatarcLength=arcRadius*2*Mth.*bend;
Arcarc=newArc(newLine(p2,p2+line2.dir*arcLength),bend,0);
floatotherLength=toP1.magnitude;
floatotherRadius=(otherLength-arcRadius)*.5f;
floatotherArcLength=otherRadius*Mth.;
Vector2arc2Point=perpContact+toP1.normalized*arcRadius;
if(drawHelpers)
DRAW.Circle(arc2Point,.075f,20).SetColor(Color.black).Fill(.3f,true);
ArcotherArc=newArc(newLine(arc2Point,arc2Point-line1.dir*otherArcLength),-.5f,0);
pathLength=arcLength+otherArcLength;
if(drawPebbles)
floatpathStepper=0;
HLSpebble=Color.red.ToHLS();
while(pathStepper<pathLength)
Vector2drawPoint=pathStepper<arcLength?
arc.LerpPos(pathStepper/arcLength):
otherArc.LerpPos((pathStepper-arcLength)/otherArcLength);
DRAW.Circle(drawPoint,.075f,20).SetColor(pebble.ShiftHue(pathStepper*.1f)).Fill(1,true);
pathStepper+=.3f;
ColorendColor=Color.red.ToHLS().ShiftHue(pathLength*.1f);
DRAW.Circle(p1,.075f,20).SetColor(endColor).Fill(1);
DRAW.Arrow(p1,line1.dir,.15f).SetColor(endColor).Fill(1);
if(DT.Go)DT.Get("P1").WorldPos(p1).Color(endColor).Shift(10,0).Dir(Dir.Right);
DRAW.Circle(p2,.075f,20).SetColor(Color.red).Fill(1);
DRAW.Arrow(p2,line2.dir,.15f).SetColor(Color.red).Fill(1);
if(DT.Go)DT.Get("P2").WorldPos(p2).Color(Color.red).Shift(10,0).Dir(Dir.Right);
if(DT.Go)DT.Get("DirDot:"+Vector2.Dot(line1.dir,line2.dir).ToString("F2")).Color(TextColor).List_L();
/*for(inti=0;i<10;i++)
DrawText.Get("ThisisLine"+i).Color(Color.red.ToHLS().ShiftHue(i*.1f)).LeftList();
for(inti=0;i<10;i++)
DrawText.Get("ThisisLine"+i).Color(Color.red.ToHLS().ShiftHue(i*.1f)).RightList();*/
privatestaticreadonlyColorTextColor=newHLS(0,.35f,0,1);
privatestaticreadonlyColorLineBlack=Color.black.A(.2f);
privatestaticreadonlyColorLineWhite=Color.white.A(.2f);
privatestaticColorLineHue{get{returnnewHLS(1,.5f,.2f).ShiftHue(animTime*.05f);}}
privatestaticvoidDot(Vector2point)
DRAW.Circle(point,.055f,20).SetColor(Color.black).Fill(.3f,true);
privatestaticvoidWhiteLine(Vector2p1,Vector2p2,floatmulti=1)
Vector2dir=p2-p1;
Vector2center=p1+dir*.5f;
p1=center-dir*.5f*multi;
p2=center+dir*.5f*multi;
DRAW.Vector(p1,(p2-p1)).SetColor(LineWhite);
privatestaticvoidBlackLine(Vector2p1,Vector2p2,floatmulti=1)
Vector2dir=p2-p1;
Vector2center=p1+dir*.5f;
p1=center-dir*.5f*multi;
p2=center+dir*.5f*multi;
DRAW.Vector(p1,(p2-p1)).SetColor(LineBlack);
privatestaticfloatApproxMulti(Vector2p1,Vector2dir1,Vector2p2,Vector2dir2)
floatm=3;
floatstep=m*.5f;
floatr1=dir1.magnitude;
floatr2=dir2.magnitude;
for(inti=0;i<20;i++)
m+=newCircle(p1+dir1*m,r1*m).Contact(newCircle(p2+dir2*m,r2*m))?-step:step;
step*=.5f;
returnm;
privateclassDT
privateVector2pos,offset;
privatestringtext;
privateColorcolor;
privateDirdir;
privateboolleftList,rightList,world;
privateDTSetup(stringtext)
this.text=text;
color=UnityEngine.Color.white;
dir=_defaultDir;
offset=Vector2.zero;
leftList=false;
rightList=false;
world=false;
returnthis;
publicDTColor(Colorcolor)
this.color=color;
returnthis;
publicDTWorldPos(Vector2pos)
world=true;
rightList=false;
leftList=false;
this.pos=pos;
returnthis;
publicDTScreenPos(Vector2pos)
this.pos=newVector2(pos.x,Screen.height-pos.y);
returnthis;
publicDTDir(Dirdir)
this.dir=dir;
returnthis;
publicDTShift(intx,inty)
offset=newVector2(x,y);
returnthis;
publicDTList_L()
leftList=true;
rightList=false;
world=false;
returnthis;
publicDTList_R()
rightList=true;
leftList=false;
world=false;
returnthis;
publicvoidDraw()
GUI.color=color;
Vector2size=style.CalcSize(newGUIContent(text));
Vector2anchorDir;
if(leftList)
pos=newVector2(0,leftY);
leftY+=size.y;
anchorDir=GetAnchorDir(global::Dir.BottomRight);
elseif(rightList)
pos=newVector2(Screen.width,rightY);
rightY+=size.y;
anchorDir=GetAnchorDir(global::Dir.BottomLeft);
else
anchorDir=GetAnchorDir(dir);
Vector2drawPos;
if(world)
Vector2screenPos=cam.WorldToScreenPoint(pos).V2();
drawPos=newVector2(screenPos.x,Screen.height-screenPos.y);
else
drawPos=pos;
Vector2anchorShift=newVector2(Mathf.Approximately(anchorDir.x,0)?0:Mathf.Sign(anchorDir.x)*size.x*.5f,
Mathf.Approximately(anchorDir.y,0)?0:Mathf.Sign(anchorDir.y)*size.y*.5f);
GUI.Label(newRect(drawPos-size*.5f+anchorShift+offset,size),text,style);
GUI.color=UnityEngine.Color.white;
privatestaticVector2GetAnchorDir(Dirdir)
switch(dir)
default:returnVector2.zero;
caseglobal::Dir.TopLeft:returnnewVector2(-1,-1);
caseglobal::Dir.Top:returnnewVector2(0,-1);
caseglobal::Dir.TopRight:returnnewVector2(1,-1);
caseglobal::Dir.Left:returnnewVector2(-1,0);
caseglobal::Dir.Right:returnnewVector2(1,0);
caseglobal::Dir.BottomLeft:returnnewVector2(-1,1);
caseglobal::Dir.Bottom:returnnewVector2(0,1);
caseglobal::Dir.BottomRight:returnnewVector2(1,1);
privatestaticCameracam;
publicstaticintCount;
publicstaticreadonlyDT[]texts=CollectionInit.Array<DT>(100);
publicstaticGUIStylestyle;
privatestaticDir_defaultDir=global::Dir.TopRight;
publicstaticfloatleftY,rightY;
publicconstboolGo=true;
publicstaticDTGet(stringtext)
returntexts[Count++].Setup(text);
publicstaticvoidInit()
cam=Camera.main;
privatevoidOnGUI()
if(DT.style==null)
DT.style=newGUIStyle(GUI.skin.label)
fontStyle=FontStyle.Bold,
fontSize=10,
padding=newRectOffset(3,3,1,1)
DT.leftY=0;
DT.rightY=0;
for(inti=0;i<DT.Count;i++)
DT.texts[i].Draw();
publicenumDir
TopLeft,Top,TopRight,Left,Center,Right,BottomLeft,Bottom,BottomRight
publicclassLineCircleAllign:MonoBehaviour
publicfloatradius,lineLength;
privatevoidUpdate()
Circlecircle=newCircle(Vector2.zero,radius);
circle.Draw(100).SetColor(Color.white);
floatangle=circle.GetArcAngle(lineLength);
if(!Mathf.Approximately(angle,0))
Vector2p1=Vector2.up.RotRad(-angle*.5f).SetLength(radius);
Vector2p2=Vector2.up.RotRad(angle*.5f).SetLength(radius);
DRAW.Vector(p1,p2-p1).SetColor(Color.yellow);
DRAW.Vector(Vector3.zero,p1).SetColor(Color.yellow);
DRAW.Vector(Vector3.zero,p2).SetColor(Color.yellow);
publicclassLineSide:MonoBehaviour
publicLineline;
publicfloatradAngle;
privatevoidUpdate()
line.Draw();
radAngle=line.dir.RadAngle((Camera.main.ScreenToWorldPoint(Input.mousePosition).V2()-line.l1));
publicclassSmallestFitCircle:MonoBehaviour
[Range(2,20)]
publicintsegments=3;
publicfloatsegmentLength;
[Space(10)]
[Range(0,1)]
publicfloatlerp;
privatefloatt;
privatevoidUpdate()
t+=Time.deltaTime*.3f;
floatangle=2*Mathf.PI/segments;
floathalfAngle=angle*.5f;
floatopposite=segmentLength*.5f;
floatradius=opposite/Mathf.Sin(halfAngle);
DRAW.Circle(Vector2.zero,radius,100).SetColor(Color.white);
HLShls=Color.yellow.ToHLS();
Vector2last=(Vector2.up*radius).RotRad(t);
floatangleStep=angle*lerp;
Vector2dir=(Vector2.left*segmentLength).RotRad(t+angleStep*.5f);
for(inti=0;i<segments;i++)
DRAW.Vector(last,dir).SetColor(hls.ShiftHue(i*.1f));
last+=dir;
dir=dir.RotRad(angleStep);
DRAW.Vector(Vector3.right*segmentLength*-.5f,Vector3.right*segmentLength).SetColor(Color.yellow);
publicclassTurd:MonoBehaviour
publicLineline;
publicfloatthickness;
publicCircle[]circles;
[Space(10)][Range(0,1)]
publicfloatanimSpeed;
privateColordraw;
privateLinefallLine,turnLine;
privateboolturnOnA;
privateFlyPathflyPath;
privatefloatflightTime;
privatefloatmaxBend;
privateintcollisionCircle;
privatefloatturnSpeed,turnTime,turnAngle;
[Space(10)]
publicLinetestLine;
privatefloatmeasure;
privateintmeasureCount;
privateenumTestState{None,Falling,LineToTangent,ArcToSurface}
privateTestStatestate;
privateboolturning;
privateLineflatLine;
privatefloatflatLineLerp,flatBend,flatBendTime,flatBendSpeed;
privateboolshowHelpers=true;
privateLinehitReaction;
privatefloathitReactionSpin,hitReactionTime;
privatevoidOnEnable()
draw=newColor(.1f,.1f,.1f,1);
maxBend=CalculateMaxBend(line.Length,thickness);
privatevoidUpdate()
line=line.Rotate(Time.deltaTime*80);
NewTest();
if(Input.GetKeyDown(KeyCode.H))
showHelpers=!showHelpers;
if(Input.GetMouseButtonDown(0)||Input.GetKeyDown(KeyCode.Space))
state=state==TestState.None?TestState.Falling:TestState.None;
if(state==TestState.Falling)
fallLine=line;
flyPath=newFlyPath(fallLine.l1+fallLine.dir*.5f,Rot.Z(Random.Range(0,360))*Vector2.up*10);
flightTime=0;
switch(state)
caseTestState.Falling:
flightTime+=Time.deltaTime*animSpeed;
fallLine=fallLine.SetPos(flyPath.GetPos(flightTime));
if(FoundCollision())
PreciseCollision();
Vector2center=circles[collisionCircle].center;
Vector2linePoint=fallLine.ClosestPoint(center);
Vector2impactMV=flyPath.GetMV(flightTime);
ImpactPhysics(fallLine,impactMV,center+(linePoint-center).SetLength(circles[collisionCircle].radius),(linePoint-center).normalized);
if(linePoint==fallLine.l1||linePoint==fallLine.GetL2())
state=TestState.LineToTangent;
turnOnA=linePoint==fallLine.l1;
turnLine=fallLine;
Vector2dir=linePoint-center;
Vector2tangent=dir.Rot90();
Vector2turnDir=(tangent*Vector2.Dot(fallLine.dir,tangent)).normalized;
turnAngle=-fallLine.dir.normalized.Angle_Sign(turnDir);
floattotalTurnCircumference=fallLine.Length*2*Mth.;
floattotalTurnTime=totalTurnCircumference/impactMV.magnitude;
turnSpeed=1f/(Mathf.Abs(turnAngle)/360*totalTurnTime);
turnTime=0;
turning=true;
else
turning=false;
turnAngle=0;
state=TestState.ArcToSurface;
flatLineLerp=Mathf.Clamp01(fallLine.GetClosestLerp(center));
flatLine=fallLine.Rotate(turnAngle,turnOnA?0:1);
floatflatRadius=circles[collisionCircle].radius+thickness;
floatcircleDirSign=Mathf.Sign(Vector2.Dot(flatLine.dir.Rot90().normalized,(center-flatLine.l1).normalized));
flatBend=flatLine.GetBend(flatRadius*circleDirSign);
flatBend=Mathf.Min(Mathf.Abs(flatBend),maxBend)*Mathf.Sign(flatBend);
flatBendTime=0;
floatarcTravel=Mathf.Abs(flatBend)*flatLine.Length*Arc.LineTipPathRatio;
flatBendSpeed=impactMV.magnitude/arcTravel;
break;
caseTestState.LineToTangent:
turnTime+=Time.deltaTime*turnSpeed*animSpeed;
turnLine=fallLine.Rotate(Mathf.Lerp(0,turnAngle,turnTime),turnOnA?0:1);
if(turnTime>=1)
state=TestState.ArcToSurface;
break;
caseTestState.ArcToSurface:
flatBendTime+=Time.deltaTime*flatBendSpeed*animSpeed;
break;
if(state!=TestState.None&&showHelpers)
Vector2mV=flyPath.GetMV(flightTime)*.1f;
DRAW.Arrow(fallLine.l1,-mV,.1f,true).SetColor(Color.white).Fill(1);
DRAW.Arrow(fallLine.GetL2(),-mV,.1f,true).SetColor(Color.white).Fill(1);
flyPath.Draw(flightTime,flightTime+.4f,20,true).SetColor(draw.A(.3f)).Fill(.3f);
if((state==TestState.LineToTangent||state==TestState.ArcToSurface)&&showHelpers)
Vector2center=circles[collisionCircle].center;
Vector2linePoint=fallLine.ClosestPoint(center);
Vector2dir=linePoint-center;
Vector2hitPoint=center+dir.SetLength(circles[collisionCircle].radius);
DRAW.Circle(hitPoint,.05f,30).SetColor(Color.red).Fill(1);
DRAW.Vector(hitPoint,dir.SetLength(thickness)).SetColor(Color.red);
if(turning)
DRAW.Circle(linePoint,.1f,30).SetColor(Color.yellow);
LinepreviewLine=fallLine.Rotate(turnAngle,turnOnA?0:1);
DRAW.GapVector(previewLine.l1,previewLine.dir,10);
fallLine.Rotate(Mth.SmoothPP(0,turnAngle,Time.realtimeSinceStartup),turnOnA?0:1).Draw().SetColor(Color.cyan);
ArcwiggleArc=newArc(flatLine,flatBend,flatLineLerp).SetBend(Mth.SmoothPP(-flatBend,flatBend,Time.realtimeSinceStartup*.5f),flatLineLerp);
wiggleArc.DrawShell(thickness,true).SetColor(Color.white.A(.5f));
wiggleArc.DrawTips().SetColor(Color.white).Fill(.5f,true);
hitReactionTime+=Time.deltaTime;
hitReaction.Rotate(GPhysics.Get_SpinAngle_Deg(hitReactionSpin,hitReactionTime)).DrawShell(thickness,true).SetColor(HLS.Get(hitReactionTime*.25f));
LinedrawLine;
switch(state)
default:drawLine=line;break;
caseTestState.Falling:drawLine=fallLine;break;
caseTestState.LineToTangent:drawLine=turnLine;break;
if(state!=TestState.ArcToSurface)
drawLine.DrawShell(thickness,true).SetColor(draw);
drawLine.DrawTips().SetColor(Color.yellow).Fill(1);
else
ArcflatArc=newArc(flatLine,Mathf.Lerp(0,flatBend,flatBendTime),flatLineLerp);
flatArc.DrawShell(thickness,true).SetColor(draw);
flatArc.DrawTips().SetColor(Color.yellow).Fill(1);
for(inti=0;i<circles.Length;i++)
DRAW.Circle(circles[i].center,circles[i].radius,100).SetColor(draw);
privatestaticfloatCalculateMaxBend(floatlength,floatthickness)
floatbend=.5f;
floatstep=.5f;
for(inti=0;i<10;i++)
floatradius=1/bend/2/Mth.*length;
floatcircumference=2*radius*Mth.;
floatarcLengthFraction=Mathf.Asin(thickness/radius)/Mth.;
floatnonArcLength=(1-arcLengthFraction)*circumference;
if(i==9)
break;
step*=.5f;
bend+=nonArcLength<length?-step:step;
returnbend;
privatestaticfloatCalculateMaxBend2(floatlength,floatchord)
return0;
privatevoidPreciseCollision()
floatstepTime=.1f;
flightTime-=stepTime;
for(inti=0;i<10;i++)
fallLine=fallLine.SetPos(flyPath.GetPos(flightTime));
if(i==9)
return;
stepTime*=.5f;
flightTime+=FoundCollision()?-stepTime:stepTime;
privateboolFoundCollision()
for(inti=0;i<circles.Length;i++)
floatitemRadiusSqr=Mth.IntPow(thickness+circles[i].radius,2);
if(fallLine.SqrDistance(circles[i].center)<=itemRadiusSqr)
collisionCircle=i;
returntrue;
returnfalse;
privatevoidNewTest()
testLine.Draw().SetColor(draw);
floatlineLerp=0;//Mathf.PingPong(Time.realtimeSinceStartup*.1f,1);
floatanimBend=Mth.SmoothPP(Time.realtimeSinceStartup*.25f*animSpeed);
ArctestArc=newArc(testLine,animBend,lineLerp);
testArc.Draw(100).SetColor(draw);
ColorlineColor=Color.Lerp(Color.white,Color.magenta,.5f);
floatrotLineAngle=(180-180*lineLerp)*animBend;
LinerotLine=testLine.Rotate(rotLineAngle,lineLerp);
rotLine.Draw().SetColor(lineColor);
Colorgreen=lineColor.ToHLS().ShiftHue(.5f);
testArc.Rotate(-rotLineAngle,0).Draw(100).SetColor(green);
privatevoidArcTipTest()
LineturnTestLine=testLine.Rotate(Time.realtimeSinceStartup*45f*animSpeed,0);
DRAW.Vector(turnTestLine.l1,turnTestLine.dir).SetColor(draw);
floatanimBend=Mth.SmoothPP(Time.realtimeSinceStartup*.5f*animSpeed);
ArctestArc=newArc(turnTestLine,animBend,0);
testArc.Draw(100);
DRAW.Circle(testArc.LerpPos(1),.1f,30).Fill();
floatlength=0;
Vector2p=turnTestLine.GetL2();
constfloatstep=1f/9999;
for(inti=1;i<10000;i++)
Vector2newP=newArc(turnTestLine,i*step,.5f).LerpPos(1);
length+=Vector2.Distance(p,newP);
p=newP;
measure+=length;
measureCount++;
Debug.Log(length+"..."+turnTestLine.Length+"..."+measure/measureCount/turnTestLine.Length);
DRAW.Shapeshape=DRAW.Shape.Get(100);
constfloatstep=1f/99;
for(inti=0;i<100;i++)
shape.Set(i,newArc(turnTestLine,i*step,0).LerpPos(1));
shape.SetColor(Color.magenta);
DRAW.Shapeshape=DRAW.Shape.Get(100);
constfloatstep=1f/99;
for(inti=0;i<100;i++)
shape.Set(i,newArc(turnTestLine,i*-step,0).LerpPos(0));
shape.SetColor(Color.magenta);
privatevoidImpactPhysics(LinehitLine,Vector2mV,Vector2hitPoint,Vector2normal)
hitReaction=hitLine;
Vector2center=hitReaction.l1+hitReaction.dir*.5f;
floatvelAlongNormal=Vector2.Dot(mV,normal);
floathitDirCross=(hitPoint-center).Cross(normal);
constfloate=.55f;
constfloatmass=10;
constfloatcolliderMass=100000;
constfloatinertia=8;
floatimpulse=-(1+e)*velAlongNormal/
(
1/mass+1/colliderMass
+Mth.IntPow(hitDirCross,2)/inertia
/*+Mathf.Pow(Extensions.CrossProduct(stickRadiusVector,Tri.HitNormalInverse),2)/inertia*///Stickinertiaisinfinite
);
hitReactionSpin=hitDirCross/inertia*impulse*Mathf.Rad2Deg/GPhysics.SpinMulti;
hitReactionTime=0;
publicclassColor32AsCord:MonoBehaviour
publicbytetileNumber;
privateMeshmesh;
privateColor32[]colors;
privatevoidAwake()
mesh=GetComponent<MeshFilter>().mesh;
colors=newColor32[mesh.vertices.Length];
SetColor();
privatevoidOnValidate()
if(Application.isPlaying&&mesh!=null)
SetColor();
privatevoidSetColor()
for(inti=0;i<colors.Length;i++)
colors[i]=newColor32(tileNumber,0,0,0);
mesh.colors32=colors;
publicclassZoneCornerTest:MonoBehaviour
publicinta,b,c,d;
[Space]
publicintzones;
[Space]
publicintmaxValue;
publicintindex;
[Space]
publicintoutA;
publicintoutB;
publicintoutC;
publicintoutD;
voidUpdate()
intmax=zones*2+1;
maxValue=max*max*max*max;
index=a*(max*max*max)+b*(max*max)+c*max+d;
publicclassHoudiniImport:AssetPostprocessor
privateconststringBodyPartImportFolder="_Character";
privateconststringBodyPartFolder="05_BodyParts/";
privateconststringMetaData="Assets/HoudiniMesh/_MetaData/";
privatevoidOnPreprocessModel()
ModelImporterthisModelImporter=assetImporterasModelImporter;
if(!thisModelImporter.assetPath.Contains("HoudiniMesh"))
return;
thisModelImporter.globalScale=1;
thisModelImporter.isReadable=thisModelImporter.assetPath.Contains("..")||thisModelImporter.assetPath.Contains(BodyPartImportFolder)||thisModelImporter.assetPath.Contains("WallOcclusion");
thisModelImporter.animationType=ModelImporterAnimationType.None;
thisModelImporter.importTangents=ModelImporterTangents.None;
thisModelImporter.optimizeMesh=true;
thisModelImporter.importMaterials=false;
thisModelImporter.importLights=false;
thisModelImporter.importCameras=false;
thisModelImporter.importBlendShapes=false;
thisModelImporter.importVisibility=false;
thisModelImporter.weldVertices=false;
publicstaticvoidOnPostprocessAllAssets(string[]importedAssets,string[]deletedAssets,string[]movedAssets,string[]movedFromPath)
for(inti=0;i<importedAssets.Length;i++)
stringpath=importedAssets[i];
if(path.Contains(BodyPartImportFolder)&&path.Contains(".fbx"))
ParseBodyPart(path);
publicstaticvoidParseBodyPart(stringfbxPath)
GameObjectfbx=AssetDatabase.LoadAssetAtPath(fbxPath,typeof(GameObject))asGameObject;
stringsavePath="Assets/"+BodyPartFolder+fbx.name+".asset";
BodyPartMeshbodyPart=AssetDatabase.LoadAssetAtPath(savePath,typeof(BodyPartMesh))asBodyPartMesh;
if(bodyPart!=null)
Debug.LogFormat("Updating:\"{0}\"",savePath);
else
bodyPart=ScriptableObject.CreateInstance<BodyPartMesh>();
AssetDatabase.CreateAsset(bodyPart,savePath);
Debug.LogFormat("Creating:\"{0}\"",savePath);
stringjsonPath=MetaData+fbx.name+".json";
if(!File.Exists(jsonPath))
return;
JSONNodenode=JSONNode.Parse(File.ReadAllText(jsonPath))["meta"];
List<Locator>locators=newList<Locator>();
foreach(JSONNodeiteminnode.Children)
JSONObjectjO=itemasJSONObject;
foreach(KeyValuePair<string,JSONNode>NinjO)
JSONNodevalueNode=N.Value;
if(valueNode.Count==3)
Vector3p=newVector3((float)double.Parse(valueNode[0]),
(float)double.Parse(valueNode[1]),
(float)double.Parse(valueNode[2]));
locators.Add(newLocator(N.Key,p));
bodyPart.partType=(PartType)Enum.Parse(typeof(PartType),fbx.name.Split('_')[0]);
bodyPart.locators=locators.ToArray();
MeshFiltermeshFilter=fbx.transform.GetComponent<MeshFilter>();
MeshcopyThis=meshFilter!=null?meshFilter.sharedMesh:fbx.transform.GetChild(0).GetComponent<MeshFilter>().sharedMesh;
MeshmeshCopy=Object.Instantiate(copyThis);
meshCopy.name=copyThis.name;
Object[]objects=AssetDatabase.LoadAllAssetsAtPath(savePath);
for(intm=0;m<objects.Length;m++)
if(objects[m]isMesh)
Object.DestroyImmediate(objects[m],true);
AssetDatabase.AddObjectToAsset(meshCopy,bodyPart);
EditorUtility.SetDirty(bodyPart);
AssetDatabase.ImportAsset(savePath);
objects=AssetDatabase.LoadAllAssetsAtPath(savePath);
for(intm=0;m<objects.Length;m++)
if(objects[m]isMesh)
bodyPart.mesh=(Mesh)objects[m];
break;
EditorUtility.SetDirty(bodyPart);
privatevoidOnPreprocessAsset()
if(assetImporter.assetPath.Contains("HoudiniUsed.txt"))
List<Color>newColors=newList<Color>();
string[]lines=File.ReadAllLines(assetImporter.assetPath);
for(inti=0;i<lines.Length;i++)
string[]parts=lines[i].Split(',');
newColors.Add(newColor32(byte.Parse(parts[0].Replace("[","")),
byte.Parse(parts[1]),
byte.Parse(parts[2].Replace("]","")),
255));
PaletteSource.Get.houdini=newColors.ToArray();
EditorUtility.SetDirty(PaletteSource.Get);
[CreateAssetMenu]
publicclassBodyPartMesh:ScriptableObject
publicMeshmesh;
publicPartTypepartType;
[Space(10)]
publicLocator[]locators;
publicVector3Get(PartTypepartType)
for(inti=0;i<locators.Length;i++)
if(locators[i].type==partType)
returnlocators[i].pos;
returnlocators[0].pos;
[Serializable]
publicclassLocator
publicPartTypetype;
publicVector3pos;
publicLocator(PartTypetype,Vector3pos)
this.type=type;
this.pos=pos;
publicLocator(stringname,Vector3pos)
type=(PartType)Enum.Parse(typeof(PartType),name);
this.pos=pos;
publicenumPartType
Stick,
Head,
Torso,
Arm,ArmL,ArmR,
Leg,LegL,LegR,
Mouth,
Eye,EyeL,EyeR
publicpartialclassRig:MonoBehaviour
publicBodyPartMeshhead,eye,mouth,torso,arm,leg;
privateconstintmaxBones=100,headParts=4,bendParts=5,partCount=bendParts;
publicreadonlyTransform[]bones=newTransform[maxBones];
publicreadonlyVector3[]bindPos=newVector3[maxBones];
privatereadonlyList<Color32>readColors=newList<Color32>(10000);
privatereadonlyList<Vector2>readUVs=newList<Vector2>(10000);
privatereadonlyList<byte>colorMask=newList<byte>(10000),
shadeMask=newList<byte>(10000);
privatereadonlyCombineInstance[]combineInstances=newCombineInstance[partCount+headParts];
privatereadonlyMesh[]sourceMeshes=newMesh[4];
publicreadonlyRigHeadrigHead=newRigHead();
publicreadonlyRigPart[]rigParts=CollectionInit.Array<RigPart>(bendParts);
privateSkinnedMeshRendererskin;
privateMeshmesh;
publicCostumeColorscC;
publicRigPoserposer;
publicRigDebugdebug;
publicintboneCount;
publicvoidSetup(Spinnerspinner)
poser=newRigPoser(this,spinner);
debug=newRigDebug(poser);
for(inti=0;i<bones.Length;i++)
bones[i]=(Application.isEditor?newGameObject("Bone"+i.ToString("D3")):newGameObject()).transform;
bones[i].SetParent(transform);
mesh=newMesh();
skin=GetComponent<SkinnedMeshRenderer>();
SkinMesh();
privatevoidSkinMesh()
sourceMeshes[0]=head.mesh;
sourceMeshes[1]=torso.mesh;
sourceMeshes[2]=arm.mesh;
sourceMeshes[3]=leg.mesh;
Vector3armRoot=torso.Get(PartType.Arm),
legRoot=torso.Get(PartType.Leg);
Vector3hands=(armRoot+arm.Get(PartType.Stick)).SetX(0);
Vector3feet=(legRoot+leg.Get(PartType.Stick)).SetX(0);
Vector3shift=(feet+hands)*-.5f;
constfloatlimbBend=1;//.333f;
RigInfo[]rigInfos=
newRigInfo(torso,shift,4,1),
newRigInfo(arm,shift+armRoot,3,limbBend),
newRigInfo(arm,(shift+armRoot).FlipX(),3,limbBend),
newRigInfo(leg,shift+legRoot,3,limbBend),
newRigInfo(leg,(shift+legRoot).FlipX(),3,limbBend)
boneCount=0;
Vector3headPos=shift+torso.Get(PartType.Head);
RigInfo[]headInfos=
newRigInfo(head,headPos,1,0),
newRigInfo(eye,headPos+head.Get(PartType.Eye),1,0),
newRigInfo(eye,(headPos+head.Get(PartType.Eye)).FlipX(),1,0),
newRigInfo(mouth,headPos+head.Get(PartType.Mouth),1,0)
for(inti=0;i<headInfos.Length;i++)
headInfos[i]=headInfos[i].CombineSetup(refcombineInstances[i]);
rigHead.Setup(headInfos,this);
for(inti=0;i<bendParts;i++)
rigParts[i].Setup(rigInfos[i].CombineSetup(refcombineInstances[i+headParts]),this);
mesh.Clear();
mesh.CombineMeshes(combineInstances);
skin.sharedMesh=mesh;
skin.bones=bones;
Matrix4x4[]bindPoses=newMatrix4x4[boneCount];
for(inti=0;i<boneCount;i++)
bindPoses[i]=Matrix4x4.Translate(-bindPos[i]);
mesh.GetUVs(0,readUVs);
mesh.GetColors(readColors);
colorMask.Clear();
shadeMask.Clear();
intcolorCount=readColors.Count;
for(inti=0;i<colorCount;i++)
Vector2uv=readUVs[i];
colorMask.Add((byte)uv.x);
shadeMask.Add((byte)uv.y);
intverticeCount=mesh.vertices.Length;
BoneWeight[]boneWeights=newBoneWeight[verticeCount];
for(inti=0;i<verticeCount;i++)
floatweight=readColors[i].a/255f;
boneWeights[i].boneIndex0=readColors[i].g;
boneWeights[i].weight0=weight;
boneWeights[i].boneIndex1=readColors[i].b;
boneWeights[i].weight1=1-weight;
mesh.bindposes=bindPoses;
mesh.boneWeights=boneWeights;
for(inti=boneCount;i<maxBones;i++)
bones[i].gameObject.SetActive(false);
poser.FinishSetup(mesh.bounds.size,hands+shift,feet+shift);
publicvoidColorizeMesh()
CostumeColorsbefore=cC;
while(cC==before)
cC=CostumeColors.RandomScheme;
mesh.Colorize(cC,colorMask,shadeMask);
publicvoidSetCostume(CostumeColorscostume)
cC=costume;
mesh.Colorize(cC,colorMask,shadeMask);
publicvoidToggleSkin(boolshow)
skin.enabled=show;
publicstructRigInfo
publicreadonlyPartTypepartType;
publicreadonlyMeshmesh;
publicreadonlyVector3pos;
publicreadonlyfloatbendyness;
publicreadonlyintboneCount;
publicRigInfo(BodyPartMeshbodyPart,Vector3pos,intboneCount,floatbendyness)
switch(bodyPart.partType)
casePartType.Arm:partType=pos.x>0?PartType.ArmR:PartType.ArmL;break;
casePartType.Leg:partType=pos.x>0?PartType.LegR:PartType.LegL;break;
default:partType=bodyPart.partType;break;
mesh=Object.Instantiate(bodyPart.mesh);
this.pos=pos;
this.boneCount=boneCount;
this.bendyness=bendyness;
publicRigInfoCombineSetup(refCombineInstancecombineInstance)
combineInstance.mesh=mesh;
combineInstance.transform=Matrix4x4.TRS(pos,Rot.Zero,newVector3(pos.x>0?-1:1,1,1));
returnthis;
publicpartialclassRig
privatestaticvoidMeshExport(Meshmesh,Transformt,stringmeshName)
StringBuildersb=newStringBuilder();
sb.Append("#"+meshName+".obj"+
"\n#"+System.DateTime.Now.ToLongDateString()+
"\n#"+System.DateTime.Now.ToLongTimeString()+
"\n#-------"+"\n\n");
Vector3pos=t.position;
Quaternionrot=t.rotation;
t.position=V3.zero;
t.rotation=Quaternion.identity;
Quaternionr=t.localRotation;
for(inti=0;i<mesh.vertices.Length;i++)
Vector3v=t.TransformPoint(mesh.vertices[i]);
sb.Append(string.Format("v{0}{1}{2}\n",v.x,v.y,-v.z));
sb.Append("\n");
for(inti=0;i<mesh.normals.Length;i++)
Vector3v=-(r*mesh.normals[i]);
sb.Append(string.Format("vn{0}{1}{2}\n",-v.x,-v.y,v.z));
sb.Append("\n");
for(vari=0;i<mesh.uv.Length;i++)
Vector3v=mesh.uv[i];
sb.Append(string.Format("vt{0}{1}\n",v.x,v.y));
int[]triangles=mesh.GetTriangles(0);
for(inti=0;i<triangles.Length;i+=3)
sb.Append(string.Format("f{0}/{0}/{0}{1}/{1}/{1}{2}/{2}/{2}\n",
triangles[i]+1,triangles[i+1]+1,triangles[i+2]+1));
stringfileName=EditorUtility.SaveFilePanel("Export.objfile","",meshName,"obj");
sw.Write(sb.ToString());
t.position=pos;
t.rotation=rot;
publicclassBendPart
privatereadonlyBonerootBone=newBone();
publicBoneTip;
publicreadonlyBone[]bones=CollectionInit.Array<Bone>(30);
publicintboneCount;
privateboolflippedY,noRootBend;
privatefloatmeshHeight,rootChainLength,stepMulti,bendyness;
publicvoidCreateBendChain(RigPartlimb)
boneCount=limb.boneCount;
flippedY=limb.flippedY;
noRootBend=limb.noRootBend;
bendyness=limb.bendyness;
rootChainLength=limb.rootChainLength;
meshHeight=limb.height;
stepMulti=limb.stepMulti;
rootBone.SetupBone(limb.rootBone.rigPos.SetX(0));
for(inti=0;i<boneCount;i++)
bones[i].SetupBone(limb.bones[i].rigPos.SetX(0));
Tip=bones[boneCount-1];
publicvoidCalculateBend(RigPoserposer)
rootBone.squashPos=rootBone.rigPos.MultiBy(poser.squashScale);
rootBone.turnRot=poser.GetTurnRot(rootBone.squashPos.y);
rootBone.turnPos=rootBone.turnRot*rootBone.squashPos;
for(inti=0;i<boneCount;i++)
bones[i].squashPos=bones[i].rigPos.MultiBy(poser.squashScale);
bones[i].turnRot=poser.GetTurnRot(bones[i].squashPos.y);
bones[i].turnPos=bones[i].turnRot*bones[i].squashPos;
if(noRootBend)
for(inti=boneCount-2;i<boneCount;i++)
bones[i].bendPos=poser.GetBendPlacement(bones[i].turnPos,false).pos;
else
floatrootRadius=poser.GetBendRadius(rootBone.turnPos);
floatnoBendAngle=Circle.GetSegmentRad(rootChainLength*poser.squashScale.y,rootRadius)*Mathf.Rad2Deg*flippedY.SignFloat(1);
PlacementrootPlacement=poser.GetBendPlacement(rootBone.turnPos);
rootBone.bendPos=rootPlacement.pos;
rootBone.bendRot=Rot.Z(noBendAngle*(1-bendyness))*rootPlacement.rot;
floatchainRadius=poser.GetBendRadius(bones[0].turnPos);
floatchainLength=meshHeight*poser.squashScale.y;
floatstepLength=chainLength*stepMulti;
floatbendLength=Mathf.Abs(Circle.GetSegmentRad(stepLength,chainRadius)*chainRadius*(boneCount-1)*2);
chainLength=bendLength.NaNChk(chainLength);
floatangle=chainLength/(2*Mathf.PI*chainRadius)*360*flippedY.SignFloat(1)*bendyness;
Vector3parentPos=rootBone.bendPos,localParentPos=rootBone.turnPos;
for(inti=0;i<boneCount;i++)
bones[i].bendPos=parentPos+rootBone.bendRot*(bones[i].turnPos-localParentPos).RotZ(angle*stepMulti*i);
parentPos=bones[i].bendPos;
localParentPos=bones[i].turnPos;
Vector3posA=bones[boneCount-2].bendPos;
Vector3posB=bones[boneCount-1].bendPos;
Vector3dir=flippedY?posA-posB:posB-posA;
bones[boneCount-1].bendRot=Quaternion.FromToRotation(V3.up,dir);
publicclassBone
publicVector3rigPos,squashPos,turnPos,bendPos;
publicQuaternionturnRot,bendRot;
publicvoidSetupBone(Vector3rigPos)
this.rigPos=rigPos;
publicPlacementGetBendPlacement(Vector3offset)
returnnewPlacement(bendPos+bendRot*offset,bendRot);
publicclassTBone:Bone
privateTransformtransform;
publicVector3updateScale=V3.one,twistScale=V3.zero;
publicQuaterniontwistRot=Quaternion.identity;
publicfloatchainLerp;
publicvoidSetupBone(Transformtransform,Vector3rigPos,floatchainLerp=0)
this.transform=transform;
this.rigPos=rigPos;
this.chainLerp=chainLerp;
transform.position=rigPos;
publicvoidSetXZScale(Vector3scale)
updateScale=scale.SetY(1);
publicvoidUpdateTransform()
transform.localPosition=bendPos;
transform.localRotation=bendRot*(turnRot*twistRot);
transform.localScale=updateScale+twistScale;
publicvoidSimpleUpdateTransform()
transform.localPosition=bendPos;
transform.localRotation=bendRot;
transform.localScale=updateScale;
publicclassRigDebug
[Switch("Char/RigRotators")]privatestaticboolshowRotators;
privatebooldrawSticks,drawBones,drawBend;
privatereadonlyRigPoserposer;
publicRigDebug(RigPoserposer)
DRAW.Enabled=DRAW.EditorDraw=true;
this.poser=poser;
publicvoidUpdate()
if(showRotators)
ActualPivot();
return;
ShowRootBones();
DrawLimbs();
DrawBend();
DrawBendChain();
privatevoidShowRootBones()
for(inti=0;i<poser.rig.rigParts.Length;i++)
DRAW.Circle(poser.transform.TransformPoint(poser.rig.rigParts[i].rootBone.turnPos),.25f,20).Fill(1);
privatevoidActualPivot()
if(poser.transform.position.y<-100)
return;
Vector3line=poser.transform.rotation*V3.forward*Level.PlaneOffset*.4f;
DRAW.Vector(poser.transform.position+line,line*-2).SetColor(COLOR.red.tomato);
DRAW.Vector(poser.HandRootPos.pos+line,line*-2).SetColor(COLOR.red.tomato);
DRAW.Vector(poser.FootRootPos.pos+line,line*-2).SetColor(COLOR.red.tomato);
for(inti=0;i<7;i++)
Vector3offset=-line+line*2/6f*i;
DRAW.Circle(poser.HandRootPos.pos+offset,poser.handRadius,12).SetColor(COLOR.red.tomato).Fill(1);
DRAW.Circle(poser.FootRootPos.pos+offset,poser.footRadius,12).SetColor(COLOR.red.tomato).Fill(1);
DRAW.Circle(poser.HandRootPos.pos,poser.handRadius+.15f,12).SetColor(COLOR.red.tomato);
DRAW.Circle(poser.FootRootPos.pos,poser.footRadius+.15f,12).SetColor(COLOR.red.tomato);
DRAW.Arrow(poser.HandRootPos.pos,poser.HandRootPos.rot*V3.up*.6f,.2f).SetColor(COLOR.red.tomato).Fill(1);
DRAW.Arrow(poser.FootRootPos.pos,poser.FootRootPos.rot*V3.down*.6f,.2f).SetColor(COLOR.red.tomato).Fill(1);
Vector3bodyV=poser.transform.rotation*newVector3(0,poser.height*.5f,0);
DRAW.Vector(poser.transform.position-bodyV,bodyV*2).SetColor(COLOR.yellow.fresh);
privatevoidDrawBendChain()
if(!GameManager.Running)
return;
for(intc=0;c<poser.mainChains.Length;c++)
for(inti=0;i<poser.mainChains[c].boneCount-1;i++)
Vector3p1=poser.transform.TransformPoint(poser.mainChains[c].bones[i].bendPos);
Vector3p2=poser.transform.TransformPoint(poser.mainChains[c].bones[i+1].bendPos);
Colorcolor=c==0?COLOR.blue.cornflower:(c==1?COLOR.red.tomato:COLOR.green.spring);
DRAW.Vector(p1,p2-p1).SetColor(color);
for(intc=0;c<2;c++)
DRAW.Circle(poser.transform.TransformPoint(poser.mainChains[c].Tip.bendPos),Item.DefaultRadius+.2f,12).SetColor(COLOR.orange.coral);
privatevoidDrawLimbs()
drawBones=drawBones.KeySwitch(KeyCode.I);
if(!drawBones)
return;
Vector3bodyPos=poser.transform.position;
QuaternionbodyRot=poser.transform.rotation;
RigPart[]rigParts=poser.rig.rigParts;
for(inti=0;i<rigParts.Length;i++)
for(inte=0;e<rigParts[i].boneCount-1;e++)
Colorc=Color.Lerp(COLOR.blue.cornflower,COLOR.purple.violet,e/(rigParts[i].boneCount-2f));
DRAW.DotVector(bodyPos+bodyRot*rigParts[i].bones[e].turnPos,bodyRot*(rigParts[i].bones[e+1].turnPos-rigParts[i].bones[e].turnPos),.045f,.005f).SetColor(c);
if(i<2)
continue;
DRAW.GapVector(bodyPos+bodyRot*rigParts[i].rootBone.turnPos,bodyRot*(rigParts[i].rootBone.bendRot*V3.up*rigParts[i].rootChainLength),5).SetColor(COLOR.red.tomato);
privateconstintpC=100;
privatereadonlyVector3[][][]lines=
new[]{newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC]},
new[]{newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC]},
new[]{newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC],newVector3[pC]}
privatevoidDrawBend()
drawBend=drawBend.KeySwitch(KeyCode.O);
if(!drawBend)
return;
Vector3bodyPos=poser.transform.position;
QuaternionbodyRot=poser.transform.rotation;
floatlineLength=poser.height*2;
for(inti=0;i<lines.Length;i++)
floatlerp=i/(lines.Length-1f);
floatz=Mathf.Lerp(poser.size.z*-.5f,poser.size.z*.5f,i/(lines.Length-1f));
Colorc=Color.Lerp(COLOR.green.lime,COLOR.yellow.fresh,lerp).A(.25f);
for(inte=0;e<lines[i].Length;e++)
floatx=Mathf.Lerp(poser.size.x*-.5f,poser.size.x*.5f,e/(lines[i].Length-1f));
for(intj=0;j<lines[i][e].Length;j++)
lines[i][e][j]=bodyPos+bodyRot*poser.GetBendPlacement(newVector3(x,-lineLength*.5f+j*(lineLength/(lines[i][e].Length-1)),z).MultiBy(poser.squashScale)).pos;
DRAW.Line(lines[i][e]).SetColor(c);
publicclassRigHead
[Switch("Char/FaceTest")]privatestaticboolgoCrazy;
publicreadonlyBonerootBone=newBone();
publicreadonlyTBone[]bones=CollectionInit.Array<TBone>(30);
publicQuaternionposeRot=Quaternion.identity;
publicfloatheight,yMin,yMax;
publicintboneCount;
publicvoidSetup(RigInfo[]headInfos,Rigrig)
boneCount=headInfos.Length;
for(inti=0;i<boneCount;i++)
RigInforigInfo=headInfos[i];
Meshmesh=rigInfo.mesh;
Boundsbounds=mesh.bounds;
if(i==0)
height=bounds.size.y;
yMin=bounds.min.y;
yMax=bounds.max.y;
rootBone.SetupBone(rigInfo.pos);
intboneIndex=rig.boneCount;
rig.boneCount++;
rig.bindPos[boneIndex]=rigInfo.pos;
bones[i].SetupBone(rig.bones[boneIndex],rigInfo.pos);
if(Application.isEditor)
rig.bones[boneIndex].name=rigInfo.partType.ToString();
mesh.GetVertices(readVertices);
intverticeCount=readVertices.Count;
mesh.GetColors(readColors);
readUVs.Clear();
for(inte=0;e<verticeCount;e++)
readUVs.Add(newVector2(readColors[e].r,readColors[e].a));
for(inte=0;e<verticeCount;e++)
bytereadPartID=readColors[e].r;
readColors[e]=newColor32(readPartID,(byte)(boneIndex),0,255);
mesh.SetColors(readColors);
mesh.SetUVs(0,readUVs);
publicvoidUpdateBones(RigPoserposer)
rootBone.squashPos=rootBone.rigPos.MultiBy(poser.squashScale);
rootBone.turnRot=poser.GetTurnRot(rootBone.squashPos.y);
rootBone.turnPos=rootBone.turnRot*rootBone.squashPos;
floatrootRadius=poser.GetBendRadius(rootBone.turnPos);
floatnoBendAngle=Circle.GetSegmentRad(height*poser.squashScale.y,rootRadius)*Mathf.Rad2Deg;
PlacementrootPlacement=poser.GetBendPlacement(rootBone.turnPos);
rootBone.bendPos=rootPlacement.pos;
rootBone.bendRot=Rot.Z(noBendAngle)*rootPlacement.rot*rootBone.turnRot;
for(inti=0;i<boneCount;i++)
bones[i].squashPos=bones[i].rigPos.MultiBy(poser.squashScale);
bones[i].turnRot=rootBone.turnRot;
boolcrazyEye=goCrazy&&(i==1||i==2);
bones[i].bendRot=!crazyEye?rootBone.bendRot:rootBone.bendRot*Rot.Z(GTime.Now*600*(i==1?1:-1));
bones[i].bendPos=rootBone.bendPos+rootBone.bendRot*(bones[i].squashPos-rootBone.squashPos);
floatblink=!(i==1||i==2)||Mathf.PerlinNoise(GTime.Now*3,.24f)>.35f?1:0;
bones[i].updateScale=!crazyEye?V3.one*blink:newVector3(3,1.5f,1);
bones[i].SimpleUpdateTransform();
privatestaticreadonlyList<Vector3>readVertices=newList<Vector3>(2000);
privatestaticreadonlyList<Color32>readColors=newList<Color32>(2000);
privatestaticreadonlyList<Vector2>readUVs=newList<Vector2>(2000);
publicclassRigPart
publicreadonlyBonerootBone=newBone();
publicreadonlyTBone[]bones=CollectionInit.Array<TBone>(30);
publicintboneCount;
publicfloatrootChainLength,stepMulti,bendyness,height,yMin,yMax;
publicboolflippedY,noRootBend;
publicPartTypepartType;
publicQuaternionposeRot=Quaternion.identity;
publicvirtualvoidSetup(RigInforigInfo,Rigrig)
partType=rigInfo.partType;
Meshmesh=rigInfo.mesh;
Boundsbounds=mesh.bounds;
height=bounds.size.y;
yMin=bounds.min.y;
yMax=bounds.max.y;
bendyness=rigInfo.bendyness;
flippedY=partType==PartType.LegL||partType==PartType.LegR;
noRootBend=partType==PartType.Torso;
rootBone.SetupBone(rigInfo.pos);
boneCount=rigInfo.boneCount;
stepMulti=boneCount>1?1f/(boneCount-1):0;
Vector3meshCenter=rigInfo.pos+(rigInfo.pos.x>0?bounds.center.FlipX():bounds.center);
Vector3top=newVector3(meshCenter.x,meshCenter.y+height*.5f,meshCenter.z);
Vector3bottom=newVector3(meshCenter.x,meshCenter.y-height*.5f,meshCenter.z);
intboneIndex=rig.boneCount;
rig.boneCount+=boneCount;
for(inti=0;i<boneCount;i++)
floatlerp=i*stepMulti;
Vector3pos=Vector3.Lerp(bottom,top,flippedY?1-lerp:lerp);
intbindIndex=boneIndex+i;
rig.bindPos[bindIndex]=pos;
bones[i].SetupBone(rig.bones[bindIndex],pos,lerp);
if(Application.isEditor)
rig.bones[boneIndex+i].name=rigInfo.partType+"_"+i.ToString("D2");
rootChainLength=Mathf.Abs(bones[boneCount-1].rigPos.y-rootBone.rigPos.y);
mesh.GetVertices(readVertices);
intverticeCount=readVertices.Count;
mesh.GetColors(readColors);
readUVs.Clear();
for(inti=0;i<verticeCount;i++)
readUVs.Add(newVector2(readColors[i].r,readColors[i].a));
floatstep=height*stepMulti;
for(inti=0;i<verticeCount;i++)
bytereadPartID=readColors[i].r;
floatverticeY=flippedY?yMax-(readVertices[i].y-yMin):readVertices[i].y;
floatlerp=Mathf.InverseLerp(yMin,yMax,verticeY)*(boneCount-1);
intminIndex=Mathf.FloorToInt(lerp);
intmaxIndex=Mathf.CeilToInt(lerp);
if(minIndex==maxIndex)
readColors[i]=newColor32(readPartID,(byte)(minIndex+boneIndex),0,255);
continue;
floatboneAHeight=yMin+minIndex*step;
floatboneBHeight=yMin+maxIndex*step;
floatboneLerp=Mathf.InverseLerp(boneAHeight,boneBHeight,verticeY);
boolfirstIsCloser=boneLerp<.5f;
readColors[i]=newColor32(readPartID,
(byte)((firstIsCloser?minIndex:maxIndex)+boneIndex),//Main
(byte)((firstIsCloser?maxIndex:minIndex)+boneIndex),//Secondary
(byte)(255*(firstIsCloser?1-boneLerp:boneLerp)));//Lerp
mesh.SetColors(readColors);
mesh.SetUVs(0,readUVs);
publicvirtualvoidSetTwist(Vector2poseTwist)
floatangle=poseTwist.y-poseTwist.x;
constfloatantiScale=1f/360*-.7f;
floattwist=Mathf.Abs(angle)*antiScale;
floatmulti=1f/(boneCount-1f);
for(inti=0;i<boneCount;i++)
floatlerp=-1+bones[i].chainLerp*2;
floatscaleLerp=Mathf.Pow(Mathf.Cos(Mathf.PI*lerp*.5f),2.5f).NaNChk();
floattwistScale=twist*scaleLerp;
bones[i].twistScale=newVector3(twistScale,0,twistScale);
bones[i].twistRot=Rot.Y(poseTwist.x+angle*i*multi);
publicvirtualvoidUpdateBones(RigPoserposer)
rootBone.squashPos=rootBone.rigPos.MultiBy(poser.squashScale);
rootBone.turnRot=poser.GetTurnRot(rootBone.squashPos.y);
rootBone.turnPos=rootBone.turnRot*rootBone.squashPos;
for(inti=0;i<boneCount;i++)
bones[i].squashPos=bones[i].rigPos.MultiBy(poser.squashScale);
bones[i].turnRot=poser.GetTurnRot(bones[i].squashPos.y);
bones[i].turnPos=bones[i].turnRot*bones[i].squashPos;
QuaternionanimPoseRot=Quaternion.FromToRotation(V3.up,rootBone.turnRot*poseRot*V3.up);
if(noRootBend)
for(inti=0;i<boneCount;i++)
bones[i].bendPos=poser.GetBendPlacement(bones[i].turnPos,false).pos;
else
floatrootRadius=poser.GetBendRadius(rootBone.turnPos);
floatnoBendAngle=Circle.GetSegmentRad(rootChainLength*poser.squashScale.y,rootRadius)*Mathf.Rad2Deg*flippedY.SignFloat(1);
PlacementrootPlacement=poser.GetBendPlacement(rootBone.turnPos);
rootBone.bendPos=rootPlacement.pos;
rootBone.bendRot=Rot.Z(noBendAngle*(1-bendyness))*rootPlacement.rot;
floatchainRadius=poser.GetBendRadius(bones[0].turnPos);
floatchainLength=height*poser.squashScale.y;
floatstepLength=chainLength*stepMulti;
floatbendLength=Mathf.Abs(Circle.GetSegmentRad(stepLength,chainRadius)*chainRadius*(boneCount-1)*2);
chainLength=bendLength.NaNChk(chainLength);
floatangle=chainLength/(2*Mathf.PI*chainRadius)*360*flippedY.SignFloat(1)*bendyness;
Vector3parentPos=rootBone.bendPos,localParentPos=rootBone.turnPos;
for(inti=0;i<boneCount;i++)
QuaternionboneRot=Rot.Z(angle*bones[i].chainLerp);
bones[i].bendPos=parentPos+animPoseRot*(rootBone.bendRot*boneRot)*(bones[i].turnPos-localParentPos);
parentPos=bones[i].bendPos;
localParentPos=bones[i].turnPos;
if(boneCount>1)
for(inti=0;i<boneCount;i++)
Vector3dirA=i>0?bones[i].bendPos-bones[i-1].bendPos:bones[i+1].bendPos-bones[i].bendPos;
Vector3dirB=i<boneCount-1?bones[i+1].bendPos-bones[i].bendPos:bones[i].bendPos-bones[i-1].bendPos;
if(flippedY)
dirA*=-1;
dirB*=-1;
bones[i].bendRot=Quaternion.FromToRotation(V3.up,Vector3.Lerp(dirA,dirB,.5f));
else
bones[0].bendRot=rootBone.bendRot;
for(inti=0;i<boneCount;i++)
bones[i].SetXZScale(poser.squashScale);
bones[i].UpdateTransform();
privatestaticreadonlyList<Vector3>readVertices=newList<Vector3>(2000);
privatestaticreadonlyList<Color32>readColors=newList<Color32>(2000);
privatestaticreadonlyList<Vector2>readUVs=newList<Vector2>(2000);
publicclassRigPoser
[Switch("Anim/TwistTest")]privatestaticbooltwistTest;
[Switch("Anim/TurnTest")]protectedstaticboolturnIt=false;
privatefloatbend,tBend,bBend,tRadius,bRadius,turn,tTurn,bTurn,btTurnDir;
publicVector3squashScale;
privatebooltStraight,bStraight;
publicreadonlyRigrig;
privatereadonlyGameObjectgameObject;
publicreadonlyTransformtransform;
publicreadonlyBendPart[]mainChains=CollectionInit.Array<BendPart>(2);
publicfloatheight;
privatefloatmin,max,torsoMin,torsoMax;
publicVector3size;
privatefloathandZ,footZ;
privateRigParttorso,armL,armR,legL,legR;
privateRigHeadhead;
privateconstintarmC=0,legC=1;
publicfloathandRadius,footRadius;
publicreadonlyPosecurrentPose=newPose();
privatereadonlySpinnerShadow[]shadows;
publicRigPoser(Rigrig,Spinnerspinner)
this.rig=rig;
transform=rig.transform;
gameObject=transform.gameObject;
TransformspinnerShadow="SpinnerShadow".ResourceInst(transform.parent).SetName("SpinnerShadow").transform;
shadows=spinnerShadow.GetComponentsInChildren<SpinnerShadow>();
for(ints=0;s<shadows.Length;s++)
shadows[s].spinner=spinner;
publicvoidFinishSetup(Vector3size,Vector3hands,Vector3feet)
head=rig.rigHead;
torso=GetPart(PartType.Torso);
armL=GetPart(PartType.ArmL);
armR=GetPart(PartType.ArmR);
legL=GetPart(PartType.LegL);
legR=GetPart(PartType.LegR);
height=hands.y-feet.y-Item.DefaultRadius*2;
min=height*-.5f;
max=height*.5f;
this.size=size.SetY(height);
torsoMin=(torso.yMin+legL.yMax)*.5f;
torsoMax=(torso.yMax+armL.yMin)*.5f;
mainChains[armC].CreateBendChain(armL);
mainChains[legC].CreateBendChain(legL);
handZ=hands.z-mainChains[armC].Tip.rigPos.z;
footZ=feet.z-mainChains[legC].Tip.rigPos.z;
for(ints=0;s<shadows.Length;s++)
shadows[s].Setup(this.size);
privateRigPartGetPart(PartTypepartType)
for(inti=0;i<rig.rigParts.Length;i++)
if(rig.rigParts[i].partType==partType)
returnrig.rigParts[i];
returnnull;
privatevoidSetPoseValues(Posepose,floatsquash)
bend=pose[Pose.Lean]*.3f;
if(bend>=-.0001f&&bend<=.0001f)
bend=0;
tBend=pose[Pose.Lean]*.3f+pose[Pose.BendT];
if(tBend>=-.0001f&&tBend<=.0001f)
tBend=0;
bBend=pose[Pose.Lean]*.3f+pose[Pose.BendB];
if(bBend>=-.0001f&&bBend<=.0001f)
bBend=0;
tStraight=f.Same(tBend,0);
bStraight=f.Same(bBend,0);
tTurn=pose[Pose.TurnT]*360;
bTurn=pose[Pose.TurnB]*360;
turn=(tTurn+bTurn)*.5f;
btTurnDir=tTurn-bTurn;
bRadius=1/bBend/2/Mth.*height;
tRadius=1/tBend/2/Mth.*height;
squashScale=size.GetFactors(size.VolumeScaleY(squash));
privatevoidTumbleAnim(floattumbleT,floattumbleB)
floattumbleTime=GameManager.Running?GTime.Now:Time.realtimeSinceStartup;
armL.poseRot=Quaternion.Euler(16*tumbleT,0,14*tumbleT)*Quaternion.FromToRotation(V3.up,V3.up.RotZ(14*tumbleT).RotY(tumbleTime*540));
armR.poseRot=Quaternion.Euler(16*tumbleT,0,-14*tumbleT)*Quaternion.FromToRotation(V3.up,V3.up.RotZ(-14*tumbleT).RotY(tumbleTime*-540));
legL.poseRot=Quaternion.Euler((11+Mathf.Sin(tumbleTime*8)*38)*tumbleB,0,-10*tumbleB);
legR.poseRot=Quaternion.Euler((11+Mathf.Sin(tumbleTime*8)*-38)*tumbleB,0,10*tumbleB);
publicPlacementGetBendPlacement(Vector3point,boolgetRot=true)
booltop=point.y>0;
if(top&&tStraight||!top&&bStraight)
returnnewPlacement(point,Rot.Zero);
floatcheckBend=top?tBend:bBend;
floatcheckRadius=top?tRadius:bRadius;
floatbodyLerp=Mathf.InverseLerp(min,max,point.y);
floatradFraction=checkBend*(1-bodyLerp-.5f)*Mth.*2;
Vector3circlePos=Circle.GetPos(checkRadius-point.x,Mth.+radFraction);
returnnewPlacement(newVector3(checkRadius+circlePos.x,circlePos.y,point.z),
getRot?Rot.Z(radFraction*Mathf.Rad2Deg):Quaternion.identity);
publicfloatGetBendRadius(Vector3point)
booltop=point.y>0;
return(top?tRadius:bRadius)-point.x;
publicQuaternionGetTurnRot(floaty)
floatlerp=Mathf.InverseLerp(torsoMin,torsoMax,y);
floatangle=bTurn+btTurnDir*lerp;
returnRot.Y(angle);
publicPlacementGetSwingOffset(Posepose,floatsquash,boolhands,floatitemRadius)
handRadius=hands?itemRadius:Item.DefaultRadius*.5f;
footRadius=!hands?itemRadius:Item.DefaultRadius*.5f;
SetPoseValues(pose,squash);
for(inti=0;i<mainChains.Length;i++)
mainChains[i].CalculateBend(this);
Vector3grabOffset=(hands?newVector3(0,itemRadius,handZ):newVector3(0,-itemRadius,footZ)).RotY(turn);
PlacementgrabPoint=mainChains[hands?armC:legC].Tip.GetBendPlacement(grabOffset).ZeroZ();
constfloatlimit=.6666667f;
returnnewPlacement(-grabPoint.pos,Quaternion.FromToRotation(grabPoint.pos,hands?V3.up:V3.down).Limit(limit));
publicvoidSetPose(Placementplacement,Posepose,floatsquash)
if(turnIt)
floatbaseTurn=GTime.Now*-2.2f;
constfloatextra=.03f;
floatextraAngle=Mth.SmoothPP(extra,-extra,GTime.Now*3f);
pose.Set(Pose.TurnT,pose[Pose.TurnT]+baseTurn+extraAngle).
Set(Pose.TurnB,pose[Pose.TurnB]+baseTurn-extraAngle);
currentPose.Copy(pose);
SetPoseValues(currentPose,squash);
if(true)
TumbleAnim(pose[Pose.TumbleT],pose[Pose.TumbleB]);
constfloatheadRange=18;
QuaternionheadRot=Quaternion.FromToRotation(V3.forward,V3.forward.RotX(-headRange).RotZ(GTime.Now*250));
head.poseRot=Rot.X(-headRange)*headRot;
if(twistTest)
Vector2testTwist=newVector2(0,Mth.SmoothPP(GTime.Now)*180);
armL.SetTwist(testTwist);
armR.SetTwist(testTwist);
legL.SetTwist(testTwist);
legR.SetTwist(testTwist);
head.UpdateBones(this);
for(inti=0;i<rig.rigParts.Length;i++)
rig.rigParts[i].UpdateBones(this);
transform.SetPlacement(placement);
for(ints=0;s<shadows.Length;s++)
shadows[s].ManualUpdate(transform.position.z<0,turn,squashScale);
publicPlacementHandRootPos
get
Placementp=mainChains[armC].Tip.GetBendPlacement(newVector3(0,handRadius,handZ).RotY(turn)).ZeroZ();
returnnewPlacement(transform.TransformPoint(p.pos),transform.rotation*p.rot);
publicPlacementFootRootPos
get
Placementp=mainChains[legC].Tip.GetBendPlacement(newVector3(0,-footRadius,footZ).RotY(turn)).ZeroZ();
returnnewPlacement(transform.TransformPoint(p.pos),transform.rotation*p.rot);
publicvoidSetActive(boolactive)
if(!active)
SetPose(Placement.OutOfSight,Pose.Reader.Zero(),1);
gameObject.SetActive(active);
for(inti=0;i<shadows.Length;i++)
shadows[i].gameObject.SetActive(active);
publicclassOldRig:MonoBehaviour{
publicAnimatoranimator;
publicAnimationClip[]clips;
privateintanim;
privatevoidUpdate()
if(Input.GetKeyDown(KeyCode.P))
anim=(anim+1)%clips.Length;
animator.SetFloat("Anim",anim/(clips.Length-1f));
animator.Play(0);
Debug.Log(clips[anim].name);
publicabstractclassCustomMaterialEditor:MaterialEditor
publicclassFeatureToggle
publicstringInspectorName;
publicstringInspectorPropertyHideTag;
publicstringShaderKeywordEnabled;
publicstringShaderKeywordDisabled;
publicboolEnabled;
publicFeatureToggle(stringInspectorName,stringInspectorPropertyHideTag,stringShaderKeywordEnabled,stringShaderKeywordDisabled)
this.InspectorName=InspectorName;
this.InspectorPropertyHideTag=InspectorPropertyHideTag;
this.ShaderKeywordEnabled=ShaderKeywordEnabled;
this.ShaderKeywordDisabled=ShaderKeywordDisabled;
this.Enabled=false;
protectedList<FeatureToggle>Toggles=newList<FeatureToggle>();
protectedabstractvoidCreateToggleList();
publicoverridevoidOnInspectorGUI()
if(!isVisible)
return;
MaterialtargetMat=targetasMaterial;
string[]oldKeyWords=targetMat.shaderKeywords;
Toggles=newList<FeatureToggle>();
CreateToggleList();
for(inti=0;i<Toggles.Count;i++)
Toggles[i].Enabled=oldKeyWords.Contains(Toggles[i].ShaderKeywordEnabled);
EditorGUI.BeginChangeCheck();
serializedObject.Update();
vartheShader=serializedObject.FindProperty("m_Shader");
if(isVisible&&!theShader.hasMultipleDifferentValues&&theShader.objectReferenceValue!=null)
floatcontrolSize=64;
EditorGUIUtility.labelWidth=Screen.width-controlSize-20;
EditorGUIUtility.fieldWidth=controlSize;
Shadershader=theShader.objectReferenceValueasShader;
EditorGUI.BeginChangeCheck();
for(inti=0;i<ShaderUtil.GetPropertyCount(shader);i++)
ShaderPropertyImpl(shader,i,null);
for(ints=0;s<Toggles.Count;s++)
EditorGUILayout.Separator();
Toggles[s].Enabled=EditorGUILayout.BeginToggleGroup(Toggles[s].InspectorName,Toggles[s].Enabled);
if(Toggles[s].Enabled)
for(inti=0;i<ShaderUtil.GetPropertyCount(shader);i++)
ShaderPropertyImpl(shader,i,Toggles[s]);
EditorGUILayout.EndToggleGroup();
if(EditorGUI.EndChangeCheck())
PropertiesChanged();
if(EditorGUI.EndChangeCheck())
List<string>newKeyWords=newList<string>();
for(inti=0;i<Toggles.Count;i++)
newKeyWords.Add(Toggles[i].Enabled?Toggles[i].ShaderKeywordEnabled:Toggles[i].ShaderKeywordDisabled);
targetMat.shaderKeywords=newKeyWords.ToArray();
EditorUtility.SetDirty(targetMat);
privatevoidShaderPropertyImpl(Shadershader,intpropertyIndex,FeatureTogglecurrentToggle)
stringpropertyDescription=ShaderUtil.GetPropertyDescription(shader,propertyIndex);
if(currentToggle==null)
for(inti=0;i<Toggles.Count;i++)
if(Regex.IsMatch(propertyDescription,Toggles[i].InspectorPropertyHideTag,RegexOptions.IgnoreCase))
return;
elseif(!Regex.IsMatch(propertyDescription,currentToggle.InspectorPropertyHideTag,RegexOptions.IgnoreCase))
return;
ShaderProperty(shader,propertyIndex);
publicclassMainMatEditor:CustomMaterialEditor
protectedoverridevoidCreateToggleList()
Toggles.Add(newFeatureToggle("UseTextures","MainTex","USETEX_ON","USETEX_OFF"));
